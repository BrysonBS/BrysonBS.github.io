<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-享元模式</title>
      <link href="/2020/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="享元模式的定义"><a href="#享元模式的定义" class="headerlink" title="享元模式的定义"></a>享元模式的定义</h4><blockquote><p>*<em>享元(Flyweight)模式: *</em> 运用共享技术来有效地支持大量细粒度对象的复用,它通过共享已经存在的对象来大幅减少需要创建的对象的数量丶避免创建大量相似对象的开销,从而提高系统资源利用率</p><ul><li>如线程池</li></ul></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>*<em>优点: *</em><ul><li>相同的对象只保存一份,这降低了系统中对象的数量,从而降低了系统中细粒度对象给内存带来的压力</li></ul></li><li>*<em>缺点: *</em><ul><li>为了使对象可以共享,需要将一些不能共享的状态外部化,这将增加程序的复杂性</li><li>读取享元模式的外部状态会使得运行时间稍微变长</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p><strong>模式的结构</strong></p><ul><li><p><strong>抽象享元角色（Flyweight）:</strong>是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入</p></li><li><p><strong>具体享元（Concrete Flyweight）角色：</strong>实现抽象享元角色中所规定的接口</p></li><li><p><strong>非享元（Unsharable Flyweight)角色：</strong>是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中</p></li><li><p><strong>享元工厂（Flyweight Factory）角色：</strong>负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象</p><p><img src="data:image/gif;base64,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" alt="avatar" title="享元模式结构图"></p></li></ul><p>图中UnsharedConcreteFlyweight是非享元角色,里面包含了非共享的外部状态信息info,而Flyweight是抽象享元角色,里面包含了享元方法operation(UnsharedConcreteFlyweight state),非享元的外部状态以参数的形式传入</p></li><li><p>模式的实现**</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 享元模式: * 通俗的说: 就是对于相同的对象可以共享的方式使用,不需要频繁创建新对象, * 对于非共享内容可以通过参数方式传递给共享对象 */</span><span class="token comment" spellcheck="true">//非享元角色 - 非共享的通过参数传递给具体享元角色</span><span class="token keyword">class</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String info<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> info<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> info<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setInfo</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> info<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象享元角色</span><span class="token keyword">interface</span> <span class="token class-name">Flyweight</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>UnsharedConcreteFlyweight state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体享元角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String key<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteFlyweight</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体享元"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">"被创建!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>UnsharedConcreteFlyweight state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"具体享元"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">"被调用!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"非具体享元"</span><span class="token operator">+</span>state<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//享元工厂</span><span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Flyweight<span class="token operator">></span> flyweights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Flyweight <span class="token function">getFlyweight</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token punctuation">{</span>        Flyweight flyweight <span class="token operator">=</span> flyweights<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flyweight <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体想元"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">"已经存在,被成功获取!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            flyweight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            flyweights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>flyweight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> flyweight<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//客户端</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightPattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FlyweightFactory factory<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f01<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f02<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f03<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f11<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f12<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f01<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第1次调用a。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f02<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第2次调用a。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f03<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第3次调用a。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f11<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第1次调用b。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f12<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第2次调用b。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-外观模式</title>
      <link href="/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="外观模式的定义"><a href="#外观模式的定义" class="headerlink" title="外观模式的定义"></a>外观模式的定义</h4><blockquote><p>*<em>外观(Facade)模式: *</em> 是一种通过为多个复杂的子系统提供一个一致的接口,而使这些子系统更加容易被访问的模式,该模式对外有一个统一接口,外部应用程序不用关心内部子系统的具体细节,这样会大大降低应用程序的复杂度,提交了程序的可维护性</p><p>*<em>通俗的说: *</em>就是将所有子系统委托给一个对象去管理,客户端调用子系统时全部都从这个对象中使用即可</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p>*<em>优点: *</em> 是”迪米特法则”的典型应用</p><ul><li>降低了子系统与客户端之间的耦合度,使得子系统的变化不会影响调用它的客户类</li><li>对客户屏蔽了子系统组件,减少了客户处理的对象数目,使得子系统使用起来更加容易</li><li>降低了大型软件系统中的编译依赖性,简化了系统在不同平台之间的移植过程,因为编译一个子系统不会影响其他的子系统,也不会影响外观对象</li></ul></li><li><p>*<em>缺点: *</em></p><ul><li>不能很好的限制客户使用子类系统</li><li>增加新的子系统可能需要修改外观类或者客户端的源代码,违背”开闭原则”</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p>*<em>模式的结构: *</em></p><ul><li><p><strong>外观（Facade）角色：</strong>为多个子系统对外提供一个共同的接口。</p></li><li><p><strong>子系统（Sub System）角色：</strong>实现系统的部分功能，客户可以通过外观角色访问它。</p></li><li><p><strong>客户（Client）角色：</strong>通过一个外观角色访问各个子系统的功能。</p></li></ul><p><img src="data:image/gif;base64,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" alt="avatar" title="外观(Facade)模式结构图"></p></li><li><p><strong>模式的实现</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 外观模式 * 通俗的说: 将所有子系统的维护到一个对象(外观角色)中去,客户端使用时只需从该对象调用即可 */</span><span class="token comment" spellcheck="true">//外观角色</span><span class="token keyword">class</span> <span class="token class-name">Facade</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//被委托的子系统对象</span>    <span class="token keyword">private</span> SubSystem01 system01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubSystem01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> SubSystem02 system02 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubSystem02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> SubSystem03 system03 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubSystem03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//提供给外部访问的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        system01<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        system02<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        system03<span class="token punctuation">.</span><span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubSystem01</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子系统01的method1()被调用!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubSystem02</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子系统02的method2()被调用!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubSystem03</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子系统03的method3()被调用!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FacadePattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Facade facade <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Facade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        facade<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰模式</title>
      <link href="/2020/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="装饰模式的定义"><a href="#装饰模式的定义" class="headerlink" title="装饰模式的定义"></a>装饰模式的定义</h4><blockquote><p>*<em>装饰(Decorator)模式: *</em> 指在不改变现有对象结构的情况下,动态的给该对象增加一些职责(即增加额外功能)的模式,它属于对象结构型模式</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>*<em>优点: *</em><ul><li>采用装饰模式扩展对象的功能比采用继承方式更加灵活</li><li>可以设计出多个不同的具体装饰类,创造出多个不同行为的组合(Java IO即采用装饰模式)</li></ul></li><li>*<em>缺点: *</em><ul><li>装饰模式增加了许多子类,如果过度使用会使程序变得很复杂</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><blockquote><p>通过组合关系来包装对象,达到扩展对象功能的目的,同时实现统一接口,可以传入同类型对象达到互相装饰效果</p></blockquote><ol><li><p><strong>模式的结构</strong></p><ul><li><p><strong>抽象构件（Component）角色：</strong>定义一个抽象接口以规范准备接收附加责任的对象</p></li><li><p><strong>具体构件（Concrete  Component）角色：</strong>实现抽象构件，通过装饰角色为其添加一些职责</p></li><li><p><strong>抽象装饰（Decorator）角色：</strong>继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</p></li><li><p><strong>具体装饰（ConcreteDecorator）角色：</strong>实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</p><p><img src="data:image/gif;base64,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" alt="avatar" title="装饰模式结构图"></p></li></ul></li><li><p><strong>模式的实现</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰模式 * 通俗说就是使用组合将对象传入,然后进行扩展, * 同时实现统一的接口,传入对象类型为接口类型,可以使具体构件达到互相装饰的效果 */</span><span class="token comment" spellcheck="true">//抽象构件角色: 统一接口</span><span class="token keyword">interface</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体构件角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建具体构件角色"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用具体构件角色的方法operation()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象装饰角色</span><span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用组合传入具体构件</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        component<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用具体构件的方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体装饰角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//增加额外功能</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"为具体构件角色增加额外的功能addedFunction()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DecoratorPattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-桥接模式</title>
      <link href="/2020/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="桥接模式的定义"><a href="#桥接模式的定义" class="headerlink" title="桥接模式的定义"></a>桥接模式的定义</h4><blockquote><p>*<em>桥接(Bridge)模式: *</em> 将抽象与实现分离,使他们可以独立变化,它是用组合关系代替继承关系来实现的,从而降低了抽象与实现这两个可变维度的耦合度</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>*<em>优点: *</em><ul><li>由于抽象与实现分离,所以扩展能力强</li><li>其实现细节对客户透明</li></ul></li><li>*<em>缺点: *</em><ul><li>由于聚合关系建立在抽象层,要求开发者针对抽象化进行设计与编程,这增加了系统的理解与设计难度</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p><strong>模式的结构</strong></p><ul><li><p><strong>抽象化（Abstraction）角色：</strong>定义抽象类，并包含一个对实现化对象的引用</p></li><li><p><strong>扩展抽象化（Refined  Abstraction）角色：</strong>是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</p></li><li><p><strong>实现化（Implementor）角色：</strong>定义实现化角色的接口，供扩展抽象化角色调用</p></li><li><p><strong>具体实现化（Concrete Implementor）角色：</strong>给出实现化角色接口的具体实现</p></li></ul><p><img src="data:image/gif;base64,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" alt="avatar" title="桥接模式结构图"></p></li><li><p><strong>模式的实现</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 桥接模式 * 通俗理解: 如果有两个接口或抽象类: 颜色与形状,现在要创建一个图形(包含颜色形状) *  方案1. 实现两个接口成为新类即新的图形,缺点是如果有很多其他颜色的图形那需要很多个实现类 *  方案2. 实现图形接口,在内部维护一个颜色对象,此时,只需要传入不同颜色对象即可生成不同颜色图形,即使用桥接模式 */</span><span class="token comment" spellcheck="true">//实现化角色: 如颜色</span><span class="token keyword">interface</span> <span class="token class-name">Implementor</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体实现化角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorA</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体实现化角色被访问"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象化角色: 如形状</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//内部维护一个实现化角色:如颜色对象</span>    <span class="token keyword">protected</span> Implementor imple<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>Implementor imple<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>imple <span class="token operator">=</span> imple<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩展抽象化角色</span><span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token function">RefinedAbstraction</span><span class="token punctuation">(</span>Implementor imple<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>imple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"扩展抽象化角色被访问"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        imple<span class="token punctuation">.</span><span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BridgeTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Implementor imple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Abstraction abs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefinedAbstraction</span><span class="token punctuation">(</span>imple<span class="token punctuation">)</span><span class="token punctuation">;</span>        abs<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="/2020/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="适配器模式定义"><a href="#适配器模式定义" class="headerlink" title="适配器模式定义"></a>适配器模式定义</h4><blockquote><p><strong>适配器模式(Adapter): ** 将一个类的接口转换成客户希望的另外一个接口,是的原本由于接口不兼容而不能一起工作的那些类能一起工作,失配模式分为</strong>类结构型模式<strong>和</strong>对象接口型模式**,前者类之间的耦合度比后者高,使用较少</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>*<em>优点: *</em><ul><li>客户端通过适配器可以透明的调用目标接口</li><li>复用了现存的类,程序员不需要修改原有代码而重用现有的适配者类</li><li>将目标类和适配者类解耦,解决了目标类和适配者类接口不一致的问题</li></ul></li><li>*<em>缺点: *</em><ul><li>对类适配器来说,更换适配器的实现过程比较复杂</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p><strong>模式的结构</strong></p><ul><li><p>目标(Target)接口：当前系统业务所期待的接口，它可以是抽象类或接口</p></li><li><p>适配者(Adaptee)类：它是被访问和适配的现存组件库中的组件接口</p></li><li><p>适配器(Adapter)类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者</p></li></ul><p><strong>类适配器模式结构图</strong></p><p><img src="data:image/gif;base64,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" alt="avatar" title="类适配器模式结构图"></p><p><strong>对象适配器模式结构图</strong></p><p><img src="data:image/gif;base64,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" alt="avatar" title="对象适配器模式结构图"></p></li><li><p><strong>模式的实现</strong></p><ul><li><p>目标与适配者</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//目标接口</span><span class="token keyword">interface</span> <span class="token class-name">Target</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//适配者接口</span><span class="token keyword">class</span> <span class="token class-name">Adaptee</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">secificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配者中的业务代码被调用!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类适配器模式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 类适配器模式 * 定义一个适配器类实现当前系统的业务接口,同时又继承现有组件库中已存在的组件 */</span><span class="token comment" spellcheck="true">//适配器类</span><span class="token keyword">class</span> <span class="token class-name">ClassAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adaptee</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">secificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用适配者的方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//客户端代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassAdapterTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类适配器模式测试:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对象适配器模式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 对象适配器模式 * 将现有组件库中已经实现的的组件引入适配器类中,该类同时实现当前系统的业务接口 */</span><span class="token comment" spellcheck="true">//对象适配器类</span><span class="token keyword">class</span> <span class="token class-name">ObjectAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//内部维护一个适配者对象</span>    <span class="token keyword">private</span> Adaptee adaptee<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ObjectAdapter</span><span class="token punctuation">(</span>Adaptee adaptee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adaptee <span class="token operator">=</span> adaptee<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        adaptee<span class="token punctuation">.</span><span class="token function">secificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用适配者的方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//客户端代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectAdapterTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象适配器模式测试："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Adaptee adaptee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adaptee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectAdapter</span><span class="token punctuation">(</span>adaptee<span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理模式</title>
      <link href="/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h4><blockquote><p><strong>代理模式:</strong> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问,这时,访问对象不适合或者不能直接引用目标对象,代理对象作为访问对象和目标对象之间的中介</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>*<em>优点: *</em><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能</li><li>代理模式能将客户端与目标对象分离,在一定程度上降低了系统的耦合度</li></ul></li><li>*<em>缺点: *</em><ul><li>在客户端和目标对象之间增加一个代理对象,会造成请求处理速度变慢</li><li>增加了系统复杂度</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p><strong>模式的结构</strong></p><ul><li><p>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</p></li><li><p>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</p></li><li><p>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能</p></li></ul><p><img src="data:image/gif;base64,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" alt="avatar" title="代理模式结构图"></p></li><li><p><strong>模式的实现</strong></p><ul><li><p><strong>静态代理</strong></p><ul><li>代理对象和目标对象实现相同的接口(保证代理对象与目标对象类型一致,面向接口编程代理对象可完全替换目标对象进行传参)</li></ul></li><li><p>可以做到不修改目标对象功能的前提下对目标对象进行扩展</p><ul><li>一旦接口增加方法,目标对象与代理对象都需要维护(缺点)</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象主题</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Dao</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//真实主题</span><span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token keyword">implements</span> <span class="token class-name">Dao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//代理</span><span class="token keyword">class</span> <span class="token class-name">UserDaoProxy</span> <span class="token keyword">implements</span> <span class="token class-name">Dao</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>userDao <span class="token operator">==</span> null<span class="token punctuation">)</span> userDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存前进行的事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存后进行的事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><ul><li><p><strong>动态代理(接口代理)</strong></p><ul><li><p>解决了静态代理的缺点</p></li><li><p>使用JDK提供的api动态的在内存重生成代理对象(又叫jdk代理,接口代理)</p></li><li><p>代理对象类型为实现接口的类型(不能强转为实现类类型)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象主题</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Dao</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//真实主题</span> <span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token keyword">implements</span> <span class="token class-name">Dao</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//动态代理工厂</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//通过构造函数传入目标对象</span>     <span class="token keyword">private</span> Object target<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token function">ProxyFactory</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//生成代理对象的方法</span>     <span class="token keyword">public</span> Object <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>                 target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                     Object value <span class="token operator">=</span> null<span class="token punctuation">;</span>                     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//只对save方法进行代理</span>                         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开启事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         value <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"事务结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token punctuation">}</span>                     <span class="token keyword">else</span> value <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token keyword">return</span> value<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>         <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><ul><li><p><strong>cglib代理(子类代理)</strong></p><ul><li><p>需要引入jar包(spring3.2以上core包中已经集成)</p></li><li><p>在内存重构建一个子类对象,从而实现对目标对象的扩展</p></li><li><p>代理类需要实现MethodInterceptor接口</p></li><li><p>需要代理的类不能为final或static(会报错),同时方法不能final(此时不报错,但是不能拦截该方法)</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//代理工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//传入目标对象</span>        <span class="token keyword">private</span> Object target<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">ProxyFactory</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//给目标对象创建代理对象</span><span class="token keyword">public</span> Object <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Enhancer en <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//工具类</span>    en<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置代理对象父类</span>    en<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//设置回调函数</span>        <span class="token comment" spellcheck="true">//回调函数作用: 执行目标对象的方法会触发执行重写的intercept的方法</span>    <span class="token keyword">return</span> en<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//创建子类并返回</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//重写的intercept方法    </span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span>Method method<span class="token punctuation">,</span>object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span>MethodProxy proxy<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“开始事务”<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object value <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//执行目标对象的方法</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“提交事务”<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/2020/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="建造者模式的定义"><a href="#建造者模式的定义" class="headerlink" title="建造者模式的定义"></a>建造者模式的定义</h4><blockquote><p>*<em>建造者(Builder)模式: *</em> 指将一个复杂对象的构造与它的表示分离,使同样的构建过程可以创建不同的表示,这样的设计模式被称为建造者模式,它是将一个复杂的对象分解为多个简单的对象,然后一步一步构建而成,它将变与不变想分离,即产品的组成部分是不变的,但是每一部分是可以灵活选择的</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>*<em>优点: *</em><ul><li>各个具体的建造者相互独立,有利于系统的扩展</li><li>客户端不必知道产品内部组成的细节,便于控制细节风险</li></ul></li><li>*<em>缺点: *</em><ul><li>产品的组成部分必须相同,这限制了其使用范围</li><li>如果产品的内部变化复杂,该模式会增加很多的建造者类</li></ul></li><li>建造者模式和工厂模式的关注点不同: 建造者模式注重零部件的组装过程,而工厂方法模式更注重零部件的创建过程,但两者可以结合使用</li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p><strong>模式的结构</strong></p><ul><li><p><strong>产品角色（Product）：</strong>它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件</p></li><li><p><strong>抽象建造者（Builder）：</strong>它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()</p></li><li><p><strong>具体建造者(Concrete Builder）：</strong>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法</p></li><li><p><strong>指挥者（Director）：</strong>它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息</p></li></ul><p><img src="data:image/gif;base64,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" alt="avatar" title=" 建造者模式结构图"></p></li><li><p><strong>模式的实现</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//产品角色:包含多个组成部件的复杂对象</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String partA<span class="token punctuation">;</span>    <span class="token keyword">private</span> String partB<span class="token punctuation">;</span>    <span class="token keyword">private</span> String partC<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartA</span><span class="token punctuation">(</span>String partA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>partA<span class="token operator">=</span>partA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartB</span><span class="token punctuation">(</span>String partB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>partB<span class="token operator">=</span>partB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartC</span><span class="token punctuation">(</span>String partC<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>partC<span class="token operator">=</span>partC<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//显示产品的特性</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象建造者:包含创建产品各子部件的抽象方法</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建产品对象</span>    <span class="token keyword">protected</span> Product product<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回产品对象</span>    <span class="token keyword">public</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//具体建造者:实现了抽象建造者接口</span><span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">"建造 PartA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">"建造 PartB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">"建造 PartC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指挥者:调用建造者中的方法完成复杂对象的创建</span><span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token operator">=</span>builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//产品构建与组装方法</span>    <span class="token keyword">public</span> Product <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//客户类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Builder builder<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product<span class="token operator">=</span>director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>实例</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 建造者模式(Builder Pattern) * 当构造方法过多或参数过多时使用建造者模式,可以更好的创建对象 * NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) * .calories(100).sodium(35).carbohydrate(27).build(); */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NutritionFacts</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servingSize<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servings<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> calories<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fat<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> sodium<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> carbohydrate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Required parameters</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servingSize<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servings<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional parameters - initialized to default values</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> calories <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> fat <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> sodium <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> carbohydrate <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Builder</span><span class="token punctuation">(</span><span class="token keyword">int</span> servingSize<span class="token punctuation">,</span> <span class="token keyword">int</span> servings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>servingSize <span class="token operator">=</span> servingSize<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>servings <span class="token operator">=</span> servings<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">calories</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            calories <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">fat</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fat <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">sodium</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sodium <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">carbohydrate</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            carbohydrate <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> NutritionFacts <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NutritionFacts</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">NutritionFacts</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        servingSize <span class="token operator">=</span> builder<span class="token punctuation">.</span>servingSize<span class="token punctuation">;</span>        servings <span class="token operator">=</span> builder<span class="token punctuation">.</span>servings<span class="token punctuation">;</span>        calories <span class="token operator">=</span> builder<span class="token punctuation">.</span>calories<span class="token punctuation">;</span>        fat <span class="token operator">=</span> builder<span class="token punctuation">.</span>fat<span class="token punctuation">;</span>        sodium <span class="token operator">=</span> builder<span class="token punctuation">.</span>sodium<span class="token punctuation">;</span>        carbohydrate <span class="token operator">=</span> builder<span class="token punctuation">.</span>carbohydrate<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-抽象工厂模式</title>
      <link href="/2020/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h4><blockquote><p><strong>抽象工厂(Abstract Factory)模式:</strong> 是一种为访问类提供一个创建一组相关或相互依赖对象的接口,且访问类无需指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</p><ul><li>抽象工厂模式是工厂方法模式的升级版本,工厂方法模式只是生产一个等级(种类)的产品,而抽象工厂模式可生产多个等级(种类)的产品</li></ul></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>使用抽象工厂模式一般要满足以下条件<ul><li>系统中有多个产品族,每个具体工厂创建同一族但属于不同等级结构的产品</li><li>系统一次只可能消费其中某一族产品,即同族的产品一起用</li></ul></li><li>除了具有工厂模式的优点外,还有以下优点<ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理,而不必专门引入多个新的类来进行管理</li><li>当增加一个新的产品族时不需要修改源代码,满足开闭原则</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p><strong>模式的结构</strong></p><ul><li><p><strong>抽象工厂（Abstract Factory）：</strong>提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品</p></li><li><p><strong>具体工厂（Concrete Factory）：</strong>主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建</p></li><li><p><strong>抽象产品（Product）：</strong>定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品</p></li><li><p><strong>具体产品（ConcreteProduct）：</strong>实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系</p></li></ul><p><img src="data:image/gif;base64,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" alt="avatar" title="抽象工厂模式结构图"></p></li><li><p><strong>模式的实现</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象工厂:提供了产品的生成方法</span><span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product1 <span class="token function">newProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Product2 <span class="token function">newProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//具体工厂:实现了产品的生成方法</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product1 <span class="token function">newProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂 1 生成-->具体产品 1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Product2 <span class="token function">newProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂 1 生成-->具体产品 2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂方法模式</title>
      <link href="/2020/03/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="工厂方法模式的定义"><a href="#工厂方法模式的定义" class="headerlink" title="工厂方法模式的定义"></a>工厂方法模式的定义</h4><blockquote><p>*<em>工厂方法(Factory Method)模式: *</em> 定义一个创建产品对象的工厂接口,将产品对象的实际创建工作推迟到具体子工厂类当中,这满足了创建型模式中所要求的”创建与使用相分离”的特点</p><ul><li>如果要创建的产品不多,只要一个工厂类就可以完成,这种模式叫”简单工厂模式”,它不属于GoF的23中经典设计模式,它的缺点是增加新产品时会违背”开闭原则”</li></ul></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>优点:</strong></p><ul><li><p>用户只需要知道具体工厂的名称就可以得到所要的产品,无需知道产品的具体创建过程</p></li><li><p>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类,无需对原工厂进行任何修改,满足开闭原则</p></li></ul></li><li><p><strong>缺点:</strong></p><ul><li>每增加一个产品就需要增加一个具体产品类和一个对应的具体工厂类,这增加了系统的复杂度</li></ul></li></ol><h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><ol><li><p><strong>模式的结构</strong></p><ul><li><p><strong>抽象工厂(Abstract Factory):</strong>提供了创建产品的接口,调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品</p></li><li><p><strong>具体工厂(Concrete Factory):</strong>主要是实现抽象工厂中的抽象方法,完成具体产品的创建</p></li><li><p><strong>抽象产品(Product):</strong>定义了产品的规范,描述了产品的主要特性和功能</p></li><li><p><strong>具体产品(Concrete Product):</strong>实现了抽象产品角色所定义的接口,由具体工厂来创建,它同具体工厂之间一一对应</p></li></ul></li></ol><p><img src="data:image/gif;base64,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" alt="avatar" title="工厂模式结构图"></p><ol start="2"><li><strong>模式的实现</strong></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象产品：提供了产品的接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品1：实现抽象产品中的抽象方法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product1</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体产品1展示"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品2：实现抽象产品中的抽象方法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product2</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体产品2展示"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象工厂: 提供了产品生成的接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    Product <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体工厂1：实现了厂品的生成方法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Factory1</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂1生成-->具体产品1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体工厂2：实现了厂品的生成方法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Factory2</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂2生成-->具体产品2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/2020/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="原型模式的定义与特点"><a href="#原型模式的定义与特点" class="headerlink" title="原型模式的定义与特点"></a>原型模式的定义与特点</h4><blockquote><p>*<em>原型(Prototype)模式: *</em> 用一个已经创建的实例作为原型,通过复制该原型对象来创建一个和原型相同或相似的新对象</p><ul><li>通俗的说就是对已存在的对象进行对象复制</li></ul></blockquote><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ol><li><strong>抽象原型类:</strong> 规定了具体原型对象必须实现的接口</li><li><strong>具体原型类:</strong>实现抽象原型类的 clone() 方法,它是可被复制的对象</li><li><strong>访问类:</strong> 使用具体原型类中的 clone() 方法来复制新的对象</li></ol><p><img src="data:image/gif;base64,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" alt="avatar" title="原型模式结构图"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>通过Java提供的对象的clone()方法实现</p></blockquote><ol><li><p>原型模式的克隆分为<strong>浅克隆</strong>和<strong>深克隆</strong></p></li><li><p>*<em>浅克隆: *</em> </p><ul><li><p>使用java提供的clone()方法,原型类实现Cloneable接口重写clone()方法然后调用clone()方法即可复制对象</p></li><li><p>如果原型类存在引用类型(对象)成员属性,浅克隆不会直接复制对象成员属性,需要该对象类也实现Cloneable接口才行</p></li></ul></li><li><p>*<em>深克隆: *</em>序列化实现深克隆,使用对象流把对象写入流中,再从流中读取实现复制对象,原型类需实现Serializable接口,对于不想被序列化的属性需要使用transient修饰</p></li></ol><pre><code>//具体原型类class RealizeType implements Cloneable,Serializable{    //public Student student;//引用类型,如果Student类没有实现Cloneable接口,浅克隆不会复制    public RealizeType() {        System.out.println("原型对象创建成功!");    }    //浅克隆: 实现Cloneable接口,重写clone方法    @Override    public Object clone() throws CloneNotSupportedException {        System.out.println("原型对象浅克隆成功");        return super.clone();    }    //深克隆: 实现Serializable接口,将对象写入流中再取出    public RealizeType deepClone(){        //序列化        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        try (ObjectOutputStream output = new ObjectOutputStream(byteArrayOutputStream)) {            output.writeObject(this);        }catch(IOException e){            e.printStackTrace();        }        //反序列化        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());        RealizeType obj = null;        try (ObjectInputStream input = new ObjectInputStream(byteArrayInputStream)) {            obj = (RealizeType) input.readObject();        }catch (IOException | ClassNotFoundException e){            e.printStackTrace();        }        System.out.println("原型对象深克隆成功");        return obj;    }}</code></pre><pre><code>    @Test //测试    public void prototype() throws CloneNotSupportedException {        //浅拷贝        RealizeType obj = new RealizeType();        RealizeType clone = (RealizeType) obj.clone();        //深拷贝        RealizeType deepClone = obj.deepClone();    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-面向对象设计原则</title>
      <link href="/2020/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2020/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><ol><li><p>开闭原则是总纲,它告诉我们要对扩展开放,对修改关闭</p></li><li><p>里氏替换原则告诉我们不要破坏继承体系</p></li><li><p>依赖倒置原则告诉我们要面向接口编程</p></li><li><p>单一职责原则告诉我们实现类要职责单一</p></li><li><p>接口隔离原则告诉我们在设计接口的时候要精简单一</p></li><li><p>迪米特法则告诉我们要降低耦合度</p></li><li><p>合成复用原则告诉我们要优先使用组合或者聚合关系复用,少用继承关系复用</p></li></ol></blockquote><h4 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则(OCP)"></a>开闭原则(OCP)</h4><blockquote><p>开闭原则(Open Closed Principle): 对扩展开放,对修改关闭</p><p>含义: 当应用的需求改变时,在不修改软件实体的源代码或者二进制代办的前提下,可以扩展模块的共功能,使其满足新的需求</p></blockquote><ol><li><strong>作用</strong><ul><li><strong>对软件测试:</strong> 只需要对扩展的代码进行测试就可以了</li><li><strong>提高代码的可复用性:</strong> 粒度越小,被复用的可能性就越大;根据原子和抽象编程可以提交代码的可复用性</li><li><strong>提高软件可维护性:</strong> 稳定性高和延续性强,易于扩展和维护</li></ul></li><li><strong>实现方法</strong><ul><li>可以通过接口或者抽象类为软件实体定义一个相对稳定的抽象层,而将相同的可变因素封装在相同的具体实现类中</li></ul></li></ol><hr><h4 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h4><blockquote><p>*<em>里氏替换原则(Liskov Substitution Principle): *</em>继承必须确保基类所拥有的性质在子类中仍然成立</p><p>是继承复用的基础,它反映了基类与子类之间的关系,是对开闭原则的补充,对实现抽象化的具体步骤的规范</p></blockquote><ol><li><strong>作用</strong><ul><li>实现开闭原则的重要方式之一</li><li>克服了继承中重写父类造成的可复用性变差的缺点</li><li>动作正确性的保证. 即类的扩展不会给已有的系统引入新的错误,降低了代码出错的可能性</li></ul></li><li><strong>实现方法</strong><ul><li>通俗的说: 子类可以扩展父类的功能,但不能改变父类原有的功能,也就是说<strong>子类继承父类时,除了添加新的方法完成新增功能外,尽量不要重写父类的方法</strong></li><li><strong>重写父类的方法完成新的功能虽然简单,但是整个继承体系的可复用性会比较差,特别是运用多态比较频繁时,程序运行出错的概率会非常大</strong></li></ul></li></ol><hr><h4 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h4><blockquote><p><strong>依赖倒置原则(Dependence Inversion Principle): **高层模块不应该依赖底层模块,两者都应该依赖其抽象;抽象不应该依赖细节,细节应该依赖抽象.核心思想是:</strong>要面向接口编程,不要面向实现编程**</p><p>依赖倒置原则是实现开闭原则的重要途径之一,它降低了客户与实现模块之间的耦合</p></blockquote><ol><li><strong>作用</strong><ul><li>降低类间的耦合性</li><li>提高系统的稳定性</li><li>减少并行开发引起的风险</li><li>提高代码的可读性和可维护性</li></ul></li><li><strong>实现方法</strong><ul><li>每个类尽量提供接口或抽象类</li><li>变量的声明类型尽量是接口或者抽象类</li><li>任何类都不应该从具体类派生</li><li>使用继承时尽量遵循里氏替换原则</li></ul></li></ol><hr><h4 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h4><blockquote><p>*<em>单一职责原则(Single Responsibility Principle): *</em>规定一个类应该有且仅有一个引起它变化的原因,否则类应该被拆分</p><p>对象不能承担太多的职责,否则将消弱这个类实现其他职责的能力,只需要一个职责时,需要全部包含进来,造成冗余</p></blockquote><ol><li><strong>作用</strong><ul><li>降低类的复杂度</li><li>提高类的可读性</li><li>提高系统的可维护性</li><li>变更引起的风险降低</li></ul></li><li><strong>实现方法</strong><ul><li>发现类的不同职责将其分离,在封装到不同的类中</li></ul></li></ol><hr><h4 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h4><blockquote><p><strong>接口隔离原则(Interface Segregation Principle):</strong> 尽量将庞大的接口拆分为更小的和更具体的接口,让接口中只包含客户感兴趣的方法</p><p>客户端不应该被迫依赖于它不使用的方法;一个类对另一个类的依赖应该建立在最小的接口上</p><p><strong>要为各个类建立它们需要的专用接口,而不要试图建立一个庞大的接口提供所有依赖它的类去调用</strong></p><ul><li>单一职责原则侧重职责,而接口隔离原则侧重的是对接口依赖的隔离</li><li>单一职责原则主要是约束类,它针对的是程序中实现的细节;接口隔离原则主要约束接口,主要针对抽象和程序整体框架的构建</li></ul></blockquote><ol><li><strong>作用</strong><ul><li>将庞大的接口分解为多个粒度小的接口,可以预防外来变更的扩散,提高系统灵活性和可维护性</li><li>提高了系统的内聚性,减少了对外交互,降低了系统的耦合性</li><li>接口粒度大小应该定义合理,太少或者太多都不好</li><li>多个专门的接口能体现对象的层次,因为可以通过接口的继承,实现对总接口的定义</li><li>减少项目工程中的代码冗余,过大的接口通常放置许多不用的方法</li></ul></li><li><strong>实现方法</strong><ul><li>接口尽量小,但是要有限度.一个接口只服务与一个子模块或业务逻辑</li><li>为依赖接口的类定制服务.只提供调用者需要的方法,屏蔽不需要的方法</li><li>了解环境,根据实际情况考虑</li><li>提高内聚,减少对外交互,使接口用最少的方法去完成最多的事</li></ul></li></ol><hr><h4 id="迪米特法则-LoD-LKP"><a href="#迪米特法则-LoD-LKP" class="headerlink" title="迪米特法则(LoD  /  LKP)"></a>迪米特法则(LoD  /  LKP)</h4><blockquote><p>*<em>迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle): *</em> 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性</p></blockquote><ol><li><strong>作用</strong><ul><li>降低了类之间的耦合度,提高了模块的相对独立性</li><li>由于亲和度降低,从而提高了类的可复用率和系统扩展性</li><li>但是,过度使用会使系统产生大量的中介类,从而增加系统的复杂性,使模块之间的通信效率降低</li></ul></li><li><strong>实现方法</strong><ul><li>在类的划分上,应该创建弱耦合的类,类与类之间的耦合越弱,就越有利于实现可复用的目标</li><li>在类的结构设计上,尽量降低类成员的访问权限</li><li>在类的设计上,优先考虑将一个类设置成不变类</li><li>在对其他类的引用上,将引用其他对象的次数降到最低</li><li>不暴露类的属性成员,而应该提供相应的访问器(set 和 get 方法)</li><li>谨慎使用序列化(Serializable)功能</li></ul></li></ol><hr><h4 id="合成复用原则-CRP-CARP"><a href="#合成复用原则-CRP-CARP" class="headerlink" title="合成复用原则(CRP  /  CARP)"></a>合成复用原则(CRP  /  CARP)</h4><blockquote><p>*<em>合成复用原则(Composite Reuse Principle)又叫组合/聚合复用原则(Composition/Aggregate Reuse Principle): *</em> 在软件复用时,要尽量先使用嘴和或者聚合等关联关系来实现,其次才考虑使用继承关系来实现</p><p>如果要使用继承关系,则必须严格遵循里氏替换原则.合成复用原则同里氏替换原则相辅相成的,两者都是开闭原则的具体实现规范</p></blockquote><ol><li><strong>作用</strong><ul><li><strong>继承复用缺点</strong><ul><li><em>继承复用破坏了类的封装性</em>.因为继承会将父类的实现细节暴露给子类,父类对子类是透明的,所以这种复用又称为“白箱”复用</li><li><em>子类与父类的耦合度高</em>.父类的实现的任何改变都会导致子类的实现发生变化,这不利于类的扩展与维护</li><li><em>它限制了复用的灵活性</em>.从父类继承而来的实现是静态的,在编译时已经定义,所以在运行时不可能发生变化</li></ul></li><li><strong>合成复用优点</strong><ul><li><em>它维持了类的封装性</em>.因为成分对象的内部细节是新对象看不见的,所以这种复用又称为“黑箱”复用</li><li><em>新旧类之间的耦合度低</em>.这种复用所需的依赖较少,新对象存取成分对象的唯一方法是通过成分对象的接口</li><li><em>复用的灵活性高</em>.这种复用可以在运行时动态进行,新对象可以动态地引用与成分对象类型相同的对象</li></ul></li></ul></li><li><strong>实现方法</strong><ul><li>合成复用原则是通过将已有的对象纳入新对象中,作为新对象的成员对象来实现的,新对象可以调用已有对象的功能,从而达到复用</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-概述</title>
      <link href="/2020/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="23种设计模式概述"><a href="#23种设计模式概述" class="headerlink" title="23种设计模式概述"></a>23种设计模式概述</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><blockquote><p><strong>根据目的来划分</strong></p><ul><li>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种</li></ul></blockquote><blockquote><p><strong>根据作用范围来划分</strong></p><ul><li>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种</li></ul></blockquote><table><thead><tr><th align="left">范围\目的</th><th align="left">创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td align="left">类模式</td><td align="left">工厂方法</td><td>(类）适配器</td><td>模板方法、解释器</td></tr><tr><td align="left">对象模式</td><td align="left">单例 原型 抽象工厂 建造者</td><td>代理 (对象）适配器 桥接 装饰 外观 享元 组合</td><td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td></tr></tbody></table><hr><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><strong>单例（Singleton）模式</strong><ul><li>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式</li></ul></li><li><strong>原型（Prototype）模式</strong><ul><li>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例</li></ul></li><li><strong>工厂方法（Factory Method）模式</strong><ul><li>定义一个用于创建产品的接口，由子类决定生产什么产品</li></ul></li><li><strong>抽象工厂（Abstract Factory）模式</strong><ul><li>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品</li></ul></li><li><strong>建造者（Builder）模式</strong><ul><li>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象</li></ul></li><li><strong>代理（Proxy）模式</strong><ul><li>为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性</li></ul></li><li><strong>适配器（Adapter）模式</strong><ul><li>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</li></ul></li><li><strong>桥接（Bridge）模式</strong><ul><li>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</li></ul></li><li><strong>装饰（Decorator）模式</strong><ul><li>动态的给对象增加一些职责，即增加其额外的功能</li></ul></li><li><strong>外观（Facade）模式</strong><ul><li>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问</li></ul></li><li><strong>享元（Flyweight）模式</strong><ul><li>运用共享技术来有效地支持大量细粒度对象的复用</li></ul></li><li><strong>组合（Composite）模式</strong><ul><li>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性</li></ul></li><li><strong>模板方法（Template Method）模式</strong><ul><li>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤</li></ul></li><li><strong>策略（Strategy）模式</strong><ul><li>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户</li></ul></li><li><strong>命令（Command）模式</strong><ul><li>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开</li></ul></li><li><strong>职责链（Chain of Responsibility）模式</strong><ul><li>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合</li></ul></li><li><strong>状态（State）模式</strong><ul><li>允许一个对象在其内部状态发生改变时改变其行为能力</li></ul></li><li><strong>观察者（Observer）模式</strong><ul><li>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为</li></ul></li><li><strong>中介者（Mediator）模式</strong><ul><li>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解</li></ul></li><li><strong>迭代器（Iterator）模式</strong><ul><li>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</li></ul></li><li><strong>访问者（Visitor）模式</strong><ul><li>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问</li></ul></li><li><strong>备忘录（Memento）模式</strong><ul><li>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它</li></ul></li><li><strong>解释器（Interpreter）模式</strong><ul><li>提供如何定义语言的文法，以及对语言句子的解释方法，即解释器</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Swing</title>
      <link href="/2020/03/19/Java%20Swing/"/>
      <url>/2020/03/19/Java%20Swing/</url>
      
        <content type="html"><![CDATA[<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><ol><li><p><strong>BorderLayout</strong></p><pre><code> public void borderLayout(){     JFrame jFrame = new JFrame("borderLayout"); //窗体     jFrame.setLayout(new BorderLayout(10,5)); //设置布局     Container container = jFrame.getContentPane(); //获取窗体容器(用于添加组件)     //创建按钮     JButton east = new JButton("EAST");     JButton west = new JButton("WEST");     JButton south = new JButton("SOUTH");     JButton north = new JButton("NORTH");     //添加按钮     container.add(east,BorderLayout.EAST);     container.add(west,BorderLayout.WEST);     container.add(south,BorderLayout.SOUTH);     container.add(north,BorderLayout.NORTH);     container.add(new JLabel("CENTER"),BorderLayout.CENTER);     jFrame.setVisible(true);     jFrame.pack(); //窗体自适应大小     //添加事件     jFrame.addWindowListener(new WindowAdapter() {         @Override         public void windowActivated(WindowEvent e) { //窗体打开时触发事件             System.out.println("激活");         }     }); }</code></pre></li><li><p><strong>FlowLayout</strong></p><pre><code> public void flowLayout(){     JFrame jFrame = new JFrame("flowLayout");     Container container = jFrame.getContentPane();     container.setLayout(new FlowLayout(FlowLayout.LEFT,5,10));     container.add(new JButton("button1"));     container.add(new JButton("button2"));     container.add(new JButton("button3"));     container.add(new JButton("button4"));     container.add(new JButton("button5"));     container.add(new JButton("button6"));     jFrame.setVisible(true);     jFrame.setSize(new Dimension(200,200));     jFrame.addWindowListener(new WindowAdapter() {         @Override         public void windowClosing(WindowEvent e) {             System.out.println("exit");         }     }); }</code></pre></li><li><p><strong>GridLayout</strong></p><pre><code> public void gridLayout(){     JFrame jFrame = new JFrame();     Container container = jFrame.getContentPane();     container.setLayout(new GridLayout(5,1,10,5));     container.add(new JButton("first"));     container.add(new JButton("second"));     container.add(new JButton("third"));     container.add(new JButton("fourth"));     container.add(new JButton("fifth"));     jFrame.setVisible(true);     jFrame.pack();     jFrame.addWindowListener(new WindowAdapter() {         @Override         public void windowIconified(WindowEvent e) {             System.out.println("最小化");         }     }); }</code></pre></li><li><p><strong>CardLayout</strong></p><pre><code> public void cardLayout(){     JFrame jFrame = new JFrame("cardLayout");     Container container = jFrame.getContentPane();     container.setLayout(new GridLayout(2,1,0,5));     JPanel top = new JPanel();     JPanel down = new JPanel(new CardLayout());     //创建按钮并添加点击事件     JButton button = new JButton("切换");     button.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             ((CardLayout)down.getLayout()).next(down); //点击时切换下一卡片         }     });     top.setPreferredSize(new Dimension(200,30));//设置大小     top.add(button);     down.setPreferredSize(new Dimension(200,50));     down.add("one",new JButton("page1"));     down.add(new JLabel("page2"));     down.add(new JButton("page3"));     container.add(top);     container.add(down);     jFrame.setVisible(true);     jFrame.pack(); }</code></pre></li><li><p><strong>GridbagLayout</strong></p><pre><code> public void gridbagLayout(){     JButton b;     GridBagConstraints c;     JFrame f = new JFrame("gridbagLayout");     GridBagLayout gridbag = new GridBagLayout();     Container container = f.getContentPane();     container.setLayout(gridbag);     b = new JButton("first");     c = new GridBagConstraints(0,0,1,1,0,0,GridBagConstraints.EAST,1,new Insets(0,0,0,0),2,2);     b.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println("first");         }     });     gridbag.setConstraints(b,c);     container.add(b);     b = new JButton("second");     c = new GridBagConstraints(1,0,3,1,0,0,GridBagConstraints.EAST,1,new Insets(0,0,0,0),2,2);     gridbag.setConstraints(b,c);     container.add(b);     b = new JButton("third");     c = new GridBagConstraints(0,2,1,1,0,0,GridBagConstraints.EAST,1,new Insets(5,0,0,0),2,30);     gridbag.setConstraints(b,c);     container.add(b);     b = new JButton("four");     c = new GridBagConstraints(1,2,1,1,0,0,GridBagConstraints.EAST,0,new Insets(0,0,0,0),2,2);     gridbag.setConstraints(b,c);     container.add(b);     b = new JButton("last button");     c = new GridBagConstraints(2,3,1,1,0,0,GridBagConstraints.EAST,1,new Insets(0,0,0,0),2,2);     gridbag.setConstraints(b,c);     container.add(b);     f.setVisible(true);     f.pack(); }</code></pre></li><li><p><strong>BoxLayout</strong></p><pre><code> public void boxLayout(){     JFrame frame = new JFrame();     Container container = frame.getContentPane();     Box box = Box.createHorizontalBox();     container.add(box);     JButton a = new JButton("A");     a.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println("A");         }     });     box.add(a);     //box.add(Box.createHorizontalGlue()); //加入透明组件     //box.add(Box.createHorizontalStrut(50)); //加入指定宽度的透明组件     //box.add(Box.createRigidArea(new Dimension(50,100)));     //box.add(new Box.Filler(new Dimension(50,50),new Dimension(100,50),new Dimension(200,100)));     box.add(new JButton("B"));     frame.setVisible(true);     frame.setSize(300,100); }</code></pre><pre><code> public void boxLayoutTest(){     JFrame jFrame = new JFrame("box");     Container container = jFrame.getContentPane();     Box boxMain = Box.createHorizontalBox();     Box vbox = Box.createVerticalBox();     JButton b = new JButton("first");     vbox.add(b);     b = new JButton("third");     b.setMaximumSize(new Dimension(100,150));     vbox.add(b);     boxMain.add(vbox);     Box vbox1 = Box.createVerticalBox();     boxMain.add(vbox1);     b = new JButton("second");     b.setAlignmentX(Component.CENTER_ALIGNMENT);     b.setMaximumSize(new Dimension(300,50));     vbox1.add(b);     Box hbox = Box.createHorizontalBox();     vbox1.add(hbox);     Box vbox2 = Box.createVerticalBox();     vbox2.add(Box.createVerticalStrut(50));     vbox2.add(new JButton("fourth"));     vbox2.add(Box.createVerticalStrut(50));     Box vbox3 = Box.createVerticalBox();     vbox3.add(Box.createVerticalGlue());     vbox3.add(new JButton("this is the last button"));     hbox.add(vbox2);     hbox.add(vbox3);     container.add(boxMain);     jFrame.pack();     jFrame.setVisible(true); }</code></pre><pre><code> public void boxLayoutTestOne(){     JFrame jFrame = new JFrame("test");     Container container = jFrame.getContentPane();     Box boxMain = Box.createVerticalBox();     Box topBox = Box.createHorizontalBox();     Box downBox = Box.createHorizontalBox();     topBox.add(new JButton("first"));     JButton second = new JButton("second");     second.setAlignmentX(Component.CENTER_ALIGNMENT);     second.setMaximumSize(new Dimension(300,26));     topBox.add(second);     JButton third = new JButton("third");     third.setMaximumSize(new Dimension(100,150));     Box fourth = Box.createVerticalBox();     Box last = Box.createVerticalBox();     fourth.add(Box.createVerticalStrut(50));     fourth.add(new JButton("fourth"));     fourth.add(Box.createVerticalStrut(50));     last.add(Box.createVerticalGlue());     last.add(new JButton("this is the last button"));     downBox.add(third);     downBox.add(fourth);     downBox.add(last);     boxMain.add(topBox);     boxMain.add(downBox);     jFrame.add(boxMain);     jFrame.setVisible(true);     jFrame.pack(); }</code></pre></li><li><p><strong>不使用布局</strong></p><pre><code> public void noLayout(){     JFrame jFrame = new JFrame("noLayout");     Container container = jFrame.getContentPane();     container.setLayout(null); //不要布局管理器     JButton first = new JButton("first");     JButton second = new JButton("second");     container.add(first);     container.add(second);     first.setBounds(15,10,80,30);     second.setBounds(80,50,90,40);     jFrame.setVisible(true);     jFrame.setSize(400,200); }</code></pre></li></ol><hr><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><ol><li><p><strong>按钮事件</strong></p><pre><code> int count = 0; public void actionListener(){     JFrame jFrame = new JFrame("event");     Container container = jFrame.getContentPane();     container.setLayout(new BorderLayout());     JButton b = new JButton("点击");     b.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             count++;             ((JButton)e.getSource()).setText(count+"");             String str = e.paramString();             System.out.println(str);         }     });     container.add(b,BorderLayout.CENTER);     jFrame.setSize(200,70);     jFrame.setVisible(true); }</code></pre><pre><code> public void manyAction(){     JFrame jFrame = new JFrame("many");     Container container = jFrame.getContentPane();     container.setLayout(new FlowLayout(FlowLayout.RIGHT));     JButton b1 = new JButton("first");     JButton b2 = new JButton("second");     b1.addActionListener(myAction());     b2.addActionListener(myAction());     container.add(b1);     container.add(b2);     jFrame.setVisible(true);     jFrame.pack(); } public ActionListener myAction(){     return new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             String name = e.getActionCommand();             if("first".equals(name)) System.out.println("成功");             else System.out.println("失败");         }     }; }</code></pre></li><li><p><strong>鼠标事件</strong></p><pre><code> public void mouseLintener(){     JFrame jFrame = new JFrame("mouse");     Container container = jFrame.getContentPane();     container.setLayout(new GridLayout(2,1));     JLabel label = new JLabel("初始状态",JLabel.CENTER);     JButton b = new JButton("按钮");     b.setPreferredSize(new Dimension(150,40));     b.addMouseListener(mouseEvent(label));     container.add(label);     container.add(b);     jFrame.setVisible(true);     jFrame.pack(); } public MouseAdapter mouseEvent(JLabel label){     return new MouseAdapter(){         public void mouseClicked(MouseEvent e) {             if(e.getClickCount() == 2){                 JFrame jFrame = new JFrame("连按2次");                 jFrame.setSize(100,100);                 jFrame.setVisible(true);             }         }         public void mousePressed(MouseEvent e) {             label.setText("鼠标按下");         }         public void mouseReleased(MouseEvent e) {             label.setText("鼠标弹起");         }     }; }</code></pre><pre><code> int startX,startY,endX,endY; ArrayDeque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); public void mouseMotionLintener(){     JFrame jFrame = new JFrame("motion"){         @Override         public void paint(Graphics g) {             g.setColor(Color.MAGENTA);             g.clearRect(0,0,300,300);             int i = 0;             int[] arr = new int[4];             for(int a : queue){                 arr[(i++)%4] = a;                 if(i%4 == 0) g.drawLine(arr[0],arr[1],arr[2],arr[3]);             }             g.drawLine(startX,startY,endX,endY);         }     };     Container container = jFrame.getContentPane();     container.addMouseListener(new MouseAdapter() {         @Override         public void mousePressed(MouseEvent e) {             startX = e.getX();             startY = e.getY();         }         @Override         public void mouseReleased(MouseEvent e) {             queue.offer(startX);             queue.offer(startY);             queue.offer(endX);             queue.offer(endY);             //System.out.println("Mousereleased"+startX+","+startY+","+endX+","+endY);         }     });     container.addMouseMotionListener(new MouseMotionAdapter() {         @Override         public void mouseDragged(MouseEvent e) {             endX = e.getX();             endY = e.getY();             jFrame.paint(jFrame.getGraphics());         }     });     jFrame.setSize(300,300);     jFrame.setVisible(true); }</code></pre></li><li><p><strong>键盘事件</strong></p><pre><code> String keyString = ""; public void keyLinstener(){     JFrame jFrame = new JFrame("key");     Container container = jFrame.getContentPane();     container.setLayout(new GridLayout(3,1));     JLabel jLabel = new JLabel("",JLabel.CENTER);     JTextField jTextField = new JTextField();     JButton jButton = new JButton("清除");     //event     jButton.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             jLabel.setText("");             jTextField.setText("");             keyString = "";         }     });     jTextField.addKeyListener(new KeyAdapter() {         @Override         public void keyTyped(KeyEvent e) {             keyString += e.getKeyChar();             jLabel.setText(keyString);         }     });     container.add(jLabel);     container.add(jTextField);     container.add(jButton);     jFrame.setVisible(true);     jFrame.setSize(300,150); }</code></pre></li></ol><hr><h4 id="窗体与面板"><a href="#窗体与面板" class="headerlink" title="窗体与面板"></a>窗体与面板</h4><ol><li><p><strong>JFrame与JInternalFrame</strong></p><pre><code> public void jInternalFrame(){     JFrame jFrame = new JFrame("internal");     Container container = jFrame.getContentPane();     JDesktopPane jDesktopPane = new JDesktopPane();     JButton jButton = new JButton("new");     jButton.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             JInternalFrame jInternalFrame = new JInternalFrame("Internal",true,true,true,true);             jInternalFrame.setSize(200,200);             jInternalFrame.setVisible(true);             jInternalFrame.setLocation(20,20);             Container container = jInternalFrame.getContentPane();             container.setLayout(new BorderLayout());             container.add(new JTextArea(),BorderLayout.CENTER);             container.add(new JButton("internal"),BorderLayout.SOUTH);             jDesktopPane.add(jInternalFrame);         }     });     container.setLayout(new BorderLayout());     container.add(jDesktopPane,BorderLayout.CENTER);     container.add(jButton,BorderLayout.SOUTH);     jFrame.setVisible(true);     jFrame.setSize(350,350); }</code></pre></li><li><p><strong>JLayeredPane(面板的层级)</strong></p><pre><code> public void jLayeredPane(){     Integer[] layeredConstant = {             JLayeredPane.DEFAULT_LAYER,             JLayeredPane.PALETTE_LAYER,             101,             JLayeredPane.MODAL_LAYER,             JLayeredPane.POPUP_LAYER,             JLayeredPane.DRAG_LAYER,             //JLayeredPane.FRAME_CONTENT_LAYER             1001     };     Color[] colors = {             Color.RED,             Color.ORANGE,             Color.YELLOW,             Color.GREEN,             Color.CYAN,             Color.BLUE,             Color.MAGENTA     };     JLabel[] labels = new JLabel[7];     JFrame jFrame = new JFrame("layered");     JLayeredPane jLayeredPane = jFrame.getLayeredPane();     Point point = new Point(0,0);     for(int i = 0 ; i &lt; 7 ; ++i){         labels[i] = createLabel("第"+i+"层",colors[i],point);         point.x += 20;         point.y += 20;         jLayeredPane.add(labels[i],layeredConstant[i]);     }     jFrame.setSize(300,200);     jFrame.setVisible(true); } public JLabel createLabel(String name,Color color,Point position){     JLabel jLabel = new JLabel(name,JLabel.CENTER);     jLabel.setVerticalAlignment(JLabel.TOP);     jLabel.setBackground(color);     //jLabel.setForeground(Color.black);     jLabel.setOpaque(true);     jLabel.setBounds(position.x,position.y,100,100);     return jLabel; }</code></pre></li><li><p><strong>JPanel</strong></p><pre><code> public void jPanel(){     JFrame jFrame = new JFrame("jPanel");     Container container = jFrame.getContentPane();     Box main = Box.createVerticalBox();     Box top = Box.createHorizontalBox();     Box down = Box.createHorizontalBox();     Box last = Box.createVerticalBox();     JLabel label1 = new JLabel("label1",JLabel.CENTER);     JLabel label2 = new JLabel("label2",JLabel.CENTER);     JLabel label3 = new JLabel("label3",JLabel.CENTER);     JLabel label4 = new JLabel("label4",JLabel.CENTER);     JLabel label5 = new JLabel("label5",JLabel.CENTER);     label1.setBorder(BorderFactory.createLineBorder(Color.GRAY));     label2.setBorder(BorderFactory.createLineBorder(Color.GRAY));     label3.setBorder(BorderFactory.createLineBorder(Color.GRAY));     label4.setBorder(BorderFactory.createLineBorder(Color.GRAY));     label5.setBorder(BorderFactory.createLineBorder(Color.GRAY));     JPanel panel1 = new JPanel(new BorderLayout());     JPanel panel2 = new JPanel(new BorderLayout());     JPanel panel3 = new JPanel(new BorderLayout());     JPanel panel4 = new JPanel(new BorderLayout());     JPanel panel5 = new JPanel(new BorderLayout());     panel1.setPreferredSize(new Dimension(300,100));     panel2.setPreferredSize(new Dimension(100,100));     panel3.setPreferredSize(new Dimension(100,100));     panel4.setPreferredSize(new Dimension(100,50));     panel5.setPreferredSize(new Dimension(100,50));     panel1.add(label1,BorderLayout.CENTER);     panel2.add(label2,BorderLayout.CENTER);     panel3.add(label3,BorderLayout.CENTER);     panel4.add(label4,BorderLayout.CENTER);     panel5.add(label5,BorderLayout.CENTER);     last.add(panel4);     last.add(panel5);     top.add(panel1);     down.add(panel2);     down.add(panel3);     down.add(last);     main.add(top);     main.add(down);     container.add(main);     jFrame.setVisible(true);     jFrame.pack(); }</code></pre></li><li><p><strong>JSplitPane(分割面板)</strong></p><pre><code> public void jSplitPane(){     JFrame jFrame = new JFrame("split");     Container container = jFrame.getContentPane();     JLabel label1 = new JLabel("label1",JLabel.CENTER);     JLabel label2 = new JLabel("label2",JLabel.CENTER);     JLabel label3 = new JLabel("label3",JLabel.CENTER);     JSplitPane jSplitPane1 = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true,label1,label2);     jSplitPane1.setDividerLocation(0.3);     jSplitPane1.setOneTouchExpandable(true);     jSplitPane1.setDividerSize(10);     JSplitPane jSplitPane2 = new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,jSplitPane1,label3);     jSplitPane2.setDividerLocation(35);     jSplitPane2.setOneTouchExpandable(true);     jSplitPane2.setDividerSize(10);     container.add(jSplitPane2);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li><li><p><strong>JTabbedPanne(标签面板)</strong></p><pre><code> public void jtabbedPane(){     JFrame jFrame = new JFrame("tab");     Container container = jFrame.getContentPane();     JPanel panel1 = new JPanel();     panel1.add(new JLabel("label1"));     JPanel panel2 = new JPanel();     panel2.add(new JLabel(new ImageIcon(FrameTest.class.getResource("./bpm.png"))));//图片作为背景     JPanel panel3 = new JPanel();     panel3.add(new JLabel("label3"));     JTabbedPane jTabbedPane = new JTabbedPane(JTabbedPane.TOP);     JScrollPane jScrollPane = new JScrollPane(panel2,JScrollPane.VERTICAL_SCROLLBAR_NEVER,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);     jTabbedPane.add("first",panel1);     jTabbedPane.add("image",jScrollPane);     jTabbedPane.add("third",panel3);     container.add(jTabbedPane);     jFrame.setVisible(true);     jFrame.setSize(300,300); }</code></pre></li><li><p><strong>JScrollPane(滚动面板)</strong></p><pre><code> public void jScrollPane(){     JFrame jFrame = new JFrame("scroll");     Container container = jFrame.getContentPane();     container.setLayout(new BorderLayout());     JPanel center = new JPanel();     center.add(new JLabel(new ImageIcon(FrameTest.class.getResource("./bpm.png"))));     JScrollPane jScrollPane = new JScrollPane(center,JScrollPane.VERTICAL_SCROLLBAR_NEVER,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);     JPanel west = new JPanel();     west.setPreferredSize(new Dimension(100,100));     west.setLayout(new GridLayout(5,1));     JButton b1 = new JButton("显示水平滚动条");     JButton b2 = new JButton("不显示水平滚动条");     JButton b3 = new JButton("适时显示水平滚动条");     b1.addActionListener(addBtnAction(jScrollPane));     b2.addActionListener(addBtnAction(jScrollPane));     b3.addActionListener(addBtnAction(jScrollPane));     west.add(b1);     west.add(b2);     west.add(b3);     container.add(west,BorderLayout.WEST);     container.add(jScrollPane,BorderLayout.CENTER);     jFrame.setVisible(true);     jFrame.setSize(300,200); } public ActionListener addBtnAction(JScrollPane jScrollPane){     return new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             String name = e.getActionCommand();             if("显示水平滚动条".equals(name)){                 jScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);             }             else if("不显示水平滚动条".equals(name)){                 jScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);             }             else{                 jScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);             }             jScrollPane.revalidate();         }     }; }</code></pre></li><li><p><strong>JScrollBar(滚动条)</strong></p><pre><code> public void jScrollBar(){     JFrame jFrame = new JFrame("bar");     Container container = jFrame.getContentPane();     JLabel top = new JLabel("刻度:",JLabel.CENTER);     JPanel center = new JPanel();     center.add(new JLabel(new ImageIcon(FrameTest.class.getResource("./bpm.png"))));     JScrollBar down = new JScrollBar(JScrollBar.HORIZONTAL,0,10,0,300);     JScrollBar right = new JScrollBar(JScrollBar.VERTICAL,0,10,0,200);     down.setUnitIncrement(5);     down.setBlockIncrement(10);     right.setUnitIncrement(2);     right.setBlockIncrement(5);     down.addAdjustmentListener(addBarAction(top,right,down));     right.addAdjustmentListener(addBarAction(top,right,down));     container.add(down,BorderLayout.SOUTH);     container.add(right,BorderLayout.EAST);     container.add(top,BorderLayout.NORTH);     container.add(center,BorderLayout.CENTER);     jFrame.setVisible(true);     jFrame.setSize(300,200); } public AdjustmentListener addBarAction(JLabel label,JScrollBar vbar,JScrollBar hbar){     return new AdjustmentListener() {         @Override         public void adjustmentValueChanged(AdjustmentEvent e) {             if((JScrollBar)e.getSource() == vbar){                 label.setText("垂直刻度: " + e.getValue());             }             else if((JScrollBar)e.getSource() == hbar){                 label.setText("水平刻度: " + e.getValue());             }         }     }; }</code></pre></li></ol><hr><h4 id="标签与按钮"><a href="#标签与按钮" class="headerlink" title="标签与按钮"></a>标签与按钮</h4><ol><li><p><strong>Border</strong></p><pre><code> public void border(){     Color[] colors = {             Color.RED,Color.ORANGE,Color.YELLOW,Color.GREEN,Color.CYAN,Color.BLUE,Color.MAGENTA     };     JFrame jFrame = new JFrame("border");     Container container = jFrame.getContentPane();     JButton btn = new JButton("toggle");     btn.setPreferredSize(new Dimension(100,30));     btn.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             int i = new Random().nextInt(7);             btn.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(colors[i],3),"toggle", TitledBorder.CENTER,TitledBorder.CENTER,null,colors[i%6+1]));         }     });     container.add(btn);     jFrame.setVisible(true);     jFrame.setSize(300,100); }</code></pre></li><li><p><strong>Icon</strong></p><pre><code> public void imageIcon(){     JFrame jFrame = new JFrame("icon");     Container container = jFrame.getContentPane();     JLabel label = new JLabel();     label.setIcon(new ImageIcon(FrameTest.class.getResource("./bpm.png")));     label.setPreferredSize(new Dimension(100,50));     label.setBorder(BorderFactory.createLineBorder(Color.MAGENTA,3));     //label.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.MAGENTA,3),"label"));     Box box = Box.createHorizontalBox();     box.add(Box.createHorizontalGlue());     box.add(label);     box.add(Box.createHorizontalGlue());     container.setLayout(new GridLayout(3,1));     container.add(new JLabel());     container.add(box);     jFrame.setSize(300,200);     jFrame.setVisible(true); }</code></pre><pre><code> public void imageIconByte(){     JFrame jFrame = new JFrame("byte");     Container container = jFrame.getContentPane();     URL url = FrameTest.class.getResource("./bpm.png");     System.out.println(url.getPath());     File file = new File(url.getPath());     InputStream input = null;     int length = (int)file.length();     byte[] buff = new byte[length];     try {         input = new FileInputStream(file);         input.read(buff);     } catch (Exception e) {         e.printStackTrace();     } finally {         try {             input.close();         } catch (Exception e) {             e.printStackTrace();         }     }     //for(byte a : buff) System.out.print((char)a);     ImageIcon icon = new ImageIcon(buff);     JButton b = new JButton(icon);     container.add(b);     jFrame.setVisible(true);     jFrame.setSize(200,100); }</code></pre><pre><code> //创建纯色图片 public Image getPureImage(Color color,int w,int h){     BufferedImage image = new BufferedImage(w,h,BufferedImage.TYPE_INT_BGR);     Graphics g = image.getGraphics();     g.setColor(color);     g.fillRect(0,0,w,h);     return image; } //创建文字图片 public ImageIcon getImageIcon2D(Image image,String title,Font font,Color fontColor){     Graphics2D g2d = (Graphics2D) image.getGraphics();     ImageIcon icon = new ImageIcon(image);     if(title != null &amp;&amp; title.length() &gt; 0) {         if(font == null) font = new Font("宋体",Font.LAYOUT_LEFT_TO_RIGHT,20);         if(fontColor == null) fontColor = Color.BLACK;         double width = font.getStringBounds(title, g2d.getFontRenderContext()).getWidth();         double height = width/title.length();         g2d.setFont(font);         g2d.setColor(fontColor);         long x = Math.round((icon.getIconWidth() - width)/2);         long y = Math.round((icon.getIconHeight() + height)/2);         g2d.drawString(title,x,y);     }     return icon; }</code></pre></li><li><p><strong>JLabel</strong></p><pre><code> public void jLabel(){     JFrame jFrame = new JFrame("label");     Container container = jFrame.getContentPane();     JLabel jLabel = new JLabel();     jLabel.setText("label");     jLabel.setHorizontalAlignment(JLabel.CENTER);     jLabel.setVerticalAlignment(JLabel.BOTTOM);     container.add(jLabel);     jFrame.setSize(300,200);     jFrame.setVisible(true); }</code></pre></li><li><p><strong>JButton</strong></p><pre><code> public void jButton(){     JFrame jFrame = new JFrame("button");     Container container = jFrame.getContentPane();     container.setLayout(new FlowLayout());     JButton b = new JButton("确定",new ImageIcon(getPureImage(Color.MAGENTA,80,40)));     b.setRolloverEnabled(true);     b.setRolloverIcon(new ImageIcon(getPureImage(Color.RED,80,40)));     b.setPressedIcon(new ImageIcon(getPureImage(Color.BLUE,80,40)));     b.setHorizontalTextPosition(JButton.CENTER);     b.setPreferredSize(new Dimension(80,40));     container.add(b);     jFrame.setVisible(true);     jFrame.setSize(300,100); }</code></pre><pre><code> //设置按钮快捷键 public void DefaultShortcut(){     JFrame jFrame = new JFrame("default enter");     Container container = jFrame.getContentPane();     container.setLayout(new GridLayout(1,2));     JButton btn1 = new JButton("first");     JButton btn2 = new JButton("second");     ActionListener action = new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println(e.getActionCommand());             if(e.getSource() == btn1){                 JFrame jFrame1 = new JFrame("first");                 jFrame1.setBounds(100,100,300,200);                 jFrame1.setVisible(true);             }             else if(e.getSource() == btn2){                 JFrame jFrame1 = new JFrame("second");                 jFrame1.setBounds(150,150,300,200);                 jFrame1.setVisible(true);             }         }     };     btn1.addActionListener(action);     btn2.addActionListener(action);     btn2.setMnemonic('S');     container.add(btn1);     container.add(btn2);     jFrame.getRootPane().setDefaultButton(btn1);     jFrame.setVisible(true);     jFrame.setSize(300,200); } //设置按钮快捷键 public void jButtonShortcut(){     JFrame jframe = new JFrame("shortcut");     Container container = jframe.getContentPane();     JButton btn = new JButton("Open new window");     btn.setMnemonic('O');     btn.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println("Open new window");             JFrame jFrame = new JFrame("new window");             jFrame.setVisible(true);             jFrame.setBounds(100,100,300,200);         }     });     container.add(btn);     jframe.setSize(300,200);     jframe.setVisible(true); }</code></pre></li><li><p><strong>JToggleButton</strong></p><pre><code> public void toggleButton(){     JFrame jFrame = new JFrame("toggle");     Container container = jFrame.getContentPane();     container.setLayout(new GridLayout(1,3));     JToggleButton tbtn1 = new JToggleButton("first");     JToggleButton tbtn2 = new JToggleButton("second");     JToggleButton tbtn3 = new JToggleButton("third");     container.add(tbtn1);     container.add(tbtn2);     container.add(tbtn3);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li></ol><hr><h4 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h4><ol><li><p><strong>JCheckBox</strong></p><pre><code> public void jCheckBox(){     JFrame jFrame  = new JFrame("checkBox");     Container container = jFrame.getContentPane();     container.setLayout(new GridLayout(3,1));     JCheckBox checkBox1 = new JCheckBox("first");     JCheckBox checkBox2 = new JCheckBox("second");     JCheckBox checkBox3 = new JCheckBox("third");     ItemListener itemListener = new ItemListener() {         @Override         public void itemStateChanged(ItemEvent e) {             if(e.getStateChange() == e.SELECTED){                 System.out.println(((JCheckBox)e.getItem()).getText());             }         }     };     checkBox1.addItemListener(itemListener);     checkBox2.addItemListener(itemListener);     checkBox3.addItemListener(itemListener);     container.add(checkBox1);     container.add(checkBox2);     container.add(checkBox3);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li><li><p><strong>JRadioButton</strong></p><pre><code> public void jRadioButton(){     JFrame jFrame = new JFrame("radio");     Container container = jFrame.getContentPane();     JRadioButton btn1 = new JRadioButton("male");     JRadioButton btn2 = new JRadioButton("female");     JPanel jPanel = new JPanel(new GridLayout(3,1));     jPanel.add(btn1);     jPanel.add(btn2);     ButtonGroup group = new ButtonGroup();     group.add(btn1);     group.add(btn2);     container.add(jPanel);     jFrame.setSize(300,200);     jFrame.setVisible(true); }</code></pre></li><li><p><strong>JList</strong></p><pre><code> public void jList(){     JFrame jFrame = new JFrame();     Container container = jFrame.getContentPane();     Vector&lt;String&gt; vector = new Vector&lt;&gt;();     Vector&lt;String&gt; vector2 = new Vector&lt;&gt;();     String sql = "SELECT * FROM NBL_TEST_ONE";     String sql_son = "SELECT * FROM NBL_TEST_ONE_SON";     Connection conn = JdbcUtils.getConnection();     try {         PreparedStatement statement = conn.prepareStatement(sql);         ResultSet res = statement.executeQuery();         while(res.next())             vector.add(res.getString("NAME"));         ResultSet ress = conn.prepareStatement(sql_son).executeQuery();         while(ress.next())             vector2.add(ress.getString("SNAME"));     } catch (SQLException e) {         e.printStackTrace();     }     JList&lt;String&gt; list = new JList&lt;&gt;(vector);     JList&lt;String&gt; list2 = new JList&lt;&gt;(vector2);     list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);     list.addListSelectionListener(new ListSelectionListener() {         @Override         public void valueChanged(ListSelectionEvent e) {             String name = list.getSelectedValue();             list2.setSelectedValue(name,false);         }     });     JPanel jPanel = new JPanel(new BorderLayout());     JPanel jPanel2 = new JPanel(new BorderLayout());     jPanel.setPreferredSize(new Dimension(150,200));     jPanel.add(list);     jPanel2.setPreferredSize(new Dimension(150,200));     jPanel2.add(list2);     JSplitPane jSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,jPanel,jPanel2);     jSplitPane.setDividerLocation(0.5);     container.add(jSplitPane);     jFrame.setVisible(true);     jFrame.pack(); }</code></pre><pre><code> public void jListModel(){     JFrame jFrame = new JFrame("listModel");     Container container = jFrame.getContentPane();     JPanel panel1 = new JPanel(new BorderLayout());     JPanel panel2 = new JPanel(new BorderLayout());     Vector&lt;String&gt; vector = new Vector&lt;&gt;();     vector.add("A");     vector.add("B");     vector.add("C");     vector.add("D");     vector.add("E");     vector.add("F");     ListModel&lt;String&gt; model = new AbstractListModel&lt;String&gt;() {         @Override         public int getSize() {             return vector.size();         }         @Override         public String getElementAt(int index) {             return vector.get(index);         }     };     ListModel&lt;String&gt; model1 = new DefaultListModel&lt;String&gt;(){         {             addElement("O");             addElement("P");             addElement("E");             addElement("N");             addElement("C");             addElement("A");         }     };     JList&lt;String&gt; list1 = new JList&lt;&gt;(model);     JList&lt;String&gt; list2 = new JList&lt;&gt;(model1);     list1.addListSelectionListener(new ListSelectionListener() {         @Override         public void valueChanged(ListSelectionEvent e) {         }     });     panel1.add(list1);     panel2.add(list2);     panel1.setPreferredSize(new Dimension(150,200));     panel2.setPreferredSize(new Dimension(150,200));     JSplitPane jSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,panel1,panel2);     jSplitPane.setDividerLocation(0.5);     container.add(jSplitPane);     jFrame.setVisible(true);     jFrame.pack(); }</code></pre><pre><code> public void jListClick(){     JFrame jFrame = new JFrame("click");     Container container = jFrame.getContentPane();     DefaultListModel&lt;String&gt; model = new DefaultListModel&lt;String&gt;(){         {             addElement("A");             addElement("B");             addElement("C");             addElement("D");             addElement("E");         }     };     DefaultListModel&lt;String&gt; model1 = new DefaultListModel&lt;&gt;();     JList&lt;String&gt; jList = new JList&lt;&gt;(model);     JList&lt;String&gt; jList1 = new JList&lt;&gt;(model1);     jList.setPreferredSize(new Dimension(150,200));     jList1.setPreferredSize(new Dimension(150,200));     MouseAdapter mouseAdapter = new MouseAdapter() {         @Override         public void mouseClicked(MouseEvent e) {             if(e.getClickCount() == 2){ //双击                 if(e.getSource() == jList) {                     int index = jList.locationToIndex(e.getPoint());                     model1.addElement(model.getElementAt(index));                     model.removeElementAt(index);                 }                 else if(e.getSource() == jList1){                     int index = jList1.locationToIndex(e.getPoint());                     model.addElement(model1.getElementAt(index));                     model1.removeElementAt(index);                 }             }         }     };     jList.addMouseListener(mouseAdapter);     jList1.addMouseListener(mouseAdapter);     JSplitPane jSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,jList,jList1);     jSplitPane.setDividerLocation(0.5);     container.add(jSplitPane);     jFrame.setVisible(true);     jFrame.pack(); }</code></pre></li><li><p><strong>JComboBox</strong></p><pre><code> public void jComboBox(){     JFrame jFrame = new JFrame("comboBox");     Container container = jFrame.getContentPane();     Vector&lt;String&gt; vector1 = new Vector&lt;&gt;();     Vector&lt;String&gt; vector2 = new Vector&lt;&gt;();     vector1.add("A");     vector1.add("B");     vector1.add("C");     vector2.add("D");     vector2.add("E");     vector2.add("F");     JComboBox&lt;String&gt; comboBox1 = new JComboBox&lt;&gt;(vector1);     JComboBox&lt;String&gt; comboBox2 = new JComboBox&lt;&gt;(vector2);     JPanel jPanel = new JPanel();     ((FlowLayout)jPanel.getLayout()).setAlignment(FlowLayout.LEFT);     //jPanel.setLayout(new FlowLayout(FlowLayout.LEFT));     jPanel.add(comboBox1);     jPanel.add(comboBox2);     container.add(jPanel);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre><pre><code> public void jComboBoxModel(){     JFrame jFrame = new JFrame("model");     Container container = jFrame.getContentPane();     class CustomComboBoxModel extends AbstractListModel&lt;String&gt; implements ComboBoxModel&lt;String&gt;{         String[] arr = {"A","B","C","D"};         String item = null;         @Override         public int getSize() {             return arr.length;         }         @Override         public String getElementAt(int index) {             return arr[index];         }         @Override         public void setSelectedItem(Object anItem) {             item = anItem.toString();         }         @Override         public Object getSelectedItem() {             return item;         }     }     ComboBoxModel&lt;String&gt; model = new CustomComboBoxModel();     JComboBox&lt;String&gt; comboBox1 = new JComboBox&lt;&gt;(model);     JComboBox&lt;String&gt; comboBox2 = new JComboBox&lt;&gt;(model);     //设置可编辑     comboBox1.setEditable(true);     ComboBoxEditor editer = comboBox1.getEditor();     comboBox1.configureEditor(editer,"ABC");     //事件     comboBox1.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println(comboBox1.getSelectedItem());         }     });     comboBox1.addItemListener(new ItemListener() {         @Override         public void itemStateChanged(ItemEvent e) {             System.out.println(e.getItem().toString());         }     });     Box box = Box.createHorizontalBox();     box.add(comboBox1);     box.add(comboBox2);     container.add(box);     container.setLayout(new FlowLayout(FlowLayout.LEFT));     jFrame.setSize(300,200);     jFrame.setVisible(true); }</code></pre></li></ol><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ol><li><p><strong>JTable</strong></p><pre><code> public void jTable(){     JFrame jFrame = new JFrame("table");     Container container = jFrame.getContentPane();     Vector&lt;Vector&gt;&lt;String&gt;&gt; vectors = new Vector&lt;&gt;();     Vector&lt;String&gt; names = new Vector&lt;&gt;();     String sql = "SELECT * FROM NBL_TEST_ONE";     //String sql = "select * from NBL_IMPBPCMASTER_DTL";     Connection conn = JdbcUtils.getConnection();     try {         PreparedStatement pre =conn.prepareStatement(sql);         ResultSet rs = pre.executeQuery();         ResultSetMetaData rsd = rs.getMetaData();         for(int i = 1 ; i &lt;= rsd.getColumnCount(); ++i)             names.add(rsd.getColumnName(i));         while(rs.next()){             Vector&lt;String&gt; vector = new Vector&lt;&gt;();             for(String n : names)                 vector.add(rs.getString(n));             vectors.add(vector);         }     } catch (SQLException e) {         e.printStackTrace();     }     JTable table = new JTable(vectors,names);     //table.setPreferredScrollableViewportSize(new Dimension(500,30));     table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);     TableColumnModel model = table.getColumnModel();     for(int i = 0 ; i&lt; model.getColumnCount() ; ++i){         TableColumn column = model.getColumn(i);         if((column.getModelIndex() &amp; 1) == 0)             column.setPreferredWidth(100);         else             column.setPreferredWidth(50);     }     table.getTableHeader().setForeground(Color.gray);     JScrollPane jScrollPane = new JScrollPane(table);     container.add(jScrollPane);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li><li><p><strong>TableModel</strong></p><pre><code> public void jTableModel(){     JFrame jFrame = new JFrame("tableModel");     Container container = jFrame.getContentPane();     TableModel model = new AbstractTableModel() {         Object[][] p = {                 {new Integer(1),"Tom","110",new Boolean(true)},                 {new Integer(2),"Jerry","120",new Boolean(false)},                 {new Integer(3),"Sinba","130",new Boolean(true)}         };         String[] names = {"编号","名字","电话","选择"};         Class[] classs = {Integer.class,String.class,String.class,Boolean.class};         @Override         public boolean isCellEditable(int rowIndex, int columnIndex) {             return true;         }         @Override         public void setValueAt(Object aValue, int rowIndex, int columnIndex) {             p[rowIndex][columnIndex] = aValue;             fireTableCellUpdated(rowIndex,columnIndex);         }         @Override         public Class&lt;?&gt; getColumnClass(int columnIndex) {             return classs[columnIndex];         }         @Override         public int getRowCount() {             //return vectors.size();             return p.length;         }         @Override         public int getColumnCount() {             //return names.size();             return names.length;         }         @Override         public String getColumnName(int column) {             //return names.get(column);             return names[column];         }         @Override         public Object getValueAt(int rowIndex, int columnIndex) {             //return vectors.get(rowIndex).get(columnIndex);             return p[rowIndex][columnIndex];         }     };     JTable jTable = new JTable(model);     //jTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);     //TableColumnModel columnModel = jTable.getColumnModel();     //columnModel.getColumn(1).setCellEditor(new DefaultCellEditor(new JComboBox(new String[]{"A","B"})));     JScrollPane jScrollPane = new JScrollPane(jTable);     container.add(jScrollPane);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li></ol><hr><h4 id="文字输入组件"><a href="#文字输入组件" class="headerlink" title="文字输入组件"></a>文字输入组件</h4><ol><li><p><strong>JTextField</strong></p><pre><code> public void jTextField(){     JFrame jFrame = new JFrame("textField");     Container container = jFrame.getContentPane();     JLabel l1 = new JLabel("name:");     JLabel l2 = new JLabel("gender:");     JLabel l3 = new JLabel("phone:");     JLabel l4 = new JLabel("email:");     JTextField t1 = new JTextField("Tom");     JTextField t2 = new JTextField("male");     JTextField t3 = new JTextField("110222020202");     JTextField t4 = new JTextField("1233233");     JPanel jPanel = new JPanel(new GridBagLayout());     GridBagConstraints gbc = new GridBagConstraints();//new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0);     gbc.anchor = GridBagConstraints.WEST;     gbc.insets = new Insets(5,5,5,5);     jPanel.add(l1,gbc);     gbc.gridx = 1;     jPanel.add(t1,gbc);     gbc.gridx = 0;     gbc.gridy = 1;     jPanel.add(l2,gbc);     gbc.gridx = 1;     jPanel.add(t2,gbc);     gbc.gridx = 0;     gbc.gridy = 2;     jPanel.add(l3,gbc);     gbc.gridx = 1;     jPanel.add(t3,gbc);     gbc.gridx = 0;     gbc.gridy = 3;     jPanel.add(l4,gbc);     gbc.gridx = 1;     jPanel.add(t4,gbc);     container.setLayout(new BorderLayout());     container.add(jPanel);     jFrame.setVisible(true);     jFrame.pack(); }</code></pre><pre><code> public void jTextFieldDocument(){     JFrame jFrame = new JFrame("document");     Container container = jFrame.getContentPane();     JLabel label = new JLabel("title");     Document doc = new PlainDocument(){         @Override         public void insertString(int offs, String str, AttributeSet a) throws BadLocationException {             if(getLength() + str.length() &lt; 5)                 super.insertString(offs, str, a);             else                 System.out.println("MAX");         }     };     JTextField textField = new JTextField(doc,"",5);     textField.addActionListener(new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println(e.getActionCommand()             );         }     });     JPanel panel = new JPanel(new GridLayout(1,2));     panel.add(label);     panel.add(textField);     container.setLayout(new FlowLayout());     container.add(panel);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li><li><p><strong>JTextArea</strong></p><pre><code> public void jTextArea(){     JFrame jFrame = new JFrame("textArea");     Container container = jFrame.getContentPane();     JTextArea textArea = new JTextArea(3,10);     textArea.setFont(new Font("宋体",Font.BOLD,16));     JPanel panel = new JPanel(new GridLayout(1,3));     JButton btn1 = new JButton("复制");     JButton btn2 = new JButton("粘贴");     JButton btn3 = new JButton("剪切");     ActionListener listener = new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             if(e.getSource() == btn1) {                 textArea.select(0,textArea.getText().length());                 textArea.copy();             }             else if(e.getSource() == btn2) textArea.paste();             else if(e.getSource() == btn3) textArea.cut();             else ;         }     };     btn1.addActionListener(listener);     btn2.addActionListener(listener);     btn3.addActionListener(listener);     panel.add(btn1);     panel.add(btn2);     panel.add(btn3);     container.add(new JScrollPane(textArea),BorderLayout.CENTER);     container.add(panel,BorderLayout.SOUTH);     jFrame.setSize(300,200);     jFrame.setVisible(true); }</code></pre><pre><code> UndoableEdit edit = null; public void jTextAreaUndo(){     JFrame jFrame = new JFrame("Undo,Redo");     Container container = jFrame.getContentPane();     JTextArea textArea = new JTextArea();     JMenuBar bar = new JMenuBar();     JMenu menu = new JMenu("Edit");     JMenuItem item1 = new JMenuItem("Undo");     JMenuItem item2 = new JMenuItem("Redo");     item1.setEnabled(false);     item2.setEnabled(false);     menu.add(item1);     menu.add(item2);     bar.add(menu);     UndoableEditListener undoableEditListener = new UndoableEditListener() {         @Override         public void undoableEditHappened(UndoableEditEvent e) {             edit = e.getEdit();             updateItem(item1,item2);         }     };     ActionListener actionListener = new ActionListener() {         @Override         public void actionPerformed(ActionEvent e) {             if(e.getSource() == item1) edit.undo();             else if(e.getSource() == item2) edit.redo();             updateItem(item1,item2);         }     };     textArea.getDocument().addUndoableEditListener(undoableEditListener);     textArea.getDocument().addDocumentListener(new DocumentListener() {         @Override         public void insertUpdate(DocumentEvent e) {             DocumentEvent.ElementChange change = e.getChange(textArea.getDocument().getDefaultRootElement());             if(change != null)                 System.out.println("第"+(change.getIndex()+1)+"行");         }         @Override         public void removeUpdate(DocumentEvent e) {         }         @Override         public void changedUpdate(DocumentEvent e) {         }     });     item1.addActionListener(actionListener);     item2.addActionListener(actionListener);     container.add(textArea);     jFrame.setJMenuBar(bar);     jFrame.setVisible(true);     jFrame.setSize(300,200); } public void updateItem(JMenuItem item1, JMenuItem item2){     item1.setEnabled(edit.canUndo());     item2.setEnabled(edit.canRedo());     item1.setText(edit.getUndoPresentationName());     item2.setText(edit.getRedoPresentationName()); }</code></pre></li><li><p><strong>JEditorPane</strong></p><pre><code> public void jEditorPane(){     JFrame jFrame = new JFrame("EditorPane");     Container container = jFrame.getContentPane();     URL url = null;     JEditorPane editorPane = null;     try {         url = new URL("https://www.baidu.com");         editorPane = new JEditorPane(url);     } catch(Exception e){         e.printStackTrace();     }     final JEditorPane editorPage = editorPane;     editorPane.setEditable(false);     editorPane.addHyperlinkListener((HyperlinkEvent e) -&gt;{         if(e.getEventType() == HyperlinkEvent.EventType.ACTIVATED){             try {                 editorPage.setPage(e.getURL());             } catch (IOException e1) {                 e1.printStackTrace();             }         }     });     JScrollPane scrollPane = new JScrollPane(editorPane);     container.add(scrollPane);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li><li><p><strong>JTextPane(富文本框)</strong></p><pre><code> public void JTextPane(){     JFrame frame = new JFrame("TextPane");     Container container = frame.getContentPane();     JTextPane textPane = new JTextPane();     Document doc = textPane.getDocument();     //属性设置     SimpleAttributeSet attributeSet = new SimpleAttributeSet();     StyleConstants.setForeground(attributeSet,Color.RED);//添加属性前景色     StyleConstants.setBold(attributeSet,true);//加粗     StyleConstants.setFontSize(attributeSet,20);//字体大小     try {         textPane.setEditable(false);//不可编辑         doc.insertString(doc.getLength(),"红色加粗20",attributeSet);         StyleConstants.setForeground(attributeSet,Color.BLUE);//添加属性前景色         StyleConstants.setBold(attributeSet,false);//加粗         StyleConstants.setFontSize(attributeSet,15);//字体大小         StyleConstants.setUnderline(attributeSet,true);//下划线         StyleConstants.setItalic(attributeSet,true); //斜体         doc.insertString(doc.getLength(),"蓝色不加粗下划线斜体15",attributeSet);     } catch (BadLocationException e) {         e.printStackTrace();     }     container.add(textPane);     frame.setVisible(true);     frame.setSize(300,200); }</code></pre></li></ol><hr><h4 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h4><ol><li><p><strong>JTree</strong></p><pre><code> public void jTree(){     JFrame jFrame = new JFrame("Tree");     Container container = jFrame.getContentPane();     JTree jTree = new JTree();     container.add(jTree);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li><li><p><strong>Hashtable构造JTree</strong></p><pre><code> public void jTreeHashTable(){     JFrame jFrame = new JFrame("hashtable");     Container container = jFrame.getContentPane();     Hashtable&lt;String,Object&gt; table = new Hashtable&lt;&gt;();     Hashtable&lt;String,String[]&gt; table2 = new Hashtable&lt;&gt;();     table2.put("UK",new String[]{"U","K"});     table2.put("France",new String[]{"F","R","A","N","C","E"});     table.put("China",new String[]{"C","H","I","N","A"});     table.put("Europe",table2);     table.put("USA",new String[]{"U","S","A"});     JTree jTree = new JTree(table);     container.add(jTree);     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li><li><p><strong>TreeNode构造JTree</strong></p><pre><code> public void jTreeNode(){     JFrame jFrame = new JFrame("TreeNode");     Container container = jFrame.getContentPane();     DefaultMutableTreeNode root = (DefaultMutableTreeNode) getRoot();     JTree jTree = new JTree(root);     JScrollPane jScrollPane = new JScrollPane(jTree,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);     container.add(jScrollPane);     jFrame.setSize(300,200);     jFrame.setVisible(true); } public TreeNode getRoot(){     DefaultMutableTreeNode root = new DefaultMutableTreeNode("root");     DefaultMutableTreeNode a = new DefaultMutableTreeNode("CHINA");     DefaultMutableTreeNode b = new DefaultMutableTreeNode("EUROPE");     DefaultMutableTreeNode c = new DefaultMutableTreeNode("USA");     root.add(a);     root.add(b);     root.add(c);     a.add(new DefaultMutableTreeNode("C"));     a.add(new DefaultMutableTreeNode("H"));     a.add(new DefaultMutableTreeNode("I"));     a.add(new DefaultMutableTreeNode("N"));     a.add(new DefaultMutableTreeNode("A"));     c.add(new DefaultMutableTreeNode("U"));     c.add(new DefaultMutableTreeNode("S"));     c.add(new DefaultMutableTreeNode("A"));     DefaultMutableTreeNode ba = new DefaultMutableTreeNode("FRANCE");     DefaultMutableTreeNode bb = new DefaultMutableTreeNode("UK");     ba.add(new DefaultMutableTreeNode("F"));     ba.add(new DefaultMutableTreeNode("R"));     ba.add(new DefaultMutableTreeNode("A"));     ba.add(new DefaultMutableTreeNode("N"));     ba.add(new DefaultMutableTreeNode("C"));     ba.add(new DefaultMutableTreeNode("E"));     bb.add(new DefaultMutableTreeNode("U"));     bb.add(new DefaultMutableTreeNode("K"));     b.add(ba);     b.add(bb);     return root; }</code></pre></li><li><p><strong>TreeModel构造JTree</strong></p><pre><code> public void jTreeModel(){     JFrame jFrame = new JFrame();     Container container = jFrame.getContentPane();     DefaultTreeModel model = new DefaultTreeModel(getRoot());     JTree jTree = new JTree(model);     //jTree.putClientProperty("JTree.lineStyle","Horizontal");     //jTree.putClientProperty("JTree.lineStyle","Angled");     DefaultTreeCellRenderer renderer = (DefaultTreeCellRenderer)jTree.getCellRenderer();     renderer.setLeafIcon(new ImageIcon(getPureImage(Color.GRAY,20,10)));     jTree.addMouseListener(new MouseAdapter() {         public void mouseClicked(MouseEvent e) {             JTree tree = (JTree)e.getSource();             TreePath path = tree.getPathForLocation(e.getX(),e.getY());             if(path != null) {                 TreeNode node = (TreeNode) path.getLastPathComponent();                 //System.out.println(node.toString());             }         }     });     jTree.setEditable(true);     TreeModel treeModel = jTree.getModel();     treeModel.addTreeModelListener(new TreeModelAdapter(){         @Override         public void treeNodesChanged(TreeModelEvent e) {             TreeNode node = (TreeNode)(e.getTreePath().getLastPathComponent());             if(node != null){                 TreeNode leaf = node.getChildAt(e.getChildIndices()[0]);                 System.out.println(leaf.toString());             }         }     });     JScrollPane jScrollPane = new JScrollPane(jTree,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);     container.add(jScrollPane);     try {         UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");     } catch (Exception e) {         e.printStackTrace();     }     jFrame.setVisible(true);     jFrame.setSize(300,200); }</code></pre></li></ol><hr><h4 id="对话框-JOptionPane与JDialog"><a href="#对话框-JOptionPane与JDialog" class="headerlink" title="对话框(JOptionPane与JDialog)"></a>对话框(JOptionPane与JDialog)</h4><hr><h4 id="菜单与工具栏"><a href="#菜单与工具栏" class="headerlink" title="菜单与工具栏"></a>菜单与工具栏</h4><ol><li><p><strong>JMenu</strong></p><pre><code> public void jOptionPaneMenuBar(){     JFrame jFrame = new JFrame("dialog");     Container container = jFrame.getContentPane();     JPanel panel = new JPanel();     ((FlowLayout)panel.getLayout()).setAlignment(FlowLayout.LEFT);     JButton btn = new JButton("show");     btn.addActionListener((ActionEvent e) -&gt;{         JOptionPane.showMessageDialog(jFrame,"错误","标题", JOptionPane.ERROR_MESSAGE);     });     panel.add(btn);     container.add(panel);     JMenuBar bar = new JMenuBar();     JMenu menu = new JMenu("file",false);     menu.setMnemonic('F');     JMenuItem item1 = new JMenuItem("new");     JMenuItem item2 = new JMenuItem("open");     JMenuItem item3 = new JMenuItem("save");     item1.setAccelerator(KeyStroke.getKeyStroke('N',java.awt.event.InputEvent.CTRL_DOWN_MASK,false));     item2.setAccelerator(KeyStroke.getKeyStroke('O',java.awt.event.InputEvent.CTRL_DOWN_MASK,false));     item3.setAccelerator(KeyStroke.getKeyStroke('S',java.awt.event.InputEvent.CTRL_DOWN_MASK,false));     item1.setIcon(new ImageIcon(getPureImage(Color.RED,20,20)));     item2.setIcon(new ImageIcon(getPureImage(Color.ORANGE,20,20)));     item3.setIcon(new ImageIcon(getPureImage(Color.YELLOW,20,20)));     item1.setHorizontalTextPosition(SwingConstants.RIGHT);     item2.setHorizontalTextPosition(SwingConstants.RIGHT);     item3.setHorizontalTextPosition(SwingConstants.RIGHT);     item1.addActionListener((ActionEvent e) -&gt; {         System.out.println("new");     });     JMenu preMenu = new JMenu("Preferences");     JMenuItem importItem = new JMenuItem("Import");     JMenuItem exportItem = new JMenuItem("Export");     preMenu.add(importItem);     preMenu.add(exportItem);     menu.add(item1);     menu.add(item2);     menu.add(item3);     menu.addSeparator();     menu.add(preMenu);     //JCheckBoxMenuItem     JMenu menu1 = new JMenu("Style");     JCheckBoxMenuItem lItem = new JCheckBoxMenuItem("Left");     JCheckBoxMenuItem cItem = new JCheckBoxMenuItem("Center");     JCheckBoxMenuItem rItem = new JCheckBoxMenuItem("Right");     JCheckBoxMenuItem jItem = new JCheckBoxMenuItem("Justify");     lItem.setAccelerator(KeyStroke.getKeyStroke('L',InputEvent.ALT_DOWN_MASK,false));     cItem.setAccelerator(KeyStroke.getKeyStroke('C',InputEvent.ALT_DOWN_MASK,false));     rItem.setAccelerator(KeyStroke.getKeyStroke('R',InputEvent.ALT_DOWN_MASK,false));     jItem.setAccelerator(KeyStroke.getKeyStroke('J',InputEvent.ALT_DOWN_MASK,false));     menu1.add(lItem);     menu1.add(cItem);     menu1.add(rItem);     menu1.add(jItem);     //JRadioButtonMenuItem     JMenu menu2 = new JMenu("Color");     JRadioButtonMenuItem redItem = new JRadioButtonMenuItem("Red");     JRadioButtonMenuItem yItem = new JRadioButtonMenuItem("Yellow");     JRadioButtonMenuItem bItem = new JRadioButtonMenuItem("Blue");     redItem.setAccelerator(KeyStroke.getKeyStroke('R',InputEvent.SHIFT_DOWN_MASK,false));     ButtonGroup group = new ButtonGroup();     group.add(redItem);     group.add(yItem);     group.add(bItem);     menu2.add(redItem);     menu2.add(yItem);     menu2.add(bItem);     bar.add(menu);     bar.add(menu1);     bar.add(menu2);     //bar.setOpaque(false);     Font font = new Font("宋体",Font.LAYOUT_LEFT_TO_RIGHT,15);     JToolBar toolBar = new JToolBar();     toolBar.setFloatable(true);     AbstractAction action = new AbstractAction() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println(e.getActionCommand());         }     };     JButton btns;     btns = toolBar.add(action);     btns.setActionCommand("NEW");     btns.setToolTipText("NEW");     btns.setIcon(getImageIcon2D(getPureImage(Color.GRAY,50,30),"NEW",font,Color.RED));     btns.setBorder(BorderFactory.createEmptyBorder());     toolBar.addSeparator();     btns = toolBar.add(action);     btns.setActionCommand("OPEN");     btns.setToolTipText("OPEN");     btns.setIcon(getImageIcon2D(getPureImage(Color.GRAY,50,30),"OPEN",font,Color.RED));     btns.setBorder(BorderFactory.createEmptyBorder());     toolBar.addSeparator();     btns = toolBar.add(action);     btns.setActionCommand("CLOSE");     btns.setToolTipText("CLOSE");     btns.setIcon(getImageIcon2D(getPureImage(Color.GRAY,50,30),"CLOSE",font,Color.RED));     btns.setBorder(BorderFactory.createEmptyBorder());     JLabel fontStyle = new JLabel(getImageIcon2D(getPureImage(Color.GRAY,50,30),"FONT:",font,Color.GREEN));     JComboBox comboBox = new JComboBox(new String[]{"A","B","C"});     toolBar.addSeparator();     toolBar.add(fontStyle);     toolBar.add(comboBox);     /*     JButton btn1 = new JButton(getImageIcon2D(getPureImage(Color.GRAY,50,30),"NEW",font,Color.RED));     JButton btn2 = new JButton(getImageIcon2D(getPureImage(Color.GRAY,50,30),"OPEN",font,Color.ORANGE));     JButton btn3 = new JButton(getImageIcon2D(getPureImage(Color.GRAY,50,30),"CLOSE",font,Color.BLUE));     JLabel fontStyle = new JLabel(getImageIcon2D(getPureImage(Color.GRAY,50,30),"FONT:",font,Color.GREEN));     JComboBox comboBox = new JComboBox(new String[]{"A","B","C"});     btn1.setBorder(BorderFactory.createEmptyBorder());     btn2.setBorder(BorderFactory.createEmptyBorder());     btn3.setBorder(BorderFactory.createEmptyBorder());     toolBar.add(btn1);     toolBar.addSeparator();     toolBar.add(btn2);     toolBar.addSeparator();     toolBar.add(btn3);     toolBar.addSeparator();     toolBar.add(fontStyle);     toolBar.add(comboBox);     */     container.add(bar,BorderLayout.NORTH);     container.add(toolBar,BorderLayout.SOUTH);     //panel.add(new JLabel(getImageIcon2D(getPureImage(Color.black,100,100),"测试",font,Color.WHITE)));     jFrame.setVisible(true);     //jFrame.setSize(300,200);     jFrame.pack(); }</code></pre></li><li><p><strong>JPopupMenu</strong></p><pre><code> public void jPopupMenu(){     JFrame jFrame = new JFrame("PopupMenu");     Container container = jFrame.getContentPane();     Font font = new Font("Microsoft YaHei",Font.LAYOUT_LEFT_TO_RIGHT,10);     JPopupMenu popupMenu = new JPopupMenu();     popupMenu.setBorder(BorderFactory.createLineBorder(Color.GRAY));     AbstractAction action = new AbstractAction() {         @Override         public void actionPerformed(ActionEvent e) {             System.out.println(e.getActionCommand());         }     };     MouseAdapter mouse = new MouseAdapter() {         @Override         public void mouseEntered(MouseEvent e) {             if(e.getSource() instanceof JMenuItem){                 JMenuItem item = (JMenuItem) e.getSource();                 item.setBackground(Color.BLUE);                 item.setForeground(Color.WHITE);             }         }         @Override         public void mouseExited(MouseEvent e) {             if(e.getSource() instanceof JMenuItem){                 JMenuItem item = (JMenuItem) e.getSource();                 item.setBackground(popupMenu.getBackground());                 item.setForeground(Color.BLACK);             }         }     };     JMenuItem item;     String title;     item = popupMenu.add(action);     popupMenu.add(item);     item.setActionCommand(title = "NEW");     item.setText(title);     item.addMouseListener(mouse);     item.setIcon(getImageIcon2D(getPureImage(Color.GRAY,30,20),title,font,Color.RED));     item = popupMenu.add(action);     item.setActionCommand(title = "OPEN");     item.setText(title);     item.addMouseListener(mouse);     item.setIcon(getImageIcon2D(getPureImage(Color.GRAY,30,20),title,font,Color.RED));     popupMenu.addSeparator();     item = popupMenu.add(action);     item.setActionCommand(title = "SAVE");     item.setText(title);     item.addMouseListener(mouse);     item.setIcon(getImageIcon2D(getPureImage(Color.GRAY,30,20),title,font,Color.RED));     JPanel panel = new JPanel();     panel.add(popupMenu);     container.add(panel);     jFrame.addMouseListener(new MouseAdapter() {         @Override         public void mouseClicked(MouseEvent e) {             if(e.getButton() == MouseEvent.BUTTON3) {                 popupMenu.setVisible(true);                 popupMenu.setLocation(e.getXOnScreen(), e.getYOnScreen());             }             else popupMenu.setVisible(false);         }     });     jFrame.setSize(300,200);     jFrame.setVisible(true); }</code></pre></li></ol><hr><h4 id="文件选择丶颜色选择丶分割线"><a href="#文件选择丶颜色选择丶分割线" class="headerlink" title="文件选择丶颜色选择丶分割线"></a>文件选择丶颜色选择丶分割线</h4><ol><li><p><strong>JFileChooser</strong></p><pre><code> public void jFileChooser(){     try {         //look and feel 使用Windows系统外观         UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");     } catch (Exception e) {         e.printStackTrace();     }     JFrame frame = new JFrame("fileChooser");     Container container = frame.getContentPane();     JMenuBar bar = new JMenuBar();     JMenu menu = new JMenu("file");     JMenuItem open = new JMenuItem("open");     JMenuItem save = new JMenuItem("save");     menu.add(open);     menu.add(save);     bar.add(menu);     container.add(bar,BorderLayout.NORTH);     JTextArea area = new JTextArea();     JScrollPane scrollPane = new JScrollPane(area,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);     container.add(scrollPane);     JFileChooser chooser = new JFileChooser("C:\\Users\\NBL\\Desktop\\web\\c");     chooser.setFileFilter(new FileFilter() {         String name;         @Override         public boolean accept(File f) {             name = f.getName();             int index = name.lastIndexOf('.');             if(index &gt;0 &amp;&amp; index &lt; name.length()-1){                 String type = name.substring(index+1,name.length());                 if("html".equals(type) || "txt".equals(type))                     return true;             }             return false;         }         @Override         public String getDescription() {             return "*.txt *.html";         }     });     chooser.setFileView(new FileView() {         String name;         @Override         public Icon getIcon(File f) {             name = f.getName();             Font font = new Font("Microsoft YaHei",Font.LAYOUT_LEFT_TO_RIGHT,10);             int index = name.lastIndexOf('.');             if(index &gt;0 &amp;&amp; index &lt; name.length()-1){                 String type = name.substring(index+1,name.length());                 if("html".equals(type))                     return getImageIcon2D(getPureImage(Color.black,50,50),"网页",font,Color.MAGENTA);                 else if("txt".equals(type))                     return getImageIcon2D(getPureImage(Color.black,50,50),"文本",font,Color.red);             }             return getImageIcon2D(getPureImage(Color.black,50,50),"OTHER",font,Color.WHITE);         }     });     //add event     ActionListener action = e -&gt; {         File file;         StringBuilder builder = new StringBuilder();         BufferedReader reader = null;         BufferedWriter writer = null;         String command = e.getActionCommand();         if("open".equals(command)){             chooser.setDialogTitle("打开文件");             chooser.setApproveButtonText("确定");             int state = chooser.showOpenDialog(frame);             if(state == JFileChooser.APPROVE_OPTION){                 file = chooser.getSelectedFile();                 try {                     reader = new BufferedReader(new FileReader(file));                     String str;                     while((str = reader.readLine()) != null)                         builder.append(str+System.getProperty("line.separator"));                     area.setText(builder.toString());                 } catch (Exception e1) {                     e1.printStackTrace();                 } finally {                     try {                         reader.close();                     } catch (IOException e1) {                         e1.printStackTrace();                     }                 }             }         }         else if("save".equals(command)){             chooser.setDialogTitle("存储文件");             chooser.setApproveButtonText("保存");             int state = chooser.showOpenDialog(frame);             if(state == JFileChooser.APPROVE_OPTION){                 file = chooser.getSelectedFile();                 try {                     writer = new BufferedWriter(new FileWriter(file));                     writer.write(area.getText());                 } catch (IOException e1) {                     e1.printStackTrace();                 } finally {                     try {                         writer.close();                     } catch (IOException e1) {                         e1.printStackTrace();                     }                 }             }         }     };     open.addActionListener(action);     save.addActionListener(action);     frame.setSize(300,200);     frame.setVisible(true); }</code></pre></li><li><p><strong>JColorChooser</strong></p><pre><code> public void jColorChooser(){     try {         UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");     } catch (Exception e) {         e.printStackTrace();     }     JFrame frame = new JFrame("colorChooser");     Container container = frame.getContentPane();     JTextArea area = new JTextArea(5,30);     container.add(area);     JButton btn = new JButton("选择颜色");     btn.addActionListener(e -&gt;{         Color color = JColorChooser.showDialog(frame,"选择颜色",area.getForeground());         if(color != null){             area.setForeground(color);         }     });     JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));     panel.add(btn);     container.add(panel,BorderLayout.NORTH);     //in container     JToolBar toolBar = new JToolBar();     JColorChooser colorChooser = new JColorChooser(Color.WHITE);     AbstractColorChooserPanel[] chooserPanels = colorChooser.getChooserPanels();     colorChooser.removeChooserPanel(chooserPanels[1]);     colorChooser.removeChooserPanel(chooserPanels[2]);     colorChooser.removeChooserPanel(chooserPanels[4]);     colorChooser.getSelectionModel().addChangeListener(e -&gt; {         Color color = colorChooser.getColor();         area.setForeground(color);     });     toolBar.add(colorChooser);     container.add(toolBar,BorderLayout.EAST);     //frame.setSize(300,200);     frame.pack();     frame.setVisible(true); }</code></pre></li><li><p><strong>JSeparator</strong></p><pre><code> public void jSeparator(){     JFrame frame = new JFrame("separator");     Container container = frame.getContentPane();     container.setLayout(new BorderLayout(1,2));     JPanel panel = new JPanel(new GridLayout(2,1));     panel.add(new JLabel("Horizontal"));     panel.add(new JSeparator());     JPanel panel1 = new JPanel(new GridLayout(1,2));     panel1.add(new JLabel("&lt;html&gt;V&lt;br/&gt;e&lt;br/&gt;r&lt;br/&gt;t&lt;br/&gt;i&lt;br/&gt;c&lt;br/&gt;a&lt;br/&gt;l"));     panel1.add(new JSeparator(JSeparator.VERTICAL));     container.add(panel);     container.add(panel1,BorderLayout.EAST);     frame.setSize(300,200);     frame.setVisible(true); }</code></pre></li></ol><hr><h4 id="滑动杆丶时间控制丶进度组件"><a href="#滑动杆丶时间控制丶进度组件" class="headerlink" title="滑动杆丶时间控制丶进度组件"></a>滑动杆丶时间控制丶进度组件</h4><ol><li><p><strong>JSlider</strong></p><pre><code> public void jSlider(){     /*          try {         UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");     } catch (Exception e) {         e.printStackTrace();     }     */     JFrame frame = new JFrame("slider");     Container container = frame.getContentPane();     JPanel panel = new JPanel();     JPanel panel1 = new JPanel();     JPanel panel2 = new JPanel();     panel.setBorder(BorderFactory.createLineBorder(Color.GRAY));     panel1.setBorder(BorderFactory.createLineBorder(Color.GRAY));     panel2.setBorder(BorderFactory.createLineBorder(Color.GRAY));     JLabel label = new JLabel("当前刻度: ");     JLabel label1 = new JLabel("当前刻度: ");     JLabel label2 = new JLabel("当前刻度: ");     JSlider slider = new JSlider(0,100);     JSlider slider1 = new JSlider(0,100);     JSlider slider2 = new JSlider(JSlider.VERTICAL,0,100,50);     slider.setPaintTicks(true); //添加刻度     slider.setMajorTickSpacing(30); //大刻度间距     slider.setMinorTickSpacing(10); //小刻度间距     slider.setPaintTrack(true); //是否显示滑动杆横杆(默认为true)     slider.setPaintLabels(true); //绘制数字标记     slider.setSnapToTicks(true);  //点击时一次移动一个小刻度     slider.putClientProperty("JSlider.isFilled",true); //设置滑动杆左右2侧颜色不一样     //自定义标记名称     Hashtable&lt;Integer,JLabel&gt; table = new Hashtable&lt;&gt;();     table.put(new Integer(30),new JLabel("低"));     table.put(new Integer(60),new JLabel("中"));     table.put(new Integer(90),new JLabel("高"));     slider.setLabelTable(table);     ChangeListener change = e -&gt; {         JSlider s = (JSlider) e.getSource();         if(s == slider) label.setText("当前刻度: "+s.getValue());         else if(s == slider1) label1.setText("当前刻度: "+s.getValue());         else if(s == slider2) label2.setText("当前刻度: "+s.getValue());     };     slider.addChangeListener(change);     slider1.addChangeListener(change);     slider2.addChangeListener(change);     slider2.setExtent(90);     panel.add(label);     panel.add(slider);     panel1.add(label1);     panel1.add(slider1);     panel2.add(label2);     panel2.add(slider2);     panel.setPreferredSize(new Dimension(100,50));     panel1.setPreferredSize(new Dimension(100,50));     panel2.setPreferredSize(new Dimension(50,100));     Box box = Box.createHorizontalBox();     Box box1 = Box.createVerticalBox();     Box box2 = Box.createVerticalBox();     Box box3 = Box.createVerticalBox();     Box box4 = Box.createVerticalBox();     box.add(box1);     box.add(box2);     box1.add(box3);     box1.add(box4);     box3.add(panel);     box4.add(panel1);     box2.add(panel2);     container.add(box);     frame.setSize(400,300);     frame.setVisible(true); }</code></pre></li><li><p><strong>Timer</strong></p><ul><li><p>已过时,推荐使用ScheduledThreadPoolExecutor替换</p><pre><code>Timer timer;int delay;int index = 0;public void Timer(){  try {      UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");  } catch (Exception e) {      e.printStackTrace();  }  JFrame frame = new JFrame("Timer");  Container container = frame.getContentPane();  JPanel label = new JPanel();  label.setBackground(Color.gray);  JSlider slider = new JSlider(1000,10000);  slider.setPaintTicks(true);  slider.setPaintLabels(true);  slider.setMinorTickSpacing(500);  slider.setMajorTickSpacing(2000);  slider.setSnapToTicks(true);  JPanel panel = new JPanel();  JButton start = new JButton("start");  JButton reStart = new JButton("reStart");  JButton repeats = new JButton("don't repeats");  panel.add(start);  panel.add(reStart);  panel.add(repeats);  Box box = Box.createVerticalBox();  box.add(label);  box.add(slider);  Color[] colors = {Color.RED,Color.ORANGE,Color.YELLOW, Color.GREEN,Color.CYAN,Color.BLUE,Color.MAGENTA,Color.pink};  //Event  ActionListener action = e -&gt; {      String command = e.getActionCommand();      if("start".equals(command)){          delay = slider.getValue();          timer = new Timer(delay,es-&gt;{   //Timer              label.setBackground(colors[index++&amp;7]);          });          start.setText("stop");          timer.start();      }      else if("stop".equals(command)){          start.setText("start");          timer.stop();      }      else if("reStart".equals(command)){          timer.restart();      }      else if("don't repeats".equals(command)){          repeats.setText("repeats");          timer.setRepeats(false);      }      else if("repeats".equals(command)){          repeats.setText("don't repeats");          timer.setRepeats(true);          timer.restart();      }  };  start.addActionListener(action);  reStart.addActionListener(action);  repeats.addActionListener(action);  slider.addChangeListener(e -&gt; {      if(timer != null) timer.setDelay(slider.getValue());  });  container.add(box);  container.add(panel,BorderLayout.SOUTH);  frame.setSize(300,200);  frame.setVisible(true);}</code></pre></li></ul></li><li><p><strong>Progress</strong></p><pre><code> public void jProgressBar(){     try {         UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");     } catch (Exception e) {         e.printStackTrace();     }     JFrame frame = new JFrame("progressBar");     Container container = frame.getContentPane();     container.setLayout(new GridLayout(3,1));     JPanel panel = new JPanel();     JButton btn = new JButton("start");     panel.add(btn);     //未覆盖前的进度条颜色     UIManager.put("ProgressBar.selectionBackground",Color.WHITE);     //覆盖后的进度条颜色     UIManager.put("ProgressBar.selectionForeground",Color.BLACK);     JProgressBar bar = new JProgressBar(0,100);     bar.setOrientation(JProgressBar.HORIZONTAL); //水平进度条     bar.setValue(0);     bar.setStringPainted(true); //显示进度信息     bar.setString("logging..."); //设置进度信息     bar.setBorderPainted(false); //不显示边框     bar.setForeground(Color.ORANGE); //前景色     bar.setBackground(Color.GRAY);  //背景色     JLabel label = new JLabel("当前进度: " + "0%");     //Event     Timer timer = new Timer(100,es -&gt; {         if(bar.getValue() &lt; 100) {             bar.setValue(bar.getValue() + 1);             label.setText("当前进度: " + bar.getValue() + "%");         }         if(bar.getValue() == 100) bar.setString("complete");     });     btn.addActionListener(e-&gt;{         String command = e.getActionCommand();         if("start".equals(command)){             timer.start();             btn.setText("stop");         }         else if("stop".equals(command)){             timer.stop();             btn.setText("start");         }     });     container.add(panel);     container.add(bar);     container.add(label);     frame.setSize(300,200);     frame.setVisible(true); }</code></pre><pre><code> int ms = 0; public void progressMonitor(){     JFrame frame = new JFrame("ProgressMonitor");     Container container = frame.getContentPane();     JPanel panel = new JPanel();     JButton btn = new JButton("start");     ProgressMonitor monitor = new ProgressMonitor(frame,"show Progress Mointor","",0,100);     monitor.setNote("note");     monitor.setProgress(0);     monitor.setMillisToDecideToPopup(0);     monitor.setMillisToPopup(1000);     Timer timer = new Timer(50,e -&gt; {        monitor.setProgress(ms++);     });     btn.addActionListener(e -&gt; {         timer.start();     });     panel.add(btn);     container.add(panel,BorderLayout.NORTH);     frame.setSize(300,200);     frame.setVisible(true); }</code></pre><pre><code> public void progressMonitorInputStream(){     try {         UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());     } catch (Exception e) {         e.printStackTrace();     }     JFrame frame = new JFrame();     Container container = frame.getContentPane();     JPanel panel = new JPanel();     JButton btn = new JButton("start");     panel.add(btn);     JTextArea area = new JTextArea();     JScrollPane scrollPane = new JScrollPane(area,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);     container.add(panel,BorderLayout.NORTH);     container.add(scrollPane);     JFileChooser fileChooser = new JFileChooser();     fileChooser.setMultiSelectionEnabled(false);     //Event     btn.addActionListener(e -&gt; {         int state = fileChooser.showOpenDialog(frame);         if(state == JFileChooser.APPROVE_OPTION){             new Thread(()-&gt;{                 File file = fileChooser.getSelectedFile();                 String str = "";                 byte[] buff = new byte[1];                 DecodeResult result = null;                 byte[] buffers = null;                 try {                     ProgressMonitorInputStream monitorInputStream = new ProgressMonitorInputStream(frame,"Running...",new FileInputStream(file));                     while(monitorInputStream.read(buff) != -1){                         if(result != null &amp;&amp; result.buffer != null) {                             int remainL = result.buffer.length;                             buffers = new byte[remainL + buff.length];                             System.arraycopy(result.buffer,0,buffers,0,remainL);                             System.arraycopy(buff,0,buffers,remainL,buff.length);                         }                         else {                             buffers = new byte[buff.length];                             System.arraycopy(buff,0,buffers,0,buffers.length);                         }                         result = decodeUTF8(buffers,buffers.length);                         str += result.result;                         //str += new String(buff,"UTF-8");                         area.setText(str);                         Thread.sleep(100);                     }                 } catch (Exception e1) {                     e1.printStackTrace();                 }             }).start();         }     });     frame.setSize(300,200);     frame.setVisible(true); }</code></pre></li></ol><hr><h4 id="Look-and-Feel"><a href="#Look-and-Feel" class="headerlink" title="Look and Feel"></a>Look and Feel</h4><blockquote><p>选择系统环境,窗体会根据此环境显示相对应的界面</p></blockquote><pre class="line-numbers language-java"><code class="language-java">UIManager<span class="token punctuation">.</span><span class="token function">setLookAndFeel</span><span class="token punctuation">(</span><span class="token string">"com.sun.java.swing.plaf.windows.WindowsLookAndFeel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-Java垃圾收集器与内存分配策略</title>
      <link href="/2020/03/09/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2020/03/09/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><ol><li><strong>引用计数算法</strong><ul><li>判断对象是否存活的一种算法: 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1,当引用失效时,计数器值就减1;任何适合计数器都为0的对象就是不可能带被使用的</li><li><strong>Java语言没有选用引用计数算法</strong>来管理内存,因为此算法存在缺陷,它很难解决对象之间的互相循环引用问题</li></ul></li><li><strong>根搜索算法</strong><ul><li>在主流的商用程序语言中(Java和C#,甚至古老的Lisp),都是使用跟搜索算法(<strong>GC Roots Trancing</strong>)判定对象是否存活的</li><li>算法基本思路是通过一系列的名为”GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径被称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(即图论中从GC Roots到这个对象不可达)时,则证明此对象先是不可用的</li><li>Java语言中,可作为GC Roots的对象包括下面几种:<ul><li>虚拟机栈(栈帧中的本地变量表)中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中JNI(Native方法)的引用对象</li></ul></li></ul></li><li><strong>引用分类</strong><ul><li>JDK1.2之后,Java对引用的概念进行了扩充,将引用分为<strong>强引用(Strong Reference)丶软引用(Soft Reference)丶弱引用(Weak Reference)丶虚引用(Phantom Reference)</strong> 四种</li><li><strong>强引用</strong> 就是指在程序代码中普遍存在的,类似”Object obj = new Objcet()”,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象</li><li><strong>软引用</strong> 用来描述一些还有用,但并非必须的对象,对于软引用关联的对象,在系统将要发生内存溢出异常之前,将会把这些对象列进回收范围之中并进行第二次回收,如果这次回收还是没有足够的内存,才会抛出内存溢出异常,在JDK1.2之后,提供了<strong>SoftReference</strong>类来实现软引用</li><li><strong>弱引用</strong> 也是用来描述非必须对象的,但是他的强度比软引用更弱一些,被弱引用关联的对象只能生存到下一次垃圾收集发生之前,当垃圾收集器工作时,无论当前内存是否足够,都会回收掉只被若引用关联的对象,JDK1.2之后,提供了<strong>WeakReference</strong> 类实现若引用</li><li><strong>虚引用</strong> 也被称为幽灵引用或者幻影引用,它是最弱的一种引用关系,一个对象是否有虚引用存在,完全不会对其生存时间构成影响,也无法通过虚引用来取的一个对象实例,为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知.JKD1.2之后,提供了<strong>PhantomReference</strong> 类来实现虚引用</li></ul></li><li><strong>对象回收过程</strong><ul><li>在跟搜索算法中不可达的对象,也并非是”非死不可”的,这个时候他们暂时处于”唤醒”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程<ul><li>如果对象在进行根搜索后发现没有与GC Roots相连接的引用链,那它将会被<strong>第一次标记并且进行一次筛选</strong></li><li>筛选的条件是次对象是否有必要执行finalize()方法,当对象没有重写finalize()方法,或者finalize()方法已经被虚拟机调用过时,虚拟机将这两种情况都视为”没有必要执行”</li><li>如果这个对象被判定为有必要执行finalize()方法,那么这个对象会被放置在一个名为F-Queue的对象中,并在稍后又一条虚拟机自动建立的丶低优先级的Finanlizer线程去执行(仅触发这个方法,不承诺会等待它运行结束)</li><li>稍后GC将对F-Queue中的对象进行<strong>第二次小规模标记</strong> ,在此之前finalize()方法执行可以拯救对象被回收的命运,只要重新与引用链上的任何一个对象建立关联即可(如this赋值给某个类变量或者对象的成员变量)</li><li>不建议使用finalize()方法</li></ul></li></ul></li><li><strong>回收方法区</strong><ul><li>很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的,Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集,而且在方法区进行垃圾手机的”性价比”一般比较低</li><li>永久代的垃圾收集主要回收两部分内容: <strong>废弃常量</strong>(如常量池中) 和 <strong>无用的类</strong></li><li>类需要同时满足下面三个条件才能算 <strong>无用的类</strong><ul><li>该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法</li></ul></li><li>虚拟机可以对满足上述三个条件的无用类进行回收,这里说的仅仅是”可以”,但是是否对类进行回收,HotSpot虚拟机提供了-Xnoclassgc参数进行控制,还可以使用-verbose:class及-XX:+TraceClassLoading丶-XX:+TraceClassUnloading查看类的加载和卸载信息,-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用,但是-XX:+TranceClassUnLoading参数需要fastdebug版的虚拟机支持</li><li>在大量使用反射丶动态代理丶CGlib等bytecode框架的场景,以及动态生成jsp和OSGi这类品频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出</li></ul></li></ol><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ol><li><strong>标记-清除算法(Mark-Sweep)</strong><ul><li>最基础的收集算法是”标记-清除”(Mark-Sweep)算法,算法分为”标记”和”清除”两个阶段,后续的收集算法都是基于这种思路的改进版本</li><li>首先标记出所有需要回收的对象,在标记完成后统一回收掉所有被标记的对象</li><li>它的主要<strong>缺点</strong>有两个: 一个是效率问题,标记和清除过程的效率都不高;另外一个是空间问题,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li><li><strong>复制算法(Copying)</strong><ul><li>为了解决效率问题,一种称为”复制”(Copying)的收集算法出现了,它将可用内存按容量划分为大小相等的凉快,每次只使用其中一块,当这块的内存用完了,就将还存活着的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉</li><li><strong>优点:</strong> 不用在考虑内存碎片等复杂情况,只要移动堆顶指针,按顺序分配内存即可,实现简单,运行高效</li><li><strong>缺点:</strong> 这种算法将内存缩小为原来的一半,代价太大</li><li>现在的商业虚拟机都采用这种收集算法来回收新生代,IBM的专门研究表明,新生代中的对象98%都是朝生暮死的,所以并不需要按照1:1的比例来划分内存空间,而是将内存分为一块较大的Eden空间和两块较小的Survivor空间,每次使用Eden和其中的一块Survivor,当回收时将Eden和Survivor中还存活着的对象一次性的拷贝到另外一块Survivor空间上,最后清理掉Eden和刚才用过的Survivor空间(当Survivor空间不够用时,需要依赖其他内存(老年代)进行分配担保)</li><li>HotSpot虚拟机默认Eden和Survivor的大小比例为8:1</li></ul></li><li><strong>标记-整理算法(Mark-Compact)</strong><ul><li>复制收集算法在对象存活率较高时需要执行较多的复制操作,效率将会变低,在老年代中一般不能直接选用这种算法</li><li>标记整理算法的标记过程仍然与”标记-清除”算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉端边界以外的内存</li></ul></li><li><strong>分代收集算法(Generational Collection)</strong><ul><li>当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)算法,根据对象的存活周期的不同将内存划分为几块,一般把Java堆分为新生代和老年代,这样就可以根据各个年代的特点采用最适合的收集算法</li><li><strong>新生代中</strong>,对象大多朝生暮死,因此选用复制算法</li><li><strong>老年代中</strong>,对象存活率高,因此选用”标记-清除”或者”标记-整理”算法</li></ul></li></ol><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ol><li><strong>概述</strong><ul><li>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定,因此不同厂商丶不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别,并且<strong>一般都会提供参数供用户根据自己应用的特点和要求组合出各个年代所使用的收集器</strong></li><li>下面讨论的收集器是基于Sun HotSpot虚拟机1.6版Update22,这个虚拟机包含了7个垃圾收集器<strong>Serial丶ParNew丶paralle Scavenge丶G1丶CMS丶Parallel Old丶Serial Old(MSC)</strong></li><li>可从网络查找详细的搭配关系图(是否可以搭配使用),</li></ul></li><li><strong>Serial收集器</strong><ul><li>Serial收集器是最基本丶历史最悠久的收集器,这个收集器是单线程收集器,当它进行垃圾收集时,必须暂停其他所有的工作线程(Stop The World),直到它收集结束,对比其他收集器而言,主要<strong>优点是简单高效</strong></li><li>Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择</li></ul></li><li><strong>ParNew收集器</strong><ul><li>ParNew收集器其实就是Serial收集器的多线程版本,除了使用多线程进行垃圾收集之外,其余和Serial收集器完全相同</li><li>它是许多运行在Server模式下的虚拟机中首选的新生代收集器,其中一个原因是目前除了Serial收集器外, 只有它能与CMS收集器(划时代)配合使用</li></ul></li><li><strong>Parallel Scavenge收集器</strong><ul><li>Parallel Scavenge收集器也是一个新生代收集器,他也是使用复制算法的收集器,又是并行的多线程收集器</li><li>Parallel Scavenge收集器的目标是达到一个可控制的吞吐量(Throughput)</li><li>停顿时间越短就越适合需要与用户交互的程序;而高吞吐量则可以最高效率的利用CPU时间,尽快的完成程序的运算任务,主要适合在后台运算而不需要太多交互的任务</li><li>参数-XX:MaxGCPauseMillis控制最大垃圾收集停顿时间,-XX:GCTimeRatio参数设置吞吐量大小</li><li>参数-XX:+UseAdapttiveSizePolicy是一个开关参数,打开之后就不需要手工指定新生代的大小(-Xmn)丶Eden与Survivor区的比例(-XX:SurvivorRatio)丶晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了,虚拟机会根据情况动态调整</li></ul></li><li><strong>Serial Old收集器</strong><ul><li>Serial Old是Serial收集器的老年代版本,它同样是一个单线程收集器,使用”标记-整理”算法</li><li>这个收集器主要意义是被Client模式下的虚拟机使用,在Server模式下,还有两大用途:一个是与Parallel Scavenge收集器搭配,另一个是作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure的时候使用</li></ul></li><li><strong>Parallel Old收集器</strong><ul><li>Parallel Old是Parallel Scavenge收集器的老年代版本,使用多线程和”标记-整理”算法</li><li>在注意吞吐量及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge+Parallel Old收集器组合</li></ul></li><li><strong>CMS收集器</strong><ul><li>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器,目前B/S系统中,这类应用尤其重视服务的响应速度,CMS收集器就非常符合这类应用的需求</li><li>CMS收集器是基于”标记-清除”算法实现的,整个过程稍微复杂,分为4个步骤:<ul><li>初始标记(CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep)</li></ul></li><li>其中初始标记丶重新标记两个步骤仍然需要”Stop The World”,初始标记仅仅是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC Roots Tracing的过程,而重新标记阶段则是为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短</li><li>CMS主要有点就是<strong>并发收集丶低停顿</strong> ,但同时也有三个显著缺点:<ul><li>CMS收集器对CPU资源非常敏感,并发阶段默认启动的回收线程数是(CPU数量+3/4),当CPU越少时,垃圾收集线程占用的CPU资源就越大</li><li>CMS收集器无法处理浮动垃圾(Floating Garbage),即CMS清理阶段用户线程还在运行,在此过程产生的垃圾,CMS会留待下一次GC时清理掉,同时在垃圾收集阶段用户线程还需要运行,则需要预留足够的内存空间给用户线程使用,如果预留的内存无法满足程序需要,就会出现一次”Concurrent Mode Failure”失败,这时候虚拟机将启动后备预案:临时启动Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长,因此参数-XX:CMSInitiatingOccupancyFraction设置的太高将很容易导致大量失败,性能反而降低</li><li>CMS采用”标记-清除”算法会产生大量空间碎片,当无法找到足够大的连续空间分配对象时,不得不提前触发一次Full GC,参数-XX:+UseCMSCompactAtFullCollection开关用于享受完”Full GC”之后额外附送一个碎片整理过程,参数-XX:CMSFullGCsBeforeCompaction用于设置在执行多少次不压缩的Full GC后,跟着来一次压缩</li></ul></li></ul></li><li><strong>G1收集器</strong><ul><li>G1收集器是基于”标记-整理”算法实现的,也就是说不会产生空间碎片,这对于长时间运行的应用系统来说非常重要</li><li>第二个特点是它可以非常精确的控制停顿(用户可指定)</li><li>G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收</li><li>G1将整个Java堆(新生代丶老年代)划分为多个大小固定的独立区域(Region),并且跟踪这些区域里面的垃圾堆积程度,在后台维护一个优先列表,每次根据允许的收集时间,优先回收垃圾最多的区域(这就是Garbage First名称由来)</li><li>区域划分及优先级的区域回收,保证了G1收集器在有限的时间内可以获得更高的收集效率</li></ul></li></ol><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><ol><li><strong>对象优先在Eden分配</strong><ul><li>大多数情况下,对象在新生代Eden区中分配,当Eden区没有足够的空间进行分配时,虚拟机将发起一次Minor GC(转移到Survivor空间,如果不够就会通过分配担保机制提前转移到老年代中去)</li></ul></li><li><strong>大对象直接进入老年代</strong><ul><li>大对象指,需要大量连续内存空间的Java对象(如很长的字符串及数组)</li><li>设置-XX:PretenureSizeThreshold参数,可以令大于这个设置值的对象直接在老年代中分配(只对Serial和ParNew收集器有效)</li><li>大对象放入老年代的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝</li></ul></li><li><strong>长期存活的对象将进入老年代</strong><ul><li>虚拟机给每个对象定义了一个对象年龄(Age)计数器,如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并将对象年龄+1,当它的年龄增加到一定程度(默认15)时,就会被晋升到老年代中,年龄阈值,可以通过参数-XX:MaxTenuringThreshold设置</li></ul></li><li><strong>动态对象年龄判定</strong><ul><li>为了更好适应不同程序的内存状况,虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代</li><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进去老年代</li></ul></li><li><strong>空间分配担保</strong><ul><li>在发生Minor GC(清理新生代)时,虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小,如果大于,则改为直接进行一次Full GC(清理整个堆),如果小于,则查看HandlePromotionFailure设置是否允许担保失败;如果允许,那只会进行Minor GC;如果不允许,则也要改为进行一次Full GC</li><li>老年代进行分配担保,大部分情况下都会将HandlePromotionFailur(担保失败)开关打开,避免Full GC过于频繁</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-Java内存区域与内存溢出</title>
      <link href="/2020/03/03/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
      <url>/2020/03/03/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><ol><li><strong>概述</strong><ul><li>java虚拟机运行时数据区可分为: <strong>方法区(Method Area)丶虚拟机栈(VM Stack)丶本地方法栈(Native Method Stack)丶堆(Heap),程序计数器(Program Couter Register)</strong></li></ul></li><li><strong>程序计数器</strong><ul><li>程序计数器是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的行号指示器,在虚拟机的概念模型里,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>在多线程中,每条线程都有一个独立的程序计数器,各条线程之间的计数器互不影响,独立存储,这类内存是线程私有的</li><li>如果线程正在执行的一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是Native方法,这个计数器值则为空,此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</li></ul></li><li><strong>java虚拟机栈</strong><ul><li>Java虚拟机栈也是线程私有的,它的生命周期与线程相同,虚拟机栈描述的是Java方法执行的内存模型:每个方法被执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表丶操作栈丶动态链接丶方法出口等信息,每个方法被调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</li><li>经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack),这种分法比较粗糙,而所指的栈就是虚拟机栈,更精确的说应该是虚拟机栈中的局部变量表部分</li><li>局部变量表所需的内存空间在编译期间完成分配,当进去一个方法时,这个方法需要在栈帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小</li><li>在Java虚拟机规范中,对这个区域规定了两种异常状况: 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出<strong>StackOverflowError</strong>异常;如果虚拟机栈可以动态扩展,当扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常</li></ul></li><li><strong>本地方法栈</strong><ul><li>本地方法栈与虚拟机栈所发虚的作用非常相似,其区别不过是虚拟机栈为虚拟机执行Java方法(字节码)服务,而本地方法栈则是为虚拟机使用到的Native方法服务</li><li>虚拟机规范中对本地方法栈中的方法使用的语言丶使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它,甚至有的虚拟机(如Sun HotSpot)直接就把本地方法栈和虚拟机栈合二为一</li><li>与虚拟机栈一样,本地方法栈区域会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常</li></ul></li><li><strong>Java堆</strong><ul><li>对于大多数应用来说,Java堆是Java虚拟机所管理的内存重最大的一块,Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存</li><li>Java堆是垃圾收集器管理的主要区域,因此也被称为”GC堆”(Garbage Collected Heap)</li><li>如果从内存回收的角度看,由于现在收集器基本都是采用的分代收集算法,所以java堆中还可以细分为: <strong>新生代和老年代</strong></li><li>无论如何划分,存储的都仍然是对象实例,进一步划分的目的是为了更好的回收内存,或者更快的分配内存</li><li>根据Java虚拟机规范规定,Java堆可以处于物理上不连续的内存空间,只要逻辑上是连续的即可,就像我们的磁盘空间一样</li><li>在是现时,可以是固定大小或者可扩展的,不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx 和 Xms控制),如果堆中没有内存完成实例分配,并且堆也无法再扩展时,会抛出<strong>OutOfMemoryError</strong>异常</li></ul></li><li><strong>方法区</strong><ul><li>方法区与Java堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息丶常量丶静态变量丶即时编译器编译后的代码等数据,方法区又称为<strong>永久代</strong></li><li>Java虚拟机规范对这个区域的限制非常宽松,除了和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外,还可以选择不实现垃圾收集</li><li>相对而言,垃圾收集行为在这个区域是比较少出现的,但并非数据进入了方法区就永久存在了,一般来说这个区域的回收”成绩”比较难令人满意,尤其是类型的卸载,条件相当苛刻,但是这部分区域的回收确实是有必要的</li><li>在Sun公司的BUG列表中,曾出现过的若干个严重BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致的内存泄漏</li><li>根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将抛出<strong>OutOfMemoryError</strong>异常</li></ul></li><li><strong>运行时常量池(Runtime Constant Pool)</strong><ul><li>运行时常量池是方法区的一部分,Class文件中除了有类的版本丶字段丶方法丶接口等描述等信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将再类加载后存放到方法区的运行时常量池中</li><li>对于运行时常量池,Java虚拟机规范没有做任何细节的要求,不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域,不过一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中</li><li>运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性,Java语言并不要求常量一定只能在编译期产生,运行期间也可能将新的常量放入池中,例如String类的intern()方法</li><li>既然运行时常量池是方法区的一部分,当常量池无法再申请到内存时会抛出<strong>OutOfMemoryError</strong>异常</li></ul></li><li><strong>直接内存(Direct Memory)</strong><ul><li>直接内存并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域,但是这部分内存也被频繁的使用,而且也可能导致<strong>OutOfMemoryError</strong>异常出现</li><li>在NIO中基于通道(Channel)与缓冲区(Buffer)的I/O方式,他可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作,显然本机直接内存的分配不会受到Java堆大小的限制,但是会受到本机总内存的大小及处理器寻址空间的限制</li><li><strong>配置虚拟机参数时,一般会根据实际内存设置-Xmx等参数信息,但经常忽略掉直接内存,从而导致动态扩展时出现OutOfMemoryError异常</strong></li></ul></li></ol><h4 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h4><ol><li>对象访问在Java语言中无处不在,即使是最简单的访问也会涉及Java栈丶Java堆丶方法区</li><li>对Object obj = new Objcet();分析<ul><li><strong>Obect obj</strong> 这部分的语义会反映到Java栈的本地变量表中,作为一个reference类型数据出现</li><li><strong>new Object()</strong>这部分的语义会反映到Java堆中,形成一块存储了Object类型所有实例数据值(Instance Data,对象中各个实例字段的数据)的结构化内存</li><li>另外用于查找到此对象类型数据(如对象类型丶父类丶实现接口丶方法等)的地址信息将存储在方法区中</li></ul></li><li>不同虚拟机实现对象访问的方式会有所不同,主流的访问方式有两种: <strong>使用句柄</strong>和<strong>直接指针</strong><ul><li><strong>使用句柄:</strong> Java堆中将会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据和类型数据各自的具体地址信息</li><li><strong>直接指针:</strong> 如果使用直接指针,Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息,reference中直接存储的就是对象地址</li></ul></li><li>这两种对象的访问方式各有优势,<strong>使用句柄访问方式</strong>的最大好处就是reference中存储的是稳定的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针,而reference本身不需要被修改</li><li><strong>使用直接指针访问方式</strong>的最大好处就是速度更快,它节省了一次指针定位的时间开销,由于对象的访问在java中是非常频繁,因此这类开销积少程度后也是一项非常可观的执行成本</li><li>Sun HotSpot虚拟机使用的是直接指针访问方式</li></ol><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a><strong>内存溢出</strong></h4><ol><li><strong>Java堆溢出</strong><ul><li>Java堆用于存储对象实例,我们只要不断的创建对象,并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象,就会在对象数量到达最大堆容量限制后产生内存溢出异常</li></ul></li><li><strong>虚拟机栈和本地方法栈溢出</strong><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverFlowError,例如无限递归调用</li><li>如果虚拟机在扩展栈时无法申请到足够内存空间,则抛出OutOfMemoryError异常(无限创建线程)</li><li>单线程情况下,无论是栈帧太大,还是虚拟机栈容量太小,当内存无法分配的时候,抛出的都是StackOverFlowError</li></ul></li><li><strong>运行时常量池溢出</strong><ul><li>不断的向运行时常量池添加内容,溢出时抛出OutOfMemoryError</li><li>最简单的做法就是使用String的intern()这个Native方法,该方法作用是: 如果常量池中已经包含一个等于此String对象的字符串,就返回引用,否则将此String对象添加到常量池中再返回引用</li><li>常量池分配在方法区内,可以使用-XX:PermSize和-XX:MaxPermSize设置方法区大小,从而间接限制常量池大小</li></ul></li><li><strong>方法区溢出</strong><ul><li>方法区用于存放Class的相关信息,如类名丶访问修饰符丶常量池丶字段描述丶方法描述等</li><li>对于这个区域测试,运行时产生大量的类去填满方法区,知道溢出,Java SE API可以动态产生类(反射GeneratedConstructorAccessor和动态代理),也可采用CGLib代理直接操作字节码运行时,产生大量的动态类</li><li>在经常动态生成大量Class的应用中,需要特别注意类的回收状况</li></ul></li><li><strong>本机直接内存溢出</strong><ul><li>DirectMemory容量可以通过-XX:MaxDirectMemorySize指定,如果不指定,则默认与Java堆的最大值(-Xmx指定)一样</li><li>虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常,但是实际上并没有真正想操作系统申请分配内存,而是通过计算得知内存无法分配,真正申请分配内存的方法是unsafe.allocateMemory()</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO-选择器</title>
      <link href="/2020/02/25/Selector/"/>
      <url>/2020/02/25/Selector/</url>
      
        <content type="html"><![CDATA[<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ol><li><p><strong>基本</strong></p><ul><li><strong>选择器(Selector):</strong> 选择器类管理着一个被注册的通道集合的信息和他们的就绪状态.通道是和选择器一起被注册的,并且使用选择器来更新通道的就绪状态<pre><code>//选择器维护了一个需要监控的通道集合,一个给定的通道可以被注册到多个选择器上//选择器对象是线程安全的public abstract class Selector {  //打开选择器  public static Selector open( ) throws IOException  //选择器是否打开  public abstract boolean isOpen( );  //关闭选择器  public abstract void close( ) throws IOException;  //返回创建此通道的提供程序  public abstract SelectionProvider provider( );  //阻塞: 选择一组其相应通道准备好进行的I/O操作的键  public abstract int select( ) throws IOException;  //阻塞:  public abstract int select (long timeout) throws IOException;  //非阻塞: 立即返回  public abstract int selectNow( ) throws IOException;  //结束阻塞的select方法立即返回  public abstract void wakeup( );  //返回此选择器的键集  public abstract Set keys( );  //返回此选择器的选择键集,需要从键集手动移除(键集不是线程安全的)  public abstract Set selectedKeys( );}</code></pre></li><li><strong>可选择通道(SelectableChannel):</strong> 这个抽象类提供了实现通道的可选择性所需要的公共方法,它是所有支持就绪检查的通道类的父类.FileChannel对象不是可选择的(没有继承),所有socket通道都是可选择的,包括从管道(Pipe)对象中获得的通道.SelectableChannel可以被注册到Selector对象上,同时可以指定选择器的操作,一个通道可以被注册到多个选择器上,但对每个选择器而言只能被注册一次.<pre><code>public abstract class SelectableChannel extends AbstractChannel implements Channel {  //部分API列表  //将通道注册到给定选择器上,并规定操作,返回一个选择键(必须为非阻塞通道,同时一旦被注册,就不能回到阻塞状态)  public abstract SelectionKey register (Selector sel, int ops) throws ClosedChannelException;  //att设置附加对象到选择键中  public abstract SelectionKey register (Selector sel, int ops,Object att) throws ClosedChannelException;  //检查通道是否已经被注册到选择器上  public abstract boolean isRegistered( );  //返回与该通道指定的选择键  public abstract SelectionKey keyFor (Selector sel);  //获取通道所支持的操作集合  public abstract int validOps( );  //在通道被注册到一个选择器上时必须先设置通道为非阻塞模式: configureBlocking(false)  public abstract void configureBlocking (boolean block) throws IOException;  //是否为阻塞模式  public abstract boolean isBlocking( );  //获取阻塞模式的锁对象  public abstract Object blockingLock( );}</code></pre></li><li><strong>选择键(SelectionKey):</strong> 选择键封装了特定的通道与特定的选择器的注册关系.选择键对象被SelectableChannle.register()返回并提供一个表示这种注册关系的标记.选择键包含了两个比特集(以整数的形式进行编码),指示了该注册关系所关心的通道操作,以及通道已经准备好的操作<pre><code>public abstract class SelectionKey {  public static final int OP_READ     //读操作  public static final int OP_WRITE    //写操作  public static final int OP_CONNECT  //连接操作,Client端支持的一种操作  public static final int OP_ACCEPT   //连接可接受操作,仅ServerSocketChannel支持  //返回此选择键所关联的通道  public abstract SelectableChannel channel( );  //返回此选择键所关联的选择器  public abstract Selector selector( );  //取消选择键注册,取消的键不会立即从selector中移除,而是添加到cancelledKeys中  //在下一次select操作中移除它,所以在调用某个选择键时需要使用isValid校验  public abstract void cancel( );  //检查此选择键是否有效  public abstract boolean isValid( );  //获得此选择键的感兴趣操作集  public abstract int interestOps( );  public abstract void interestOps (int ops);  //获取此选择键的准备好的操作集  public abstract int readyOps( );  //检测此选择键是否可读操作  public final boolean isReadable( )  //检测此选择键是否可写操作  public final boolean isWritable( )  //检测此选择键关联的通道是否完成套接字连接操作  public final boolean isConnectable( )  //检测此选择键关联的通道是否已经准备好接受新的套接字链接操作  public final boolean isAcceptable( )  //将给定附件对象注册到此选择键上  public final Object attach (Object ob)  //获取此选择键上注册的附件对象  public final Object attachment( )}</code></pre></li></ul></li><li><p><strong>异步关闭能力</strong></p><ul><li>任何时候都有可能关闭一个通道或者取消一个选择键,除非采取步骤进行同步,否则键的状态及相关的通道将发生意料之外的改变</li></ul></li><li><p><strong>多线程</strong></p><ul><li>如果想要使用更多的线程为通道提供服务,多个选择器不是好的选择,更好的策略是对所有选择通道使用一个选择器,并将对就绪通道的服务委托给其他线程</li><li>对于某些通道要求比其他通道更高的响应速度,可以通过使用两个选择器来解决:一个为命令链接服务,另一个为普通链接服务</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO-通道</title>
      <link href="/2019/09/12/Channnel/"/>
      <url>/2019/09/12/Channnel/</url>
      
        <content type="html"><![CDATA[<h4 id="通道基础"><a href="#通道基础" class="headerlink" title="通道基础"></a>通道基础</h4><ol><li><p><strong>基本</strong></p><ul><li>顶层的Channel接口,只有两个操作: 检查一个通道是否打开(isOpen())和关闭一个打开的通道(close())<pre><code>public interface Channel{  public boolean isOpen();//通道是否开启  public void close() throws IOException;//关闭打开的通道}</code></pre></li><li>通道是访问I/O服务的导管,I/O可以分为广义的两大类:File I/O与Stream I/O,相应的有两种类型的通道与之对应,FileChannel类和socket通道类:SocketChannel丶ServerSocketChannel丶DatagramChannel(UDP)</li></ul></li><li><p><strong>打开通道</strong></p><pre><code> //socket通道可以直接使用其工厂方法open()打开 SocketChannel sc = SocketChannel.open(); sc.connect (new InetSocketAddress ("somehost", someport)); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind (new InetSocketAddress (somelocalport)); DatagramChannel dc = DatagramChannel.open(); //FileChannel只能通过RandomAccessFile丶FileInputStream丶FileOutputStream获取 RandomAccessFile raf = new RandomAccessFile ("somefile", "r"); FileChannel fc = raf.getChannel( ); //Channels工厂类  Channels.newChannel(System.in);</code></pre></li><li><p><strong>使用通道</strong></p><ul><li>通道可以是单向的(unidirectional)或者双向的(bidirectional),一个类实现ReadableByteChannel接口或者WritableByteChannel接口其中一个则为单向,全部实现则为双向(可以双向传输数据),</li><li>对于file文件可以在不同的时候以不同的权限打开,FileInputStream对象总是以read-only的权限打开文件,<strong>因此此对象的getChannel()方法虽然实现了两个接口,但是却是只读的</strong>,如果进行write()操作就会抛出异常</li><li>ByteChannel的read()与write()方法使用ByteBuffer对象作为参数,两种方法均返回已传输的字节数,如果缓冲区没有满,则可重新提交给通道从上次中断的地方继续传输,直到缓冲区hasRemaining()方法返回false</li><li>通道可以以阻塞(blocking)或非阻塞(nonblocking)模式运行,非阻塞模式的通道不会让调用线程休眠,请求的操作要么立即完成,要么返回一个未进行任何操作的结果,只有面向流的通道,如sockets和pipes才能使用非阻塞模式<pre><code>//读取接口public interface ReadableByteChannel extends Channel{  public int read (ByteBuffer dst) throws IOException;}//写入接口public interface WritableByteChannel extends Channel{  public int write (ByteBuffer src) throws IOException;}</code></pre></li></ul></li><li><p><strong>关闭通道</strong></p><ul><li>通道不能被重复使用,当通道关闭时,与特定I/O服务的特定连接就会丢失,然后通道将不再连接任何东西</li><li>调用通道的close()方法时,可能会导致在关闭底层I/O服务的过程中线程暂时阻塞(Socket通道关闭花费时间较长),哪怕该通道是非阻塞模式,多线程同时close()时,第一个阻塞,后面会跟着阻塞,直到已关闭,再调用close()不会产生任何操作</li><li>isOpen()方法检测通道的开放状态</li><li>通道引入了一些与关闭和中断有关的新行为,对于一个实现了InterruptibleChannel接口的通道,<strong>如果一个线程在该通道上被阻塞同时被中断,那么该通道将被关闭,被阻塞线程会产生ClosedByInterruptException异常</strong></li><li><strong>一个被设置中断状态(interrupt status)的线程试图访问一个通道时,那么这个通道将立即被关闭,同时抛出ClosedByInterruptException异常</strong></li><li>可中断的通道是可以异步关闭的,当一个通道被关闭时,休眠在该通道上的所有线程都将被唤醒并受到一个AsynchronousCloseException异常,接着通道就被关闭将不再可用</li></ul></li><li><p><strong>Scatter/Gather(分散/聚集)</strong></p><ul><li>Scatter/Gather是一个简单却强大的概念,对于read(ByteBuffer [] dsts),从通道中读取的数据会按顺序分散(scatter)到多个缓冲区;对于write(ByteBuffer [] dsts),多个缓冲区中的数据会按顺序进入通道(gather)<pre><code>public interface ScatteringByteChannel extends ReadableByteChannel{  //scatter: 从通道中读取的数据按顺序放入多个缓冲区中  public long read (ByteBuffer [] dsts)throws IOException;  //offset为数组索引,指明从哪个缓冲区开始,length为要使用的缓冲区数量  public long read (ByteBuffer [] dsts, int offset, int length)throws IOException;}public interface GatheringByteChannel extends WritableByteChannel{  //gather: 多个缓冲区中的数据按顺序进入通道中  public long write(ByteBuffer[] srcs)throws IOException;  public long write(ByteBuffer[] srcs, int offset, int length) throws IOException;}</code></pre></li></ul></li></ol><h4 id="文件通道"><a href="#文件通道" class="headerlink" title="文件通道"></a>文件通道</h4><ol><li><p><strong>基本</strong></p><ul><li><p>文件通道总是阻塞式的,FileChannel实例只能通过一个打开的file对象(RandomAccessFile丶FileInputStream丶FileOutputStream)上调用getChannel()方法获取,获取到的对象与file对象访问权限相同</p></li><li><p>FileChannel对象是线程安全的,多个进程可以在同一个实例上并发调用方法而不会引起任何问题,但是有些文件操作是单线程的,会阻塞其他线程</p><pre><code>public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {  //...部分方法列表  //从通道的position位置读取字节序列放入dst缓冲区  public abstract int read (ByteBuffer dst, long position)  //从给定缓冲区向通道从position位置写入字节序列  public abstract int write (ByteBuffer src, long position)  public abstract long size()//返回此通道文件的当前大小字节  public abstract long position()//返回此通道的文件位置  public abstract void position (long newPosition)//设置此通道的文件位置  public abstract void truncate (long size)//截断: 将此通道文件截断为指定大小  //参数metadata表示在方法返回值前文件的元数据(metadate)是否也要同步更新到磁盘  public abstract void force (boolean metaData)//强制文件的所有待定修改立即同步到磁盘  public final FileLock lock()//获取此通道文件的排它锁  //获取此通道给定区域的锁定,position:锁定区域起始位置,size:锁的区域大小,shared:true=共享锁,false=独占锁  //获取共享锁时必须以只读的权限打开,获取独占锁时则需要写的权限  public abstract FileLock lock (long position, long size, boolean shared)  public final FileLock tryLock()//尝试获取此通道文件的排它锁,会立即返回结果(成功或者失败)  //尝试获取此通道给定区域的排它锁  public abstract FileLock tryLock (long position, long size, boolean shared)  //将此通道文件的指定区域直接映射到内存中,position:起始位置,size大小  public abstract MappedByteBuffer map (MapMode mode, long position, long size)  public static class MapMode {      public static final MapMode READ_ONLY   //只读映射模式      public static final MapMode READ_WRITE  //读/写映射模式      public static final MapMode PRIVATE     //私有(写时复制)映射模式  }  //将该通道文件直接传输到给定的可写字节通道,position:起始位置,count:传输最大字节数,target:目标通道  public abstract long transferTo (long position, long count, WritableByteChannel target)  //从给定的可读字节通道将字节传输到当前通道中,src:源通道,position:起始位置,count:要传输的最大自己数  public abstract long transferFrom (ReadableByteChannel src, long position, long count)}</code></pre></li></ul></li><li><p><strong>访问文件</strong></p><ul><li>每个FileChannel都有一个”file position”的概念,这个position值决定文件中从哪一处的数据接下来将被读或写</li><li>truncate()方法会砍掉你所指定的新size值之外的所有数据,同时position会被设置为新size值,因此无论传入size大于或者小于原始大小都会产生副作用</li><li>对于position (long newPosition)方法设置通道的position值,如果设置负值会抛异常,如果设置的值超出文件尾,那么再使用read()方法时会返回一个文件尾,使用write()方法会引起文件增长以容纳写入的字节,并可能出现文件空洞(<strong>文件尾到写入的位置position之间的空间被称为文件空洞</strong>)</li><li><strong>文件空洞</strong>并不占据磁盘空间,直到后续真正写入数据才存入磁盘,在此之前,文件系统会将其解释为0的子串,所以建立文件空洞时速度非常快,没有磁盘I/O</li><li><strong>文件空洞</strong>虽然没有占用磁盘空间,但是文件系统会扣减程序可用磁盘空间数值大小,做到预留,因此基于文件系统的程序会看到文件空洞占据磁盘空间的表象</li><li><strong>文件空洞</strong>可以预先空间占用,如下载10G的内容需要1小时,使用文件空洞占用10G大小,其他程序将无法在此期间使用该空间</li></ul></li><li><p><strong>文件锁定</strong></p><pre><code> public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {     //...other     public final FileLock lock()//获取此通道文件的排它锁     //获取此通道给定区域的锁定,position:锁定区域起始位置,size:锁的区域大小,shared:true=共享锁,false=独占锁     //获取共享锁时必须以只读的权限打开,获取独占锁时则需要写的权限     public abstract FileLock lock (long position, long size, boolean shared)     public final FileLock tryLock()//尝试获取此通道文件的排它锁,会立即返回结果(成功或者失败)     //尝试获取此通道给定区域的排它锁     public abstract FileLock tryLock (long position, long size, boolean shared) }</code></pre><ul><li>文件锁与文件关联,而不是与通道关联,锁的是外部进程,而不是同一个Java虚拟机上的线程</li><li>锁定区域的范围不一定限制在文件的size以内,可以超出文件尾,因此,我们可以提前把待写入数据的区域锁定,我们也可以锁定一个不包含任何文件内容的区域,以备后续增长需要,相反如果锁定了文件的某块区域,然后文件增长超出了那块区域,那么新增加的文件内容将不受到锁保护<pre><code>//文件锁APIpublic abstract class FileLock {  public final FileChannel channel()//锁是由哪个锁创建的  public final long position()//锁定文件的起始位置  public final long size()//锁定文件的大小  public final boolean isShared()//是否为共享锁  public final boolean overlaps (long position, long size)//锁是否与给定范围重叠  public abstract boolean isValid();//锁是否有效  public abstract void release( ) throws IOException;//释放锁}</code></pre></li></ul></li><li><p><strong>内存映射文件</strong></p><ul><li>FileChannel上调用map()方法会创建一个由磁盘文件支持的虚拟内存映射,并在那块虚拟内存空间外部封装一个MappedByteBuffer对象</li><li>MappedByteBuffer对象的行为大体类似一个基于内存的缓冲区,只不过该对象的数据元素存储在磁盘上的 一个文件中(文件数据会缓存到内存中)</li><li>get()方法从磁盘文件中获取数据,put()方法会更新磁盘上的文件,并且做出的修改对于该文件的其他阅读者可见</li><li>内存映射机制来访问一个文件会比常规方法读写高效得多,甚至比使用通道的效率都高</li><li>MapMode.PRIVATE表示写时复制模式,通过put()方法所做的修改会导致产生一个私有的数据拷贝并且该拷贝中的数据只有MappedByteBuffer实例可以看到,该过程不会对底层文件做任何修改,一旦缓冲区被施以垃圾回收,那么修改就会丢失,必须以read/wirte权限打开文件才能建立MapMode.PRIVATE映射</li><li>MapMode.PRIVATE模式并不会导致你的缓冲区看不到通过其他方式对文件所做的修改,对文件某个区域的修改再使用MapMode.PRIVATE模式的缓冲区中都能反映出来,除非该缓冲区已经修改了文件上的同一个区域</li><li>MappedByteBuffer对象一旦建立之后就保持有效,直到被垃圾收集为止,没有绑定在创建他们的通道上,关闭相关联的FileChannel不会破坏映射(易导致文件被占用无法及时释放)</li><li>MemoryMappedBuffer直接反映它所关联的磁盘文件,如果映射有效时文件被在结构上(大小)修改,那么缓冲区部分可能无法访问,并抛出未检查异常<pre><code>//MappedByteBuffer创建public abstract class FileChannel extends AbstractChannel implements ByteChannel, GatheringByteChannel, ScatteringByteChannel {  // other  //将此通道文件的指定区域直接映射到内存中,position:起始位置,size大小  public abstract MappedByteBuffer map (MapMode mode, long position,long size)  public static class MapMode {      public static final MapMode READ_ONLY //只读映射模式      public static final MapMode READ_WRITE //读/写映射模式      public static final MapMode PRIVATE    //私有(写时复制)映射模式  }}</code></pre></li><li>当为一个文件建立虚拟内存映射之后,文件数据通常不会因此被从磁盘读取到内存,对于映射缓冲区,虚拟内存系统将根据需要来把文件中相应区块的数据读进来,这个过程是需要时间的,因此可以使用load()提前加载</li><li>load()方法会加载整个文件以使它常驻内存,这样后续的操作基于内存,访问速度将更高</li><li>但是load()方法是一个代价高的操作,因为它会导致大量的页调入,load()方法返回并不能保证文件就会完全常驻内存,由于请求页面调入是动态的,该方法主要作用是提前加载文件进入内存,以便后续的访问速度尽可能快</li><li>对于大多数程序,提前加载文件消耗资源是不划算的,在实际访问时分摊页调入开销才是更好的选择</li><li>应该总是使用MappedByteBuffer.force()而非FileChannel.force()方法,因为通道对象可能不清楚通过映射缓冲区做出的文件的全部更改<pre><code>public abstract class MappedByteBuffer extends ByteBuffer {  // other  //MappedByteBuffer特别的方法  public final MappedByteBuffer load()//加载整个文件使他常驻内存(相当于提前加载)  public final boolean isLoaded()//判断被映射的文件是否常驻内存了(不绝对,只是一个暗示)  //应使用MappedByteBuffer的force()方法,而非FileChannel的force()方法,  //因为通道对象可能不清楚通过映射缓冲区做出的全部更改  public final MappedByteBuffer force()//强制将缓冲区更改反映到磁盘上}</code></pre></li></ul></li><li><p><strong>Channel-to-Channel传输</strong></p><ul><li>从一个位置将文件数据批量传输到另一个位置,FileChannel类添加了一些优化方法来提高传输过程的效率</li><li>transferTo()和transferFrom()方法允许将一个通道交叉连接到另一个通道,而不需要通过一个中间缓冲区来传递数据,只有FileChannel类有这两个方法</li><li>直接的通道传输不会更新与某个FileChannel关联的position值,会从position位置开始,传输的字节数不超过count参数值,实际传输的字节数会有方法返回</li><li>对于transferTo()方法,如果position+count的值大于文件的size值,传输会在文件尾的位置终止;类似的,对于transferFrom()方法: 如果来源src是另一个FileChannel并且已经到达文件尾,那么传输将提前终止</li><li>Channel-to-Channel传输是可以极其快速的,特别是在底层操作系统提供本地支持的时候,对于大量的数据传输,会是一个巨大的帮助</li></ul></li></ol><h4 id="Socket通道"><a href="#Socket通道" class="headerlink" title="Socket通道"></a>Socket通道</h4><ol><li><p><strong>基本</strong></p><ul><li>全部的socket通道类(DatagramChannel丶SocketChannel和ServerSocketChannel)在被实例化时都会创建一个对等socket对象(java.net类中的Socket丶ServerSocket丶DatagramSocket,它们已经被更新以识别通道),对等的socket可以通过调用socket()方法从一个通道上获取,此外这三个java.net类现在都有getChannel()方法</li><li>虽然每个socket通道(java.nio.channel包中)都有一个关联的java.net.socket对象,却并非所有的socket都有一个关联的通道,如果使用传统方式(直接实例化)创建了一个Socket对象,它就不会有关联的SocketChannel并且它的getChannel()方法将总是返回null</li><li>方法<pre><code>public abstract class SelectableChannel extends AbstractChannel implements Channel {  // 部分API列表  //设置通道的阻塞模式:阻塞/非阻塞  public abstract void configureBlocking (boolean block) throws IOException;  public abstract boolean isBlocking( ); //判断通道是那种阻塞模式  //防止其他对象修改阻塞模式,只有拥有该对象锁的线程才能修改阻塞模式  public abstract Object blockingLock( );}</code></pre></li></ul></li><li><p><strong>ServerSocketChannel</strong></p><ul><li>完整API<pre><code>public abstract class ServerSocketChannel extends AbstractSelectableChannel {  /**   *工厂方法创建一个新的ServerSocketChannel对象,   *返回同一个未绑定的java.net.ServerSocket关联的通道   *该对等ServerSocket可以通过ServerSocketChannel对象调用socket()获取   *通过对等的socket的bind()方法绑定到一个端口开始监听   **/  public static ServerSocketChannel open( ) throws IOException  //返回对等的Socket对象  public abstract ServerSocket socket( );  //返回的对象可以在非阻塞模式下运行,非阻塞模式下调用,没有传入链接在等待时,会立即返回null  public abstract ServerSocket accept( ) throws IOException;  //返回此频道支持操作的操作集  public final int validOps( )}</code></pre></li></ul></li><li><p><strong>SocketChannel</strong></p><ul><li>API<pre><code>  public abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel {  //部分API列表  //打开链接通道  public static SocketChannel open( ) throws IOException  //打开链接通道并链接到远程地址(相当于open()+connect(remote))  public static SocketChannel open (InetSocketAddress remote) throws IOException  //获取与此通道对等的Socket  public abstract Socket socket( );  //将此通道链接到远程地址  public abstract boolean connect (SocketAddress remote) throws IOException;  //判断是否正在进行链接操作  public abstract boolean isConnectionPending( );  //判断是否完成链接操作  public abstract boolean finishConnect( ) throws IOException;  //判断是否已经完成链接  public abstract boolean isConnected( );  //确定支持的操作的操作集  public final int validOps( )}</code></pre></li><li>Socket通道是线程安全的,但是任何时候都只有一个读操作和一个写操作在进行中,sockets是面向流而非包导向的,他们可以保证发送的字节会按照顺序到达但无法承诺维持字节分组,例如某个发送器可能给一个socket写入20字节而接收器调用read()方法却只收到了其中3个字节,剩下的17个字节还在传输中,因此让多个不配合的线程共享某个流socket的同一侧绝非一个好的涉及选择</li><li>connect()和finishConnect()方法是互相同步的,并且只要其中一个操作正在进行,任何读或写方法调用都会阻塞,即使是在非阻塞模式下</li></ul></li><li><p><strong>DatagramSocket</strong></p><ul><li>API<pre><code>public abstract class DatagramChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel {  //部分方法列表  //打开数据通道  public static DatagramChannel open( ) throws IOException  //获取与通道等价的socket  public abstract DatagramSocket socket( );  //指定链接到的地址,除了此地址之外任何其他源地址的数据包都会被忽略  public abstract DatagramChannel connect (SocketAddress remote) throws IOException;  //判断是否指定连接地址  public abstract boolean isConnected( );  //取消指定的连接地址  public abstract DatagramChannel disconnect( ) throws IOException;  //接收数据放入ByteBuffer中,非阻塞模式没有可接受包时会返回null,  //包内数据超出byteBuffer范围则会被悄悄丢弃  public abstract SocketAddress receive (ByteBuffer dst) throws IOException;  //发送数据包,非阻塞模式返回发送字节数或者0,  //发送数据包是一个全有全无的行为,如果超出数据包承载能力,就什么都不发送  public abstract int send (ByteBuffer src, SocketAddress target)  //返回读取字节的数量,非阻塞模式返回值可能为0      public abstract int read (ByteBuffer dst) throws IOException;  public abstract int write (ByteBuffer src) throws IOException;}</code></pre></li><li>DatagramChannel(数据包通道UDP)不同与流socket(TCP/IP),流socket具有有序而可靠的数据传输特性,但是该协议为了在包导向的互联网基础设施上维护流的语义必然会产生巨大的开销,并且流语义不能适用所有情形,数据包的吞吐量要比流协议高很多</li></ul></li></ol><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ol><li><strong>基本</strong><ul><li>API<pre><code>public abstract class Pipe {  //打开管道  public static Pipe open( ) throws IOException  //返回此通道的源通道      public abstract SourceChannel source( );  //返回此通道的接收通道  public abstract SinkChannel sink( );  //Pipe可写端的通道  public static abstract class SourceChannel extends AbstractSelectableChannel implements ReadableByteChannel, ScatteringByteChannel  //Pipe可读端的通道  public static abstract class SinkChannel extends AbstractSelectableChannel implements WritableByteChannel, GatheringByteChannel}</code></pre></li><li>Pipe实例是通过调用不带参数的Pipe.open()工厂方法来创建的,Pipe类定义了两个嵌套的通道类来实现管路,Pipe.SourceChannel(管道负责读的一端)和Pipe.SinkChannel(管道负责写的一端),这两个通道实例是在Pipe对象创建的同时被创建的,可以通过在Pipe对象上分别调用source()与sink()方法来获取</li><li>管道所能承载的数据量是依赖实现的,唯一可保证的是写到SinkChannel中的字节都能按照同样的顺序在SourceChannel上重现</li></ul></li></ol><h4 id="通道工具类"><a href="#通道工具类" class="headerlink" title="通道工具类"></a>通道工具类</h4><ul><li>API<pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Channels</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//返回一个将从给定的通道读取字节的流</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> InputStream <span class="token function">newInputStream</span><span class="token punctuation">(</span>ReadableByteChannel ch<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//返回一个将给定的通道写入字节的流</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> OutputStream <span class="token function">newOutputStream</span><span class="token punctuation">(</span><span class="token keyword">final</span> WritableByteChannel ch<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//返回一个给定的输入流读取数据的通道</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> ReadableByteChannel <span class="token function">newChannel</span><span class="token punctuation">(</span><span class="token keyword">final</span> InputStream in<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//返回一个将向给定的输出流写入数据的通道</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> WritableByteChannel <span class="token function">newChannel</span><span class="token punctuation">(</span><span class="token keyword">final</span> OutputStream out<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//返回一个reader,它将从给定的通道读取字节并依据提供的CharsetDecoder对读取的字节进行解码</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Reader <span class="token function">newReader</span><span class="token punctuation">(</span>ReadableByteChannel ch<span class="token punctuation">,</span> CharsetDecoder dec<span class="token punctuation">,</span> <span class="token keyword">int</span> minBufferCap<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//返回一个reader,它将从给定的通道读取字节并依据提供的字符集名称将读取到的字节解码为字符</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Reader <span class="token function">newReader</span><span class="token punctuation">(</span>ReadableByteChannel ch<span class="token punctuation">,</span> String csName<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//返回一个writer,它将使用提供的CharsetEncoder对象对字符编码并写到给定的通道中</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Writer <span class="token function">newWriter</span><span class="token punctuation">(</span><span class="token keyword">final</span> WritableByteChannel ch<span class="token punctuation">,</span> <span class="token keyword">final</span> CharsetEncoder enc<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> minBufferCap<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//返回一个writer,它将依据提供的字符集名称对字符编码并写到给定的通道中</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Writer <span class="token function">newWriter</span><span class="token punctuation">(</span>WritableByteChannel ch<span class="token punctuation">,</span> String csName<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO-缓冲区</title>
      <link href="/2019/09/10/Buffers/"/>
      <url>/2019/09/10/Buffers/</url>
      
        <content type="html"><![CDATA[<h4 id="缓冲区基础"><a href="#缓冲区基础" class="headerlink" title="缓冲区基础"></a>缓冲区基础</h4><blockquote><p>缓冲区是对基本数据元素数组的封装对象,Buffer类及其专有的子类提供了用于处理数据缓冲区的API</p></blockquote><blockquote><p>缓冲区不是多线程安全的,多线程同时存取时,需要同步</p></blockquote><ol><li><p><strong>属性</strong></p><ul><li>Capacity(容量): 缓冲区大小,创建时设定,不能更改</li><li>Limit(上界): 缓冲区现存元素数量</li><li>Position(位置): 下一个要被读或写的元素索引,位置会自动由相应的get()和put()函数更新</li><li>Mark(标记): 一个备忘位置,调用mark()来设定mark=position,调用reset()设定position=mark</li><li>关系: 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</li></ul></li><li><p><strong>缓冲区API</strong></p><pre><code> public abstract class Buffer {     public final int capacity()//容量     public final int position()//返回下一个将要被读写的元素索引     public final Buffer position (int newPosition)//设置下一个被读写元素的索引     public final int limit()//返回缓冲区上界     public final Buffer limit (int newLimit)//设置缓冲区上界     public final Buffer mark()//设置标记mark=position     public final Buffer reset()//重置读写位置position=mark     public final Buffer clear()//重置为0,即limit=capacity,position=0     public final Buffer flip()//翻转,将添加元素状态翻转成读取元素状态(相当于limit = position,然后position = 0然后开始读取写入的元素)     public final Buffer rewind()//position=0,mark=-1     public final int remaining()//返回剩余可读元素数量,当前位置到上界还剩余的元素数量     public final boolean hasRemaining()//是否有剩余可读元素,即是否到达上界(limit)     public abstract boolean isReadOnly();//是否只读 }</code></pre></li><li><p><strong>存取</strong></p><pre><code> public abstract class ByteBuffer extends Buffer implements Comparable{     public abstract byte get();//取position位置     public abstract byte get (int index);//取index位置     public abstract ByteBuffer put (byte b);//存position位置开始     public abstract ByteBuffer put (int index, byte b);//存index位置开始     //...批量存取 }</code></pre></li><li><p><strong>翻转</strong></p><ul><li>filp() : 翻转,将继续添加元素状态翻转成一个准备读取元素状态</li><li>如果已经写入缓冲区,此时想要读取缓冲区内容,我们需将limit设置为当前位置position,然后将position重置为0,此时使用get()即可读取<strong>等价于: buffer.limit(buffer.position()).position(0)</strong></li><li>缓冲区翻转两次,实际可读取大小会变成0(limit=0,position=0)</li></ul></li><li><p><strong>释放</strong></p><ul><li>clear()将缓冲区重置为0,仅仅是limit = capacity,position=0,没有改变缓冲区内的任何数据元素</li></ul></li><li><p><strong>压缩/比较</strong></p><pre><code> public abstract class ByteBuffer extends Buffer implements Comparable{     public abstract ByteBuffer compact();//将未读元素移动到数组首     public boolean equals (Object ob)//比较每个缓冲区剩余的内容是否相同(对象类型必须相同)     public int compareTo (Object ob)//以字典顺序比较,可以比较大小 }</code></pre></li><li><p><strong>创建缓冲区</strong></p><ul><li><p>CharBuffer,IntBuffer,DoubleBuffer,ShortBuffer,LongBuffer,FloatBuffer,ByteBuffer七种缓冲区创建方式相同,(MappedByteBuffer特殊)</p><pre><code>//以CharBuffer为例public abstract class CharBuffer extends Buffer implements CharSequence, Comparable{  public static CharBuffer allocate (int capacity)//分配一个固定容量的缓冲区  public static CharBuffer wrap (char [] array)//使用自定义的数组作为缓冲区  public static CharBuffer wrap (char [] array, int offset,int length)//使用自定义数组作为缓冲区,并设置初始化位置(position)和长度(limit-position)  public final boolean hasArray()//是否存在底层数组(allocate或wrap()创建的间接缓冲区底层都是数组)  public final char [] array()//获取缓冲区底层数组(hasArray()返回false时不要使用,会抛异常)  public final int arrayOffset()//返回缓冲区数据在数组中存储的开始位置偏移量  //特有的  public static CharBuffer wrap (CharSequence csq)//通过可读字符流创建缓冲区(实现Charsequence接口的类: String,StringBuffer等)  public static CharBuffer wrap (CharSequence csq, int start,int end) //通过字符流的子序列创建缓冲区}</code></pre></li></ul></li><li><p><strong>复制缓冲区</strong></p><pre><code> public abstract class CharBuffer extends Buffer implements CharSequence, Comparable{     //创建一个与原始缓冲区相似的新缓冲区,两个缓冲区共享数据元素,拥有同样容量,(相当于底层共用一个数组)     //但拥有各自的position,limit,mark属性,一个缓冲区改变会反映到另一个缓冲区上,会继承只读或直接缓冲区属性     public abstract CharBuffer duplicate();     public abstract CharBuffer asReadOnlyBuffer();//同duplicate,不同的是改缓冲区只读,不能使用put()     public abstract CharBuffer slice();     //分割缓冲区,从源缓冲区position位置开始到limit位置结束创建一个新缓冲区     //新缓冲区与原始缓冲区共享元素子序列,会继承只读和直接属性 }</code></pre><h4 id="字节缓冲区"><a href="#字节缓冲区" class="headerlink" title="字节缓冲区"></a>字节缓冲区</h4></li><li><p><strong>字节顺序:</strong></p><ul><li>BIG_ENDIAN(大端字节顺序: 数字<strong>高-&gt;低</strong>位,存储内存地址<strong>低-&gt;高</strong>) , LITTLE_ENDIAN(小端字节顺序,Intel处理器使用小端字节顺序)<pre><code>public final class ByteOrder{  public static final ByteOrder BIG_ENDIAN//大端字节顺序  public static final ByteOrder LITTLE_ENDIAN//小端字节顺序  public static ByteOrder nativeOrder()//获取本地字节顺序}</code></pre><pre><code>public abstract class ByteBuffer extends Buffer implements Comparable{  public final ByteOrder order()//查询字节顺序  public final ByteBuffer order (ByteOrder bo)//设置字节顺序}</code></pre></li></ul></li><li><p><strong>直接缓冲区</strong></p><ul><li>直接缓冲区被用于与通道和固有I/O例程交互,它们通过使用固有代码来告诉操作系统直接释放或填充内存区域<pre><code>public abstract class ByteBuffer extends Buffer implements Comparable{  public static ByteBuffer allocateDirect (int capacity)//分配直接字节缓冲区  public abstract boolean isDirect();//是否直接缓冲区,如果底层是基于直接字节缓冲区的包装(wrap)缓冲区则也是true}</code></pre></li></ul></li><li><p><strong>视图缓冲区</strong></p><ul><li>视图缓冲区对象维护了自己的属性丶容量丶位置丶上界和标记,但是和原来的缓冲区共享数据元素<pre><code>//基于ByteBuffer缓冲区创建其视图缓冲区public abstract class ByteBuffer extends Buffer implements Comparable{  public abstract CharBuffer asCharBuffer();  public abstract ShortBuffer asShortBuffer();  public abstract IntBuffer asIntBuffer();  public abstract LongBuffer asLongBuffer();  public abstract FloatBuffer asFloatBuffer();  public abstract DoubleBuffer asDoubleBuffer();}</code></pre></li></ul></li><li><p><strong>数据元素视图</strong></p><ul><li>ByteBuffer类提供了以多字节数据类型的形式存取byte数据组<pre><code>public abstract class ByteBuffer extends Buffer implements Comparable {  public abstract char getChar();  public abstract char getChar (int index);//从index位置开始取2字节char值  public abstract int getInt();//从position位置开始取4字节int值  public abstract int getInt (int index);  //...等等  public abstract ByteBuffer putFloat (float value);  public abstract ByteBuffer putFloat (int index, float value);  public abstract ByteBuffer putDouble (double value);  public abstract ByteBuffer putDouble (int index, double value);}</code></pre></li></ul></li><li><p><strong>内存映射缓冲区</strong></p><ul><li>映射缓冲区是通过内存映射来存取文件中的数据元素的字节缓冲区,映射缓冲区通常是直接存取内存的,只能通过FileChannel类创建,用法和直接缓冲区类似,但是MappedByteBuffer对象可以处理独立与文件存取形式的许多特定字符</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-原子变量与非阻塞同步机制</title>
      <link href="/2019/09/06/AtomicVariablesandNonblockingSynchronization/"/>
      <url>/2019/09/06/AtomicVariablesandNonblockingSynchronization/</url>
      
        <content type="html"><![CDATA[<h4 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h4><ol><li><p><strong>CAS操作</strong></p><ul><li>CAS(比较并交换)包含三个操作,需要读写的内存位置V丶进行比较的值A和拟写入的新值B.当且仅当V的值等于A时,CAS才会通过原子方式用新值B来更新V的值,否则不会执行任何操作,无论位置V的值是否等于A,都将返回V原有的值,(比较并设置,无论操作成功都会返回)</li><li>CAS使用一项乐观的技术,它希望能成功的执行更新操作,当多个线程尝试使用CAS同时更新一个变量时,只有其中一个线程能更新成功,其他线程都会失败,但是失败的线程不会被挂机,而是被告知在这次竞争中失败,并可再次尝试(可以决定是否重新尝试:自旋丶终止)</li><li>基于CAS可以实现原子操作,通常情况下比使用锁效率高(多线程高度竞争的情况下,锁的性能将超过原子变量的性能)</li></ul></li><li><p><strong>原子变量类型</strong></p><ul><li><p>原子变量比锁的粒度更细,将发生竞争的范围缩小到单个变量上</p><pre><code>计数器: AtomicInteger AtomicLong AtomicBoolean AtomicReference域更新器: AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater数组: AtomicIntegerArray AtomicLongArray AtomicReferenceArray复合变量: AtomicMarkableReference AtomicStampedReference</code></pre></li><li><p>原子引用(AtomicReference),底层采用compareAndSwapObject实现CAS,比较的是两个对象地址是否相等,仅保证修改对象引用的原子性</p><pre><code>@Testpublic void ReferenceTest(){  People p1 = new People("Tom");  People p2 = new People("Jerry");  //原子引用  AtomicReference&lt;People&gt; reference = new AtomicReference&lt;&gt;(p1);  p1.name = "Tom1";  System.out.println(reference.get().name); //Tom1  reference.compareAndSet(p1,p2);//原子的更新引用: 将reference引用由p1变为p2  System.out.println(reference.get().name); //Jerry}</code></pre></li><li><p>操作非原子变量的字段属性,XXXFieldUpdater是基于反射的工具类,它能对指定类的指定volatile引用字段进行原子更新(这个字段不能是private的)</p><pre><code>@Testpublic void atomicTest(){  AtomicReferenceFieldUpdater&lt;People,String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(People.class,String.class,"name");  People p = new People();  //原子更新操作  updater.compareAndSet(p,p.name,"Tom");  System.out.println(p.name);//Tom}class People{  //要更新的非原子变量(必须volatile修饰)  volatile String name;}</code></pre></li><li><p>复合变量: 解决CAS操作的ABA问题,<strong>AtomicStampedReference</strong>内部额外增加int类型时间戳(一般自增)记录变量的修改次数,可以知道引用变量中途被修改了几次;<strong>AtomicMarkableReference</strong>内部使用的是boolean变量,用来表示变量是否被修改过,适用于单纯的关心是否被更改过,不关系更新次数</p></li></ul></li></ol><h4 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h4><blockquote><p><strong>非阻塞算法:</strong> 如果在某种算法中,一个线程的失败或者挂起不会导致其他线程也失败或挂起,那么这种算法就是非阻塞算法</p></blockquote><blockquote><p><strong>无锁(Lock-Free)算法:</strong> 如果算法的每个步骤中都存在某个线程能够执行下去,那么这种算法也被称为无锁算法</p></blockquote><blockquote><p>如果算法中仅将CAS用于协调线程之间的操作,并能正确地实现,那么它既是一种无阻塞算法,又是一种无锁算法</p></blockquote><ol><li><p><strong>非阻塞的栈</strong></p><pre><code>//非阻塞的链式栈public class ConcurrentStack&lt;E&gt; { private AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;&gt;(); //非static的内部类对象会隐式的在外部类中保存一个引用,指向创建它的外部类对象 private static class Node&lt;E&gt;{     public final E item;     public Node&lt;E&gt; next;     public Node(E item) {         this.item = item;     } } public void push(E item){     Node&lt;E&gt; newHead = new Node&lt;&gt;(item);     Node&lt;E&gt; oldHead;     do{         oldHead = top.get();         newHead.next = oldHead;     } while(!top.compareAndSet(oldHead,newHead));//自旋 } public E pop(){     Node&lt;E&gt; oldHead;     Node&lt;E&gt; newHead;     do{         oldHead = top.get();         if(oldHead == null) return null;         newHead = oldHead.next;     } while(!top.compareAndSet(oldHead,newHead));//自旋     return oldHead.item; }}</code></pre></li><li><p><strong>非阻塞链表</strong></p><pre><code>//非阻塞链表的插入算法public class LinkedQueue&lt;E&gt; { private static class Node&lt;E&gt;{     final E item;     final AtomicReference&lt;Node&lt;E&gt;&gt; next;     public Node(E item, AtomicReference&lt;Node&lt;E&gt;&gt; next) {         this.item = item;         this.next = next;     } } private final Node&lt;E&gt; dummy = new Node&lt;&gt;(null,null); private final AtomicReference&lt;Node&lt;E&gt;&gt; head = new AtomicReference&lt;&gt;(dummy); private final AtomicReference&lt;Node&lt;E&gt;&gt; tail = new AtomicReference&lt;&gt;(dummy); //插入: 先更新next,再更新tail,可能状态: 开始-&gt;中间状态(next完成)-&gt;结束(tail完成) public boolean put(E item){     Node&lt;E&gt; newNode = new Node&lt;&gt;(item,null);     while(true) {//自旋         Node&lt;E&gt; curTail = tail.get();//获取当前尾节点         Node&lt;E&gt; tailNext = curTail.next.get();         if (curTail == tail.get()) { //需要处理的状态: 开始状态(准备插入操作)丶中间状态(帮助完成)             if (tailNext != null) //有其他线程正在执行插入操作: 中间状态                 tail.compareAndSet(curTail, tailNext);//尝试帮助其他线程推进尾节点             else {//没有其他线程执行插入操作,尝试插入新节点: 开始状态                 if (curTail.next.compareAndSet(null, newNode)) {//1.尝试更新next                     //更新next成功,2.尝试推进尾节点(可能失败,其他线程帮助推进好了)                     tail.compareAndSet(curTail, newNode);                     return true;                 }//否则更新next失败,自旋重新尝试插入操作             }         }//否则: 结束状态,无需处理,重新尝试插入操作     } }}</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-构建自定义的同步工具</title>
      <link href="/2019/09/02/BuildingCustomSynchronizers/"/>
      <url>/2019/09/02/BuildingCustomSynchronizers/</url>
      
        <content type="html"><![CDATA[<h3 id="构建自定义的同步工具"><a href="#构建自定义的同步工具" class="headerlink" title="构建自定义的同步工具"></a>构建自定义的同步工具</h3><blockquote><p>现有类库不能提供足够的功能时,可以使用内置的条件队列丶显示的Condition对象或者AbstractQueuedSynchronizer来构建自己的同步器</p></blockquote><h4 id="内置的条件队列"><a href="#内置的条件队列" class="headerlink" title="内置的条件队列"></a>内置的条件队列</h4><blockquote><p>条件队列是指一组在等待某个条件变成真的线程,队列中元素是线程</p></blockquote><blockquote><p>条件队列是和锁相关联的,一个内置锁只能对应一个条件队列(有缺陷,显式锁可以对应多个),当需要获得内置锁时,并发的线程就会进入条件队列,Object的wait(),notify(),notifyAll()方法可以操作条件队列</p></blockquote><blockquote><ul><li>wait(): 让当前线程进入条件队列中等待</li><li>notify(): 从条件队列的线程中随机唤醒一个线程,并让它去参与锁的竞争</li><li>notifyAll(): 唤醒条件队列中所有等待的线程,让它们参与锁竞争</li></ul></blockquote><pre><code>//内置的条件队列实现可阻塞的put与take方法//阻塞并直到:not-full //可额外增加可中断策略public synchronized void put(V v){    while(isFull()) //使用while当唤醒重新获取锁后再进行一次判断        wait();    boolean wasEmpty = isEmpty();    doPut(v);   //插入操作    if(wasEmpty) notifyAll(); //唤醒}//阻塞并直到: not-emptypublic synchronized V take(){    while(isEmpty)        wait();    boolean wasFull = isFull();    V v = doTake(); //获取操作    if(wasFull) notifyAll();    //唤醒    return v;}</code></pre><h4 id="显式的Condition对象"><a href="#显式的Condition对象" class="headerlink" title="显式的Condition对象"></a>显式的Condition对象</h4><blockquote><p>内置条件队列存在一些缺陷,每个内置锁都只能有一个相关联的条件队列</p></blockquote><blockquote><p>一个显式锁可以对应多个Condition,一个Condition维护一个条件队列,这是一种更灵活的选择,对于公平的锁,线程会依照FIFO顺序从Condition.await中释放</p></blockquote><pre><code>    //显式的条件队列实现可阻塞的put与take方法    class ConditionBoundedBuffer&lt;T&gt;{        protected final Lock lock = new ReentrantLock();        //条件        private final Condition notFull = lock.newCondition();        private final Condition notEmpty = lock.newCondition();        //阻塞并直到: notFull        public void put(T t) throws InterruptedException {            lock.lock();            try{                while(isFull())                    notFull.await();                doPut(t);                notEmpty.signal();            } finally {                lock.unlock();            }        }        //阻塞并直到: notEmpty        public T take() throws InterruptedException {            lock.lock();            try {                while (isEmpty())                    notEmpty.await();                T t = doTake();                notFull.signal();                return t;            } finally {                lock.unlock();            }        }    }</code></pre><ul><li><strong>使用Lock实现信号量(Semaphore)</strong><pre><code>  //使用Lock实现Semaphore(信号量)  class SemaphoreOnLock{      private final Lock lock = new ReentrantLock();      private final Condition permitsAvailable = lock.newCondition();      private int permits;      public SemaphoreOnLock(int permits) {          lock.lock();          try{              this.permits = permits;          } finally {              lock.unlock();          }      }      //阻塞直到: permitsAvailable      public void acquire() throws InterruptedException {          lock.lock();          try{              while(permits &lt;= 0)                  permitsAvailable.await();              --permits;//获取后许可-1          } finally {              lock.unlock();          }      }      public void release(){          lock.lock();          try{              ++permits; //释放后许可+1              permitsAvailable.signal();//唤醒          } finally {              lock.unlock();          }      }  }</code></pre><h4 id="AbstractQueuedSynchronizer-AQS"><a href="#AbstractQueuedSynchronizer-AQS" class="headerlink" title="AbstractQueuedSynchronizer(AQS)"></a>AbstractQueuedSynchronizer(AQS)</h4><blockquote><p>AQS是一个用于构建锁和同步器的框架,许多同步器都可以通过AQS很容易并且高效的构造出来,如: ReentrantLock丶Semaphore丶CountDownLatch丶ReentrantReadWriteLock丶SynchronousQueue和FutureTask</p></blockquote></li></ul><ol><li><strong>AQS的域</strong><pre><code> private transient volatile Node head;//同步队列头结点 private transient volative Node tail; //同步队列尾节点 private volatile int state; //同步状态</code></pre><ul><li>域: 同步状态+同步队列</li><li>同步状态: 可以通过getState丶setState以及compareAndSetState等方法进行操作,可以用于表示任意状态,如ReentrantLock中表示重入获取锁的次数;Semaphore用它表示剩余的许可数量;FutureTask用它表示任务的状态</li><li>同步队列: 队列的节点(Node)中保存了获取同步状态失败的线程引用丶等待状态丶以及前驱和后继节点,是一个FIFO的双向队列</li></ul></li><li><strong>AQS的方法</strong><ul><li>修改同步状态的方法<pre><code>protected final int getState();//获取同步状态protected final void setState(int newState);//设置同步状态protected final boolean compareAndSetState(int expect,int update);//CAS设置同步状态</code></pre></li><li>独占式获取和释放同步状态<pre><code>public final void acquire(int arg) //独占式获取同步状态,如果不成功会进入同步队列等待public final void acquireInterruptibly(int arg) //与acquire不同的是,能响应中断public final boolean tryAcquireNanos(int arg, long nanosTimeout) //增加超时机制public final boolean release(int arg) //独占式释放同步状态,该方法会调用重写的tryRelease(int arg)</code></pre></li><li>共享式获取和释放同步状态<pre><code>public final void acquireShared(int arg) //共享式获取同步状态,如果不成功会进入同步队列等待.与独占式不同的是,同一时刻可以有多个线程获取到同步状态public final void acquireSharedInterruptibly(int arg) //可响应中断public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) //超时机制public final boolean releaseShared(int arg) //共享式释放同步状态,该方法会调用重写的tryReleaseShared(int arg)</code></pre></li><li>查询同步队列中的等待线程情况<pre><code>public final Collection&lt;Thread&gt; getQueuedThreads(); //返回包含可能正在等待获取的线程列表,是无序估计值public final boolean hasQueuedThreads();</code></pre></li><li>AQS提供的可重写方法(非final)<pre><code>protected boolean tryAcquire(int arg) //独占式获取同步状态,此方法应该查询是否允许它在独占模式下获取对象状态,如果允许,则获取它,true表示成功,false失败protected boolean tryRelease(int arg) //独占式释放同步状态protected int tryAcquireShared(int arg) //共享式获取同步状态,返回值语义:负数代表获取失败,0代表获取成功但没有剩余资源丶正数代表获取成功,还有剩余资源protected boolean tryReleaseShared(int arg) //共享式释放同步状态protected boolean isHeldExclusively() //AQS是否被当前线程所独占</code></pre></li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-显式锁</title>
      <link href="/2019/08/30/ExplicitLocks/"/>
      <url>/2019/08/30/ExplicitLocks/</url>
      
        <content type="html"><![CDATA[<h4 id="Lock与ReentrantLock"><a href="#Lock与ReentrantLock" class="headerlink" title="Lock与ReentrantLock"></a>Lock与ReentrantLock</h4><ol><li><strong>Lock接口</strong><ul><li>Lock提供了一种无条件的丶可轮询的丶可定时的以及可中断的锁获取操作,所有加锁和解锁的方法都是显式的<pre><code>public interface Lock{  void lock(); //阻塞的获取锁,知道获取到锁才返回且不可中断  void lockInterruptibly();//可中断的获取锁,在阻塞等待过程中可响应中断  boolean tryLock();//尝试非阻塞的获取锁,调用方法后立即返回,获取锁成功返回true,失败返回false  boolean tryLock(long timeout,TimeUnit unit);//限定了一个尝试获取锁的时间,在该时间内会尝试获取锁(成功true,失败false),超出时间后直接返回false  void unlock();//释放锁  Condition newCondition();//Condition对象:维护一个条件队列,await() singal()方法可以对其进行操作}</code></pre></li></ul></li><li><strong>ReentrantLock类</strong><ul><li>ReentrantLock类实现了Lock接口,并提供了与synchronized相同的互斥性和内存可见性,还提供了可重入的加锁语义,提供了更高的灵活性<pre><code>//Lock接口的标准使用形式Lock lock = new ReentrantLock();//...lock.lock();//获取锁try{  //处理} finally{  lock.unlock();//释放锁一定要在finally块中}</code></pre></li></ul></li><li><strong>轮询锁与定时锁</strong><ul><li>可定时的与可轮询的锁获取模式是由tryLock方法实现的,可以避免死锁的发生<pre><code>//通过tryLock来避免锁顺序死锁(非阻塞避免死锁)try{  if(fromAcct.lock.tryLock()){ //尝试获取锁,直接返回结果,非阻塞(true,false)      try{          if(toAcct.lock.tryLock()){//尝试获取锁,直接返回结果,非阻塞              //其他          }      } finally{          toAcct.lock.unlock();      }  }} finally{  fromAcct.lock.unlock();}</code></pre><pre><code>//带有时间限制的加锁(在timeout时间内没有获取到锁就返回false)if(!lock.tryLock(timeout,unit))   return false;try{  //获取锁成功时操作  return doSomething();} finally{  lock.unlock();}</code></pre></li></ul></li><li><strong>可中断的获取锁操作</strong><pre><code> //可中断的锁获取操作 public boolean sendOnSharedLine(String message) throws InterruptedException{//中断会抛出InterruptedException异常     lock.lockInterruptibly();   //可中断的获取锁     try{         return cancellableSendOnShareLine(message);     } finally{         lock.unlock();     } }</code></pre></li><li><strong>公平锁与非公平锁</strong><ul><li>ReentrantLock构造函数中提供了两种公平性选择: 创建一个非公平锁(默认)或一个公平锁</li><li>公平锁上,线程将按照他们发出请求的顺序来获取锁,非公平锁则允许插队</li></ul></li><li><strong>synchronized与ReentrantLock之间的选择</strong><ul><li>在一些内置锁无法满足需求的情况下,ReentrantLock可以作为一种高级工具,当需要一些高级功能时才应该使用ReentrantLock,这些功能包括: 可定时的丶可轮询丶与可中断的锁获取操作,公平队列,以及非块结构的锁,否则还是应该优先使用synchronized</li></ul></li><li><strong>读写锁</strong><pre><code> public interface ReadWriteLock{     Lock readLock();    //获取读锁     Lock writeLock();   //获取写锁 }</code></pre><ul><li>读写锁加锁策略中,允许多个读操作同时进行,但是每次只允许一个写操作</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-性能与可伸缩性</title>
      <link href="/2019/08/28/PerformanceAndScalability/"/>
      <url>/2019/08/28/PerformanceAndScalability/</url>
      
        <content type="html"><![CDATA[<h4 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h4><ol><li><strong>性能与可伸缩性</strong><ul><li>可伸缩性指的是: 当增加计算资源时(如CPU丶内存丶存储容量或I/O带宽),程序的吞吐量或处理能力相应地增加</li></ul></li><li><strong>线程引入的开销</strong><ul><li>在多线程的调度和协调过程中都需要一定的性能开销: 对于为了提升性能而引入的线程来说,并行带来的性能提升必须超过并发导致的开销</li></ul></li><li><strong>上下文切换</strong><ul><li>如果主线程是唯一线程,那么它基本上不会被调度出去.另一方面,如果可运行的线程数大于CPU的数量,那么操作系统最终会将某个正在运行的线程调度出来,从而使其他线程能够使用CPU,这将导致一次上下文切换,切换上下文需要一定的开销(JVM和操作系统的开销丶缓存缺失等)</li><li>在程序中发生越多的阻塞,与CPU密集型的程序就会发生越多的上下文切换,从而增加调度开销(无阻塞算法可以有助于减少上下文切换)</li><li>上下文切换实际开销跟平台有关,大多数通用处理器上下文切换开销相当于5000 ~ 10000个时钟周期,约几微秒</li></ul></li><li><strong>内存同步</strong><ul><li>同步操作的性能开销包括多个方面,synchronized与volatile提供的可见性保证中可能会使用一些特殊指令,即内存栅栏(Memory Barrier),内存栅栏可以刷新缓存,使缓存无效,而且在内存栅栏中,大多数操作都不能重排序</li></ul></li><li><strong>阻塞</strong><ul><li>在锁上发生竞争时,竞争失败的线程肯定会阻塞,JVM在实现阻塞行为时,可以采用自旋等待(时间短)(Spin-Waiting)或者通过操作系统挂机被阻塞的线程(时间长),效率高低取决于上下文切换的开销以及在成功获取锁之前需要等待的时间</li><li>在运行和阻塞之间切换,就相当于一次上下文切换<h4 id="提升性能的方式"><a href="#提升性能的方式" class="headerlink" title="提升性能的方式"></a>提升性能的方式</h4></li></ul></li><li><strong>减少锁的竞争</strong><ul><li>串行操作会降低可伸缩性,上下文切换也会降低性能,在锁上发生竞争时同样导致这两个问题,因此要考虑减少锁的竞争</li><li>在并发程序中,对可伸缩性最主要的威胁就是独占方式的资源锁</li><li>三种方式减少锁竞争: 1.减少锁的持有时间; 2.降低锁的请求频率; 3.使用带有协调机制的独占锁,这些机制允许更高的并发性</li></ul></li><li><strong>缩小锁的范围(快进快出)</strong><ul><li>降低发生锁竞争的可能性的一种有效方式就是尽可能的缩短锁的持有时间</li><li>尽管缩小同步代码块能提高可伸缩性,但同步代码块也不能过小,一些需要采用原子方式执行的操作,必须包含在一个同步块中</li></ul></li><li><strong>减小锁的粒度</strong><ul><li>降低线程请求锁的频率(从而减少发生竞争的可能性)也属于减少锁的持有时间,这可以通过锁分解和锁分段等技术来实现</li><li>采用多个相互独立的锁来保护独立的状态变量,从而改变这些变量在之前由单个锁来保护的情况,这些技术能减少锁操作的粒度,并能实现更高的可伸缩性</li><li>使用锁越多,那么发生死锁的风险也越高<pre><code>//锁分解前(使用的都是同一个锁this)public class ServerStatus{  public final Set&lt;String&gt; users;  public final Set&lt;String&gt; queries;  public synchronized void addUser(String u){ users.add(u); }  public synchronized void addQuery(String q){ queries.add(q); }}</code></pre><pre><code>//使用锁分解技术(分解为多个锁)public class ServerStatus{  public final Set&lt;String&gt; users;  public final Set&lt;String&gt; queries;  public void addUser(String u){      synchronized(users){ users.add(u); }  }  public void addQuery(String q){      synchronized(queries){ queries.add(q); }  }}</code></pre></li></ul></li><li><strong>锁分段</strong><ul><li>将锁分解技术进一步扩展为对一组独立对象上的锁进行分解,这种情况被称为锁分段</li><li>在ConcurrentHashMap(JDK1.7以下)中使用了一个包含16个锁的数组,每个锁保护整个散列桶的1/16,其中第N个散列桶由第(N mod 16)个锁来保护,当需要put元素时,并不对整个hashmap进行加锁,而是先通过hashcode来知道它要放到哪一个分段中,然后对这个分段进行加锁,所以多线程put时,只要不是放到同一个分段中,就实现了并行插入</li><li>锁分段的一个劣势在于: 与采用单个锁来实现独占访问相比,获取多个锁来实现独占访问(某些情况下需要加锁整个容器)将更加困难,并且开销更高</li></ul></li><li><strong>避免热点域</strong><ul><li>将一些反复计算的结果缓存起来,会引入一些热点域(Hot Field),而这些热点域会限制可伸缩性</li></ul></li><li><strong>一些替代独占锁的方法</strong><ul><li>放弃独占锁,使用一种友好并发的方式来管理共享状态,如使用并发容器丶读写锁丶不可变对象及原子变量</li></ul></li><li><strong>避免使用对象池</strong><ul><li>在多线程中使用对象池,需要某种同步来协调对象池数据结构的访问,对象池带来的竞争可能形成一个可伸缩性瓶颈,虽然这看似一种性能优化技术,但实际上却会导致可伸缩性问题,对象池有其特定的用途,但对于性能优化来说,用途是有限的</li></ul></li><li><strong>减少上下文切换</strong><ul><li>在许多任务中都包含一些可能被阻塞的操作,当任务在运行和阻塞这两个状态之间转换时,就相当于一次上下文切换</li><li>减少锁的竞争就能减少阻塞的可能性,同时减少上下文切换,因为在获取锁上发生竞争时将会导致更多的上下文切换</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-避免活跃性问题</title>
      <link href="/2019/08/27/AvoidingLivenessHazards/"/>
      <url>/2019/08/27/AvoidingLivenessHazards/</url>
      
        <content type="html"><![CDATA[<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote><p>当一个线程永远的持有一个锁,并且其他线程都尝试获得这个锁时,那么它们将永远被阻塞</p></blockquote><blockquote><p>eg: 1.线程A持有锁L并想获得锁M,同时线程B持有锁M并尝试获取锁L,那么这两个线程将永远地等待下去,这种情况就是最简单的死锁形式,称为抱死(Deadly Embrace); 2.多个线程由于存在环路的锁依赖关系而永远等待下去(循环等待)</p></blockquote><ol><li><p><strong>锁顺序死锁</strong></p><ul><li><p>多个线程相互占用对方的资源的锁,而又相互等待对方释放锁,此时若无外力干预,这些线程将一直阻塞,形成死锁</p></li><li><p>两个线程试图以不同的顺序来获得相同的锁,即上面抱死形式</p></li><li><p>所有线程以固定的顺序来获得锁,就不会出现锁顺序死锁</p><pre><code>//简单的锁顺序死锁class LeftRightDeadLock{  private final Object left = new Object();  private final Object right = new Object();  public void leftRight(){ //获取锁顺序 left -&gt; right      synchronized (left){          synchronized (right){              doSomething();          }      }  }  public void rightLeft(){ //获取锁顺序 right -&gt; left      synchronized (right){          synchronized (left){              doSomething();          }      }  }  public void doSomething(){}}</code></pre></li></ul></li><li><p><strong>动态锁顺序死锁</strong></p><pre><code> //动态的锁顺序死锁(A-&gt;B转账,同时B-&gt;转账容易死锁(抱死)) public void transferMoney(Account fromAccount,Account toAccount,DollarAmount amount){     synchronized(fromAccount){         synchronized(toAccount){             //转账操作         }     } }</code></pre><pre><code> //通过锁顺序来避免死锁 private static final Object tieLock = new Object();//额外添加一个锁,只有当获取到这个锁时才能获取其他锁(等同于只有一个锁,极少数情况使用,会影响并发性能) public void transferMoney(final Account fromAcct,final Account toAcct,final DollarAmount amount){     int fromHash = System.identityHashCode(fromAcct);     int toHash = System.identityHashCode(toAcct);     if(fromHash &lt; toHash){//加锁顺序(hash: 小-&gt;大)         synchronized(fromAcct){             synchronized(toAcct){                 //转账操作             }         }     }     else if(fromHash &gt; toHash){//加锁顺序(hash: 小-&gt;大)         synchronized(toAcct){             synchronized(fromAcct){                 //转账操作             }         }     }     else{//hash冲突(极少数情况):额外增加一个锁,获取该锁后才能获取其他锁,等同于只有一个锁         synchronized(tieLock){             synchronized(fromAcct){                 synchronized(toAcct){                     //转账操作                 }             }         }     } }</code></pre></li><li><p>** 在协作对象之间发生死锁**</p><pre><code> //在相互协作对象之间的锁顺序死锁 //并行的调用setLocation与getImage方法可能会导致锁顺序死锁 class Taxi{     //...其他内容     public synchronized Point getLocation(){         return location;     }     public synchronized void setLocation(Point location){         this.location = location;         if(location.equals(destination))             dispatcher.notifyAvailable(this);//调用Dispatcher类方法(隐式的获取另一个锁)     } } class Dispatcher{     //...其他内容     public synchronized void notifyAvailable(Taxi taxi){         //更新     }     public synchronized Image getImage(){         Image image = new Image();         for(Taxi t : taxis)             //隐式获取另一个锁             image.drawMarker(t.getLocation);         return image;     } }</code></pre></li><li><p><strong>开放调用</strong></p><ul><li><p>调用某个方法是不需要持有锁,这种调用被称为开放调用</p></li><li><p>在程序中应尽量使用开放调用,与那些持有锁时调用外部方法的程序相比,更易于对依赖于开放调用的程序进行死锁分析</p><pre><code>//通过开放调用来避免在相互协作的对象之间产生死锁class Taxi{  public synchronized Point getLocation(){ return location; }  public void setLocation(Point location){      boolean reachedDestination;      synchronized(this){          this.location = location;          reachedDestination = location.equals(destination);      }      if(reachedDestination)          dispatcher.notifyAvailable(this)//开放调用,调用时不需要持有锁,执行此方法只会在方法内部隐式的获取一个锁  }}class Dispatcher{  public synchronized void notifyAvailable(Taxi taxi){      avilableTaxis.add(taxi);  }  public Image getImage(){      Set&lt;Taxi&gt; copy;      synchronized(this){          copy = new HashSet&lt;Taxi&gt;(taxis);      }      Image image = new Image();      for(Taxi t : copy)          image.drawMarker(t.getLocation);//开放调用,调用时不需要获取锁      return image  }}</code></pre></li></ul></li><li><p><strong>资源死锁</strong></p><ul><li>多个线程在相同的资源集合上等待时,也会发生死锁</li><li>eg: 1.线程A持有数据库D1的连接,并等待与数据库D2的连接,线程B持有D2的链接并等待D1的链接2.一个任务提交另一个任务,并等待被提交任务在单线程的Executor中执行完成,这种情况下第一个任务将永远等待下去,并使得这个Executor中执行的所有其他任务都停止执行,有界线程池/资源池与相互依赖的任务不能一起使用<h4 id="死锁的避免与诊断"><a href="#死锁的避免与诊断" class="headerlink" title="死锁的避免与诊断"></a>死锁的避免与诊断</h4><blockquote><p>如果一个程序每次至多只能获取一个锁,那么就不会产生锁顺序死锁</p></blockquote></li></ul></li></ol><blockquote><p>找出什么地方将获取多个锁,然后对所有这些实例进行全局分析,确保它们在整个过程中获取锁的顺序保持一致</p></blockquote><blockquote><p>尽可能的使用开放调用,这能极大地简化分析过</p></blockquote><ol><li><strong>支持定时的锁</strong><ul><li>显式的使用Lock类中的定时tryLock功能,可以指定一个超时限制(Timeout),等待超时后会返回一个失败信息(对于嵌套的方法中调用请求多个锁,即使你知道已经持有外层锁,也无法释放它)</li></ul></li><li><strong>通过线程转储信息来分析死锁</strong><ul><li>JVM通过线程转储(Thread Dump)来帮助识别死锁的发生,线程转储包括各个运行中的线程的栈追踪信息,这类似于发生异常时的栈追踪信息,线程转储还包含加锁信息,例如每个线程持有哪些锁,在哪个栈帧中获得这些锁,以及被阻塞的线程正在等待获取哪一个锁</li><li>在生成线程转储之前,JVM将再等待关系图中通过搜索循环来找出死锁,如果发现了一个死锁,则获取相应的死锁信息,例如在死锁中涉及哪些锁和线程,以及这个锁的获取操作位于程序的哪些位置</li><li>UNIX平台触发线程转储操作,可以通过向JVM的进程发送SIGOUIT信号(kill -3),或者按ctrl-,在Windows下按ctrl-break键<h4 id="其他活跃性危险"><a href="#其他活跃性危险" class="headerlink" title="其他活跃性危险"></a>其他活跃性危险</h4></li></ul></li><li><strong>饥饿</strong><ul><li>当线程由于无法访问它所需的资源而不能继续执行时,就发生了”饥饿(Starvaion)”</li><li>如果优先级高的线程一直抢占优先级低线程的资源,导致低优先级的线程无法得到执行,这就是饥饿,还有一种情况是一个线程一直占着一个资源不放而导致其他线程得不到执行,与死锁不同的是饥饿在以后一段时间内还是能够执行的,如那个占用资源的线程结束了并且释放了资源</li><li>要避免使用线程优先级,因为会增加平台依赖性,并可能导致活跃性问题</li></ul></li><li><strong>糟糕的响应性</strong><ul><li>CPU密集型的后台任务可能对响应性造成影响,他们会竞争CPU的时钟周期,可以降低它们的优先级</li><li>不良的锁管理也可能导致糟糕的响应性,如果某个线程长时间占有一个锁(正在对一个大容器迭代),而其他想要访问这个容器的线程就必须等待很长时间</li></ul></li><li><strong>活锁</strong><ul><li>线程不断重复执行相同的操作,而且总是失败,导致不能继续往后执行,如在处理事务消息的应用程序中:如果不能成功处理某个消息,那么将回滚事务,并将它重新放入队列开头,如果这个消息存在错误,那将一直循环下去,无法继续执行</li><li>拿到资源却有相互释放不执行,当多线程中出现了相互谦让,都主动将资源释放给别的线程使用,这样这个资源在多线程之间跳动而又得不到执行</li><li>对于相互谦让的可以在重试机制中引入随机性,如两台机器尝试使用相同的载波发送数据包,那么这些数据包就会发生冲突,检测到冲突后会在稍后再次尝试发送,如果两者都选择1秒后重试,那么又会发生冲突,并且不断的冲突下去,可以通过设置随机的等待时间来规避这种情况</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-线程池的使用</title>
      <link href="/2019/08/26/ApplyingThreadPools/"/>
      <url>/2019/08/26/ApplyingThreadPools/</url>
      
        <content type="html"><![CDATA[<h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><ul><li>在线程池中,如果任务依赖于其他任务,那么可能产生死锁</li><li><strong>饥饿:</strong> 一个线程在无限的等待另外一个或多个线程相互传递使用并且永不会释放的资源</li><li><strong>死锁:</strong> 可以认为是两个线程或者进程在请求对方占有的资源<h4 id="运行时间较长的任务"><a href="#运行时间较长的任务" class="headerlink" title="运行时间较长的任务"></a>运行时间较长的任务</h4></li><li>如果任务阻塞的时间过长,那么即使不出现死锁,线程池的响应性也会变得糟糕</li><li>其中一种解决方案是限定任务等待资源的时间,而不要无限制的等待</li><li>类库的大多数可阻塞方法中,都同时定义了限时版本和无限时版本,如Thread.join丶BolockingQueue.put丶CountDownLatch.await和Selector.select等,如果等待超时,那么可以把任务标识为失败,然后终止任务或者重新放回队列以便后续执行<h4 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h4></li><li>要正确设置线程池的大小,必须分析计算环境丶资源预算和任务特性.部署的系统中有多少个CPU?多大的内存?任务是计算(CPU)密集型丶I/O密集型还是二者皆可?它们是否需要像JDBC连接这样的稀缺资源</li><li>对于计算(CPU)密集型任务,线程池的大小一般设置为N(cpu) + 1,通常能实现最优利用率<h4 id="配置ThreadPoolExecutor"><a href="#配置ThreadPoolExecutor" class="headerlink" title="配置ThreadPoolExecutor"></a>配置ThreadPoolExecutor</h4></li><li>ThreadPoolExecutor为一些Executor提供了基本的实现,如newCachedThreadPool丶newFixedThreadPool丶newScheduledThreadExecutor等工厂方法返回的</li><li>如果默认的执行策略不能满足需求,那么可以使用ThreadPoolExecutor的构造函数来实例化一个对象,根据自己需求定制,可以参考Executors工厂类的源码<pre><code>  public ThreadPoolExecutor(      int corePoolSize,   //基本大小      int maximumPoolSize,    //最大大小      long keepAliveTime, //存活时间(空闲时间超过存活时间时,将被标记为可回收且线程池的当前大小超过基本大小时,该线程将被终止)      TimeUnit unit, //存活时间单位      BlockingQueue&lt;Runnable&gt; workQueue,//等待执行的任务放入的队列(无界,有界,同步移交)      ThreadFactory threadFactory, //每当线程池需要创建一个线程时,都是通过线程工厂方法来完成的      RejectedExecutionHandler handler //饱和策略,有界队列被填满后,拒绝新任务的策略  ){ ... }</code></pre></li><li><strong>饱和策略:</strong><ul><li>setRejectedExecutionHandler设置ThreadPoolExecutor的饱和策略</li><li>AbortPolicy 终止策略是默认的饱和策略,该策略将抛出未检查的RejectedExecutionException,调用者可捕获异常然后处理</li><li>CallerRunsPolicy 调用者运行是一种调节机制,该机制会将某些任务回退到调用者,由调用者线程执行,这样会制约调用者线程一段时间内不能提交任务(回退任务没有执行完成前),在这期间,调用者线程不会调用accept,因此到达的请求将被保存在TCP层的队列中而不是在应用程序的队列中,如果持续过载,TCP层将最终发现它的请求队列被填满,因此同样会开始抛弃请求</li><li>DiscardPolicy 抛弃策略会抛弃新提交的任务</li><li>DiscardOldestPolicy 抛弃最旧的策略会抛弃下一个将被执行的任务,然后尝试重新提交新的任务</li></ul></li><li><strong>线程工厂</strong><ul><li>每当线程池需要创建一个线程时,都是通过线程工厂(ThreadFactory)方法来完成的,如果要利用安全策略来控制对某些特殊代码库的访问权限,可通过Executor中的privilegedThreadFactory工厂来定制自己的线程工厂,这将与创建privilegedThreadFactory的线程拥有相同的访问权限,新线程的 accesscontrolcontext 和 contextclassloader 的其他设置与调用此 privilegedthreadfactory 方法的线程相同,如果不使用该方式,线程将从调用execute或者submit的客户程序中继承访问权限</li></ul></li><li><strong>通过构造函数创建ThreadPoolExecutor对象后再设置</strong><ul><li>ThreadpoolExecutor对象提供的setter方法来设置参数(线程池基本大小,最大大小,存活时间,线程工厂,拒绝执行处理器)</li><li>如果是通过Executors中的工厂方法创建的(newSingleThreadExecutor除外),那么可以将结果的类型强转为ThreadPoolExecutor进行设置</li><li>Executors中有一个unconfigurableExecutorService工厂方法,该方法对现有的ExecutorService进行包装,使其只暴露出ExecutorService的方法,因此不能对其配置,newSingleThreadExecutor返回按这种方式封装的ExecutorService</li></ul></li><li><strong>扩展ThreadPoolExecutor</strong><ul><li>ThreadPoolExecutor中提供了beforeExecute丶afterExecute丶terminated方法可以在其子类中进行改写,从而扩展其行为,可以添加日志丶计时丶监视丶统计信息收集</li><li>beforeExecute如果抛出异常,那么任务将不会被执行,afterExecute也不会被调用</li><li>afterExecute: 无论任务是从run中正常返回,还是抛出异常返回,afterExecute都会被调用,如果任务完成后带有一个Error,那么就不会调用afterExecute</li><li>terminated: 线程池完成关闭操作时调用,也就是所有任务都已完成并且所有工作者线程都已关闭后,terminated可以用来释放Executor在其生命周期里分配的各种资源,此外可执行发送通知,记录日志或收集finalize统计信息等操作</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-任务执行</title>
      <link href="/2019/08/24/TaskExecution/"/>
      <url>/2019/08/24/TaskExecution/</url>
      
        <content type="html"><![CDATA[<h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><ol><li><p><strong>Executors工厂类</strong></p><ul><li>newFixedThreadPool创建一个可重用的固定线程数的线程池,以共享的无界队列方式来运行这些线程,当活动线程到达固定数量时,再次加入任务会加入队列等待其他活动线程运行结束,再执行</li><li>newCachedThreadPool创建一个可缓存线程池大小不固定(基本大小为0,最大大小为Integer.MAX_VALUE),在使用缓存型池时,先查看池中有没有以前创建的线程,如果有就复用,没有则加入;会终止并从缓存中移除那些已有60秒未被使用的线程</li><li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行</li><li>newSingleThreadExecutor创建一个单线程化的线程池,保证所有任务按照指定顺序(FIFO,LIFO,优先级)执行</li><li>newWorkStealingPool实际上就是ForkJoinPool,默认并行级别是CPU数目,每个工作线程都维护着一个工作队列(是双端队列),使用工作窃取(work-stealing)算法,完成自己任务而处于空闲的工作线程会从其他仍然忙碌状态的工作线程处窃取等待执行的任务进行处理</li><li>其他自定义类型的连接池可通过显示的ThreadPoolExecutor构造函数创建</li></ul></li><li><p><strong>ExecutorService</strong></p><ul><li><p>ExecutorService是一个接口,继承了Executor接口,该接口扩展了一些生命周期的方法</p><pre><code>public interface ExecutorService extends Executor {  void shutdown(); //平缓的关闭,停止接收新的任务,等待已经提交的任务执行结束(包括还未执行的任务)再关闭  List&lt;Runnable&gt; shutdownNow();//粗暴的关闭,停止接收新的任务,并尝试停止所有运行中的任务,不在启动队列中尚未开始执行的任务  boolean isShutdown(); //是否已经关闭  boolean isTerminated();//若关闭后所有任务都已完成,则返回true;注意除非首先调用shutdown或shutdownNow,否则isTerminated永不为true  /**   * @param timeout 超时时间   * @param unit 时间单位   * 使线程等待timeout时长,当超过timeout时间后,会监测ExecutorService是否已经关闭,   * 若关闭则返回true,否则返回false.一般情况下会和shutdown方法组合使用.   * (awaitTermination不会关闭ExecutorService,只是定时检测一下他是否关闭)   */  boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;  //...其他用于任务提交的便利方法}</code></pre></li></ul></li><li><p><strong>示例</strong></p><pre><code> //基于线程池的web服务器 class TaskExecutionWebServer{     private static final int NTHREADS = 100;     //创建固定线程数的线程池     private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);     public static void main(String[] args) throws IOException{         ServerSocket socket = new ServerSocket(80);         while(true){             final Socket connection = socket.accept();             Runnable task = () -&gt; handleRequest(connection);             exec.execute(task); //将请求任务加入线程池,超过线程数的线程会被加入队列中等待         }     }     private static void handleRequest(Socket connection) {         // 请求处理     } }</code></pre></li><li><p><strong>延迟任务与周期任务</strong></p><ul><li><p>Timer(存在缺陷,不推荐使用)负责管理延迟任务以及周期任务,然而Timer存在一些缺陷,<strong>执行所有定时任务时只会创建一个线程</strong>,Timer线程不会捕获异常,如果抛出了未检查异常则会导致线程终止,导致整个Timer线程任务取消;<strong>Timer对调度的支持是基于绝对时间的</strong>,而不是相对时间,所以对系统时间的改变非常敏感</p></li><li><p>ShceduledThreadPoolExecutor用来替代Timer,它基于相对时间(基于System.nanoTime实现相对时间,不会因系统时间的改变而改变)</p><pre><code>//错误的Timer行为(所有定时任务只会创建一个线程)public void timerTest() throws Exception {  Timer timer = new Timer();  timer.schedule(new ThrowTask(), 1); //定时任务1抛出异常  Thread.sleep(1000);  timer.schedule(new ThrowTask(), 1); //整个Timer线程终止(Timer already cancelled),定时任务2不在执行  Thread.sleep(5000);}class ThrowTask extends TimerTask { //执行任务,抛出异常  public void run() { throw new RuntimeException(); }}</code></pre></li></ul></li><li><p><strong>携带结果的任务Callable与Future</strong></p><ul><li><p>Runnable和Callable描述的都是抽象的计算任务,但是Runnable没有返回值,Callable可以有返回值(Callable<void>可以表示无返回值),并可能抛出一个异常</void></p></li><li><p>Future表示一个任务的生命周期,并提供了相应的方法来判断是否已经完成或取消,以及获取任务的结果和取消任务等(任务的生命周期只能前进,不能后退),其中get方法是可阻塞的</p></li></ul></li></ol><h4 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h4><blockquote><ul><li><p>Fork/Join框架是ExecutorService接口的一种具体实现,目的是为了更好地利用多个处理器,能够递归的拆解子任务(用新线程处理fork),需要实现其compute方法,在其中实现分割子任务</p><ul><li>ForkJoinPool 的每个工作线程都维护着一个工作队列(是双端队列),使用工作窃取(work-stealing)算法,完成自己任务而处于空闲的工作线程会从其他仍然忙碌状态的工作线程处窃取等待执行的任务进行处理</li><li>如果想对大任务进行分割成子任务,可以选择继承RecursiveTask(有返回值)或者RecursiveAction(无返回值),重写compute方法并在内部进行分割子任务,然后向ForkJoinPool线程池中提交自定义的ForkJoinTask任务即可</li><li>提交ForkJoinTask任务时,invoke是同步执行,submit是异步执行</li><li>fork与invokeAll区别,fork是建立分支,直接将子任务交于其他线程处理,invokeAll会将其中第一个任务交给当前线程处理,其他的任务交于其他线程处理</li></ul></li></ul></blockquote><ol><li><strong>示例: 多线程归并排序</strong></li></ol><pre><code>@Testpublic void forkJoinTest() throws Exception{    //创建数组    Integer[] array = new Random().ints(100000000,0,Integer.MAX_VALUE)            .boxed().toArray(Integer[]::new);    new Merge&lt;&gt;(array).parallelSort();    //new Merge&lt;&gt;(array).sort();    System.out.println(SortTemplate.isSorted(array));//判断是否有序}//使用Fork/Join进行归并排序class Merge&lt;E&gt; extends RecursiveAction{    private E[] elements;    private E[] aux;//辅助数组    private Comparator&lt;E&gt; comparator; //比较器    private int lo;    private int hi;    public Merge(E[] elements, Comparator&lt;E&gt; comparator) {        this.elements = elements;        this.aux = (E[])new Object[elements.length];        this.comparator = comparator;        //准备数据        this.lo = 0;        this.hi = elements.length-1;    }    public Merge(E[] elements){        this.elements = elements;        this.aux = (E[])new Object[elements.length];        this.comparator = (E x,E y) -&gt; {            if(x instanceof Comparable) return ((Comparable) x).compareTo(y);            else throw new RuntimeException("需要传入Comparator或者实现Comparable");        };        //准备数据        this.lo = 0;        this.hi = elements.length-1;    }    //私有构造方法用于分支调用    private Merge(E[] elements, E[] aux, Comparator&lt;E&gt; comparator, int lo, int hi) {        this.elements = elements;        this.aux = aux;        this.comparator = comparator;        this.lo = lo;        this.hi = hi;    }    //单线程归并    public void sort(){        merge(elements,aux,lo,hi);    }    //多线程并行归并    public void parallelSort(){        ForkJoinPool forkJoin = (ForkJoinPool) Executors.newWorkStealingPool();        try {            forkJoin.submit(this).get();//提交任务并获取等待结束        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        forkJoin.shutdown();    }    @Override    protected void compute() {        if(hi - lo &lt;= 10000) merge(elements,aux,lo,hi);        else{            //分成两部分,分别进行归并操作            int mid = lo + (hi-lo)/2;            Merge&lt;E&gt; mergeTask1 = new Merge&lt;&gt;(elements,aux,comparator,lo,mid);            Merge&lt;E&gt; mergeTask2 = new Merge&lt;&gt;(elements,aux,comparator,mid+1,hi);            //mergeTask1.fork(); //分支(异步): 子任务交给其他线程处理            //mergeTask2.fork();            //mergeTask1.join(); //获取(同步): 阻塞当前线程并等待获取结果            //mergeTask2.join();            invokeAll(mergeTask1,mergeTask2); //批量提交子任务,会阻塞到结果返回: 与fork不同,mergeTask1会分配给当前线程            inPlaceMerge(elements,lo,mid,hi);        }    }    //归并排序(对arr数组[lo,hi]部分进行归并排序)    private void merge(E[] arr,E[] aux,int lo,int hi){        for(int i=lo;i&lt;=hi;++i)            aux[i] = arr[i];        for(int i=1,len=hi-lo+1;i&lt;len;i&lt;&lt;=1)            for(int j = lo;j&lt;=hi-i;j += i&lt;&lt;1)                inPlaceMerge(arr,j,j+i-1,Math.min(j+(i&lt;&lt;1)-1,hi));    }    private void inPlaceMerge(E[] elements,int lo,int mid,int hi){        for(int i=lo;i&lt;=hi;++i)            aux[i] = elements[i];        int i = lo,j = mid+1;        for(int k=lo;k&lt;=hi;++k) {            if (i &gt; mid) elements[k] = aux[j++];            else if (j &gt; hi) elements[k] = aux[i++];            else if (((Comparable)aux[i]).compareTo(aux[j]) &gt; 0) elements[k] = aux[j++];            else elements[k] = aux[i++];        }    }}</code></pre><ol start="2"><li><strong>示例: 多线程快排</strong></li></ol><pre><code>public class Quick&lt;E&gt; extends RecursiveAction{    private E[] elements;    private Comparator&lt;E&gt; comparator; //比较器    private int lo;    private int hi;    public Quick(E[] elements, Comparator&lt;E&gt; comparator) {        this.elements = elements;        this.comparator = comparator;        this.lo = 0;        this.hi = elements.length - 1;    }    public Quick(E[] elements) {        this.elements = elements;        this.comparator = (E x,E y) -&gt; {            if(x instanceof Comparable) return ((Comparable) x).compareTo(y);            else throw new RuntimeException("需要传入Comparator或者实现Comparable");        };        this.lo = 0;        this.hi = elements.length - 1;    }    private Quick(E[] elements,int lo,int hi){        this.elements = elements;        this.lo = lo;        this.hi = hi;    }    //快排:单线程    public void sort(){ quickMedian(elements,lo,hi); }    //快排:多线程并行    public void parallelSort(){        ForkJoinPool forkJoin = (ForkJoinPool) Executors.newWorkStealingPool();        try {            forkJoin.submit(this).get();//提交任务并获取等待结束        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        forkJoin.shutdown();    }    @Override    protected void compute() {        if(hi - lo &lt;= 10000) quickMedian(elements,lo,hi);        else{            //分切            int j = partitionMedian(elements,lo,hi);            //剩余两部分作为两个分支任务放入ForkJoinPool            Quick&lt;E&gt; left = new Quick&lt;&gt;(elements,lo,j-1);            Quick&lt;E&gt; right = new Quick&lt;&gt;(elements,j+1,hi);            invokeAll(left,right);        }    }    //快速排序: 对[lo,hi]部分进行快速排序    private void quickMedian(E[] arr,int lo,int hi){        int len = hi-lo+1;        if(len &lt;= 10){ //1. 数组规模小于10时使用插入排序            insertion(arr,lo,hi);            return;        }        int j = partitionMedian(arr,lo,hi);        quickMedian(arr,lo,j-1);        quickMedian(arr,j+1,hi);    }    private int partitionMedian(E[] arr,int lo,int hi){        int len = hi-lo+1;        setMedian(arr,lo,hi); //2. 从lo,hi,中间处mid三个数中找出中位数与lo交换,最大数与hi交换        E v = arr[lo]; //分切元素        int i = lo, j = hi+1;        while(true){            while(((Comparable)v).compareTo(arr[--j]) &lt; 0);            while(((Comparable)arr[++i]).compareTo(v) &lt; 0); // if(i == j) break; 取中位数时,每次最大数与hi交换,因此不需要进行边界判断            if(i &gt;= j) break;            //交换            exch(arr,i,j);        }        exch(arr,lo,j);        return j;    }    private void setMedian(E[] arr,int lo,int hi){        int mid = (lo+hi)/2;        int max = lo;        if(((Comparable)arr[max]).compareTo(arr[mid]) &lt; 0) max = mid;        if(((Comparable)arr[max]).compareTo(arr[hi]) &lt; 0) max = hi;        exch(arr,max,hi);        if(((Comparable)arr[lo]).compareTo(arr[mid]) &lt; 0) exch(arr,lo,mid);    }    private void exch(E[] arr,int i,int j){        if(i == j) return;        E temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }    private void insertion(E[] arr,int lo,int hi){        for(int i=lo+1;i&lt;=hi;++i)            for(int j=i;j&gt;lo &amp;&amp; ((Comparable)arr[j]).compareTo(arr[j-1]) &lt; 0;--j)                exch(arr,j,j-1);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-取消与关闭</title>
      <link href="/2019/08/22/CancellationAndShutdown/"/>
      <url>/2019/08/22/CancellationAndShutdown/</url>
      
        <content type="html"><![CDATA[<h4 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a><strong>任务取消</strong></h4><ol><li><p><strong>取消</strong></p><ul><li>java中没有安全的将占方式来停止线程,只有一些协作式的机制</li><li>其中一种协作机制,设置某个”已请求取消标志”,而任务将定期的查看该标志,如果设置了这个标志,任务将提前结束,(对于存在阻塞方法的任务,可能永远不会检查到取消标志,导致永远不会结束)<pre><code>while(!cancelled) //因为put为可阻塞方法,可能导致一直阻塞,导致无法检查取消标志  blockQueue.put(p);</code></pre></li></ul></li><li><p><strong>中断</strong></p><ul><li>每个线程都有一个boolean类型的中断状态,当中断线程时,这个线程的中断状态将被设为true(仅设置状态)<pre><code>public class Thread{  public void interrupt(){} //设置中断  public boolean isInterrupted(){} //检查是否中断  public static boolean interrupted(){} //清除当前线程的中断状态}</code></pre></li><li>阻塞库方法,如Thread.sleep和Object.wait等方法都会检查线程何时中断,并且在发现中断时提前返回,它们在响应中断时执行的操作包括:清除中断状态,抛出InterruptedException,表示阻塞操作由于中断而提前结束,JVM不能保证阻塞方法检测到中断的速度,但实际情况中响应速度还是非常快的</li><li>调用interrupt并不意味着立即停止目标线程正在执行的任务,而只是传递了请求中断的消息</li></ul></li><li><p><strong>中断策略</strong></p><ul><li>最合理的中断策略是某种形式的线程级(Thread_Level)取消操作或服务级(Service-Level)取消操作;尽快退出,在必要时进行清理,通知某个所有者该线程已经退出</li></ul></li><li><p><strong>响应中断</strong></p><blockquote><p>当调用可中断的阻塞函数时(中断后会抛出InterruptedException),有两种使用策略用于处理该异常</p></blockquote><ul><li>传递(声明抛出)异常,从而使你的方法也成为可中断的阻塞方法<pre><code>public Task getNextTask() throws InterruptedException{ //传递异常  return blockingQueue.take();}</code></pre></li><li>恢复中断状态,从而使调用栈中的上层代码能够对其进行处理</li></ul></li><li><p><strong>通过Future来实现取消</strong></p><ul><li>Future作为一种抽象机制来管理任务的生命周期,处理异常,以及实现取消.通常使用现有库中的类比自行编写更好</li><li>boolean cancel(boolean mayInterruptRunning)方法参数为false时只能取消还没有开始的任务,对于已经开始的任务,就任由其运行下去;参数为true时,会中断正在执行的任务<pre><code>//通过Future取消任务public void timedRun(Runnable r,long timeout,TimeUnit unit) throws InterruptedException{  //交给Future取消任务  Future&lt;?&gt; task = taskExec.submit(r); //taskExec 为ExecutorService  try {      task.get(timeout,unit);  } catch (ExecutionException e) {      //可对异常进行处理,抛出详细异常  } catch (TimeoutException e) {      //取消任务  } finally {      //如果任务已经结束,cancel方法不会有任何影响;如果任务正在运行,将被中断      task.cancel(true);   }}</code></pre></li></ul></li><li><p><strong>处理不可中断的阻塞</strong></p><ul><li><p>重写interrupt方法将非标准的取消操作封装在Thread中</p><pre><code>//重写interrupt方法将非标准的取消操作封装在Thread中class ReaderThread extends Thread{  private final Socket socket;  @Override  public void interrupt() { //重写interrupt方法      try {          socket.close();      } catch (IOException e) {      } finally {          super.interrupt();      }  }  @Override  public void run() {      //任务  }}</code></pre></li><li><p>将非标准的取消操作封装在一个任务(Future)中</p><pre><code>//扩展Callable接口interface CancellableTask&lt;T&gt; extends Callable&lt;T&gt;{  void cancel();  RunnableFuture&lt;T&gt; newTask();}//将非标准的取消操作封装到(Future)任务中abstract class SocketUsingTask&lt;T&gt; implements CancellableTask&lt;T&gt;{  private Socket socket;  //...  @Override  public synchronized void cancel() { //重写取消操作      try {          if(socket != null)              socket.close();      } catch (IOException e) {}  }  @Override  public RunnableFuture&lt;T&gt; newTask() { //将此Callable封装为任务返回      return new FutureTask&lt;T&gt;(this){//封装为FutureTask          //重写取消方法          @Override          public boolean cancel(boolean mayInterruptIfRunning) {              try {                  SocketUsingTask.this.cancel(); //调用Callable重写的cancel方法              } finally {                  return super.cancel(mayInterruptIfRunning);              }          }      };  }}    </code></pre></li></ul></li><li><p><strong>停止基于线程的服务</strong></p><ul><li>服务应该提供生命周期方法(Lifecycle Method)来关闭它自己以及它所拥有的线程,这样服务关闭时,就可以关闭所有线程了,如ExecutorService中提供了shutdown和shutdownNow方法</li></ul></li><li><p><strong>关闭ExecutorService</strong></p><ul><li>shutdown正常关闭:等待队列中所有任务执行完成后才关闭</li><li>shutdownNow强制关闭:首先关闭当前正在执行的任务,然后返回所有尚未启动的任务清单(无法获知正在执行而被关闭的任务)</li></ul></li><li><p><strong>毒丸(Poison Pill)对象</strong></p><ul><li>毒丸是指一个放在队列上的对象,当得到这个对象时,立即停止</li><li>在FIFO队列中,毒丸对象将确保消费者在关闭之前首先完成队列中的所有工作,在提交毒丸对象之前提交的所有任务都会被处理,而之后的不会再处理<h4 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h4></li></ul></li><li><p><strong>未捕获异常的处理</strong></p><ul><li>Thread中提供了UncaughtExceptionHandler,它能检测出某个线程由于未捕获的异常而终结的情况,当一个线程由于未捕获的异常退出时,JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler异常处理器,如果没有提供,那默认将栈追踪信息输出到System.err</li><li>可以实现该接口,主动的处理异常并写入日志中</li><li>Thread.setUncaughtExceptionHandler为线程设置异常处理器</li><li>Thread.setDefaultUncaughtExceptionHandler设置默认的异常处理器</li><li>ThreadPoolExecutor在构造函数中传入ThreadFactory,就会为线程池所有线程设置一个异常处理器</li><li>在Executor中由submit提交的任务,不会交UncaughtExceptionHandler,而是被Future.get封装在ExecutionException中重新抛出<h4 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h4></li></ul></li><li><p><strong>关闭钩子</strong></p><ul><li>在JVM正常关闭中,JVM首先会调用所有已注册的关闭钩子(Shutdown Hook),关闭钩子并发执行,JVM并不保证关闭钩子的执行顺序,,当所有关闭钩子执行结束,如果runFinalizersOnExit为true,那么JVM将运行终结器,然后在停止,编写的关闭钩子必须要尽快退出,因为它们会延迟JVM的结束时间</li><li>Runtime.getRuntime().addShutdownHook(Threa thread); 注册关闭钩子<pre><code>//通过注册一个关闭钩子来停止日志服务public void start(){  Runtime.getRuntime().addShutdownHook(new Thread(){      public void run(){          //停止日志服务      }  })}</code></pre><h4 id="守护线程-Daemon-Thread"><a href="#守护线程-Daemon-Thread" class="headerlink" title="守护线程(Daemon Thread)"></a>守护线程(Daemon Thread)</h4><blockquote><p>当JVM中不存在任何一个正在运行的非守护线程时,则JVM进程即会退出,此时会丢弃掉所有现存的守护线程</p></blockquote></li></ul></li></ol><blockquote><p>当JVM停止时,所有仍然存在的守护线程都将被丢弃,既不执行finally块,也不会执行回卷栈,应该尽可能少的私用守护线程</p></blockquote><blockquote><p>创建一个守护线程,需要在调用thread.start()方法之前调用thread.setDeamon()方法.</p></blockquote><h4 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h4><blockquote><p>GC回收器对那些定义了finalize方法的对象会进行特殊处理: 在回收器释放他们后,会调用他们的finalize方法,从而保证一些持久化的资源被释放</p></blockquote><blockquote><p>尽量避免使用终结器(当需要管理对象且该对象持有的资源是通过本地方法获得时才使用)</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-构建基础模块</title>
      <link href="/2019/08/20/BuildingBlocks/"/>
      <url>/2019/08/20/BuildingBlocks/</url>
      
        <content type="html"><![CDATA[<h4 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h4><blockquote><p>Vector , Hashtable , Collections.synchronizedXxx等工厂方法创建</p></blockquote><blockquote><p>这些类实现线程安全方式: 将它们的状态封装起来,并对每个共有方法都进行同步,是的每次只有一个线程能方法容器状态</p></blockquote><ol><li><p><strong>同步容器类上复合操作需要加锁</strong></p><pre><code> //使用客户端加锁的Vector上的复合操作 public static Object getList(Vector list){     //线程安全容器类的复合操作需要加锁(与容器类内部锁相同)保证线程安全     synchronized (list) {         int lastIndex = list.size() - 1;         return list.get(lastIndex);     } }</code></pre></li><li><p><strong>注意: 隐藏的迭代器</strong></p><blockquote><p>hashCode 与 equals 等方法会间接的执行迭代操作</p></blockquote><blockquote><p>containsAll 丶 removeAll 和 retainAll等方法,以及把容器作为参数的构造方法,都会对容器进行迭代</p></blockquote><pre><code> //隐藏的迭代器 public void toStringList(Vector list){     //容器会进行隐藏的迭代操作,不能保证线程安全     System.out.println(list); }</code></pre><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><blockquote><p>通过并发容器(细粒度加锁)来代替同步容器,可以极大提高伸缩性并降低风险</p></blockquote></li></ol><blockquote><p>ConcurrentHashMap , CopyOnWriteArrayList , ConcurrentLinkedQueue先进先出队列 , BlockingQueue 阻塞队列</p></blockquote><ol><li><p>ConcurrentHashMap</p><ul><li>JDK1.7使用分段锁,JDK1.8+使用CAS+synchronized</li><li>当需要加锁Map进行独占访问时,应放弃使用ConcurrentHashMap</li><li>如果要增加额外的复合原子操作,则不能使用客户端加锁机制,可以使用组合(详见对象的组合)(实现ConcurrentMap接口)</li></ul></li><li><p>CopyOnWriteArrayList</p><ul><li>读取时不加锁,写入和删除时加锁,每次修改时都会创建并重新发布一个容器副本</li><li>只能保证数据的最终一致性,不能保证数据的实时一致性</li><li>每当修改时都会复制底层数组,这需要一定开销,仅当迭代操作远远多于修改操作时,才应该使用</li></ul></li><li><p><strong>阻塞队列</strong></p><ul><li>LinkedBlockingQueue 和 ArrayBlockingQueue是FIFO队列 ; PriorityBlockingQueue是优先队列 ;<br>BlockingDeque是双端队列(常用于工作窃取算法) ; SynchronousQueue没有容量的无缓冲队列,维护的是一组线程,因为没有存储功能,put与take方法会一直阻塞,直到另一个线程已经准备好参与到交付过程中,数据直接在配对的线程之间传递</li><li>阻塞队列提供了可阻塞的put和take方法,以及支持定时的offer和poll方法,如果队列已经满了,那么put方法将阻塞直到有空间可用;如果队列为空,那么take方法将会阻塞直到有元素可用,队列可以是有界的也可以是无界的,无界队列永远不会充满,因此无界队列上的put方法永远不会阻塞</li><li>阻塞队列支持生产者-消费者模式,可以协调生产者和消费者等线程之间的控制流<h4 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h4></li></ul></li><li><p><strong>闭锁</strong></p><ul><li><p>CountDownLatch , 闭锁可以使一个线程等待其他线程完成各自的工作后再执行(例如确保某个计算在其所需的所有资源都被初始化之后才继续执行)</p></li><li><p>CountDownLatch是通过计数器实现的,计数器初始值为线程的数量,每当一个线程完成自己的任务后,计数器值就会减1,当计数器达到0时,闭锁上等待的线程就可以恢复执行任务</p><pre><code>//闭锁实例: 运动员等待一声命令比赛开始,所有运动员达到终点后比赛结束public void latchTest(){  int players = 3;  //begin闭锁初始化,计数值1  CountDownLatch begin = new CountDownLatch(1);  //end闭锁初始化,计数值2  CountDownLatch end = new CountDownLatch(players);  for(int i=0;i&lt;players;++i){      new Thread(() -&gt; {          try {              begin.await(); //begin闭锁,等待直到计数为0时,开始往后执行          } catch (InterruptedException e) {              e.printStackTrace();          }          System.out.println(Thread.currentThread().getName() + "Arrived");          end.countDown(); //end闭锁,计数-1      }).start();  }  System.out.println("the race begin");  begin.countDown(); //begin闭锁,计数-1  try {      end.await(); //end闭锁,等待直到计数为0,才开始往后执行  } catch (InterruptedException e) {      e.printStackTrace();  }  System.out.println("the race end");}</code></pre></li><li><p>FutureTask实现闭锁,FutureTask可用于异步获取执行结果或取消执行任务的场景</p><pre><code>//使用FutureTask来提前加载稍后使用的数据class Preloader{  ProductInfo loadProductInfo(){ return null; }  private final FutureTask&lt;ProductInfo&gt; future = new FutureTask&lt;&gt;(() -&gt; loadProductInfo() );  private final Thread thread = new Thread(future);  public void start(){ thread.start(); }  public ProductInfo get(){      ProductInfo info = null;      try {          info = future.get(); //等待FutureTask线程任务执行结束后返回执行结果      } catch (InterruptedException e) {          e.printStackTrace();      } catch (ExecutionException e) {          //所有异常都被封装到ExecutionException中,可在此进行处理返回详细异常          e.printStackTrace();      }      return info;}interface ProductInfo{}}</code></pre></li></ul></li><li><p><strong>信号量</strong></p><ul><li><p>Semaphore类是一个计数信号量,必须由获取它的线程释放,常用于控制同时访问特定资源的线程数目</p></li><li><p>二值信号量,即初始值为1的Semaphore,可以用做互斥体(mutex),并具备不可重入的加锁语义</p></li><li><p>Semaphore可以实现资源池,有界阻塞容器等</p><pre><code>//使用Semaphore实现有界容器class BoundedHashSet&lt;T&gt;{  private final Set&lt;T&gt; set;  private final Semaphore semaphore;  //构造函数,传入有界容器大小  public BoundedHashSet(int bound) {      this.set = Collections.synchronizedSet(new HashSet&lt;&gt;());      this.semaphore = new Semaphore(bound);  }  //添加时先获取计数信号量(计数+1),如果添加失败则,释放  public boolean add(T o) throws InterruptedException {      boolean wasAdded = false;      semaphore.acquire();      try {          wasAdded = set.add(o);      } finally {          if(!wasAdded) semaphore.release();      }      return wasAdded;  }  //删除成功时释放计数信号量(计数-1)  public boolean remove(T o){      boolean wasRemoved = set.remove(o);      if(wasRemoved) semaphore.release();      return wasRemoved;  }}</code></pre></li></ul></li><li><p><strong>栅栏</strong></p><ul><li>栅栏类似于闭锁,它能阻塞一组线程直到某个事件发生,栅栏与闭锁的关键区别在于,所有的线程必须同时到达栅栏位置(await()位置),才能继续执行,闭锁用于等待事件(可以是这些线程以外的事件),而栅栏用于等待其他线程(只能在线程中)</li><li>栅栏提供了reset方法,可以重复使用,闭锁不能重复使用</li><li>另一种形式的栅栏是Exchanger , 它是两方栅栏,用于在各方的栅栏上交换数据<pre><code>//栅栏: CyclicBarrier简单实例public void barrierTest(){  //创建一个栅栏对象,初始化为5  CyclicBarrier barrier = new CyclicBarrier(5);  for(int i=0;i&lt;5;++i){      new Thread(() -&gt; {          try {              System.out.println(Thread.currentThread().getName() + "执行到栅栏位置");              barrier.await();    //设置栅栏,线程执行到此会等待                                  //当其他所有设置栅栏的线程都到达栅栏位置,再往后执行          } catch (InterruptedException e) {              e.printStackTrace();          } catch (BrokenBarrierException e) {              e.printStackTrace();          }          System.out.println(Thread.currentThread().getName() + "通过栅栏");      }).start();  }}</code></pre></li></ul></li><li><p><strong>Exchanger</strong></p><ul><li><p>用于两个线程间信息交换,两个线程使用同一个Exchanger对象,V exchange(V x),x为需要交换的变量,返回结果为交换后的变量</p></li><li><p>如果超过两个线程使用同一个Exchanger对象,执行exchange方法,得到的结果随机</p><pre><code>@Testpublic void echangerTest(){  Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();//使用同一个exchange  new Thread(() -&gt;{//线程1      try {          //传入交换前的值(Tom),返回交换后的值(Jerry)          System.out.println("Tom交换后: "+exchanger.exchange("Tom"));      } catch (InterruptedException e) {          e.printStackTrace();      }  }).start();  new Thread(() -&gt;{//线程2      try {          System.out.println("Jerry交换后: "+exchanger.exchange("Jerry"));      } catch (InterruptedException e) {          e.printStackTrace();      }  }).start();}//输出//Tom交换后: Jerry//Jerry交换后: Tom</code></pre></li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-对象的组合</title>
      <link href="/2019/08/18/Composingobjects/"/>
      <url>/2019/08/18/Composingobjects/</url>
      
        <content type="html"><![CDATA[<h4 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h4><blockquote><p>将数据封装在对象内部,可以将数据的访问限制在对象的方法上,从而更容易确保线程在访问数据时总能持有正确的锁</p><ul><li>java类库中有很多线程封闭示例: Collections.synchronizedList及其类似方法,这些工厂方法通过装饰器(Decorator)设计模式将容器类封装在一个同步的包装容器对象中</li></ul></blockquote><pre><code>//通过封闭机制来确保线程安全public class PersonSet {    //将数据封装在对象内部    private final Set&lt;Person&gt; mySet = new HashSet&lt;Person&gt;();    //数据访问只能通过此同步方法进行    public synchronized void addPerson(Person p) {        mySet.add(p);    }    //数据访问只能通过此同步方法进行    public synchronized boolean containsPerson(Person p) {        return mySet.contains(p);    }    interface Person {    }}</code></pre><ol><li><p><strong>监视器模式</strong></p><blockquote><p>遵循java监视器模式的对象会把对象的所有可变状态都封装起来,并由对象自己的内置锁来保护,例如Vector和HashTable</p></blockquote></li></ol><pre><code>//监视器模式: 通过一个私有锁来保护状态public class PrivateLock {    private final Object myLock = new Object();    Widget widget; //要封装的对象widget    void someMethod() {        synchronized (myLock) { //由内置锁(监视器)保护            // 访问或修改widget对象状态        }    }}</code></pre><ol start="2"><li><p><strong>线程安全性的委托</strong></p><blockquote><p>如果一个类是由多个独立且线程安全的状态变量组成,并且在所有的操作中都不包含无效状态转换,那么可以将线程安全性委托给底层的状态变量</p></blockquote></li></ol><pre><code>//将线程安全性委托给多个状态变量public class VisualComponent {    //两个事件监听器之间不存在任何关联,将VisualComponent类的线程安全性委托给这两个线程安全的监听器列表    //由CopyOnWriteArrayList管理保证线程安全性    private final List&lt;KeyListener&gt; keyListeners = new CopyOnWriteArrayList&lt;KeyListener&gt;();    private final List&lt;MouseListener&gt; mouseListeners = new CopyOnWriteArrayList&lt;MouseListener&gt;();    public void addKeyListener(KeyListener listener) {        keyListeners.add(listener);    }    public void addMouseListener(MouseListener listener) {        mouseListeners.add(listener);    }    public void removeKeyListener(KeyListener listener) {        keyListeners.remove(listener);    }    public void removeMouseListener(MouseListener listener) {        mouseListeners.remove(listener);    }}</code></pre><h4 id="现有的线程安全类中添加功能"><a href="#现有的线程安全类中添加功能" class="headerlink" title="现有的线程安全类中添加功能"></a>现有的线程安全类中添加功能</h4><ol><li><strong>扩展类</strong></li></ol><pre><code>//没有则添加: 继承然后扩展类public class BetterVector &lt;E&gt; extends Vector&lt;E&gt; {    //对于一个继承了serializable的类,应该重新定义其serialVersionUID    static final long serialVersionUID = -3963416950630760754L;    //不存在时添加: 增加一个原子方法(使用同步锁)    public synchronized boolean putIfAbsent(E x) {        boolean absent = !contains(x);        if (absent)            add(x);        return absent;    }}</code></pre><ol start="2"><li><strong>客户端加锁机制</strong></li></ol><pre><code>//没有则添加: 通过客户端加锁方式实现class GoodListHelper &lt;E&gt; {    public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;());    public boolean putIfAbsent(E x) {        synchronized (list) { //锁对象必须和list对象内部方法使用的锁对象为同一个            boolean absent = !list.contains(x);            if (absent)                list.add(x);            return absent;        }    }}</code></pre><ol start="3"><li><strong>组合</strong></li></ol><pre><code>//没有则添加: 通过组合实现(该方式更加健壮)//实际上就是java监视器模式public class ImprovedList&lt;T&gt; implements List&lt;T&gt; {    //维护一个list对象,将实现委托给list对象的方法    private final List&lt;T&gt; list;    public ImprovedList(List&lt;T&gt; list) {        this.list = list;    }    //没有则添加    public synchronized boolean putIfAbsent(T x) {        boolean contains = list.contains(x);        if (contains)            list.add(x);        return !contains;    }    //方法实现委托给list对象的方法,其他方法使用同样方式即可    public synchronized boolean add(T e) {        return list.add(e);    }    public synchronized boolean remove(Object o) {        return list.remove(o);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-对象的共享</title>
      <link href="/2019/08/10/SharingObjects/"/>
      <url>/2019/08/10/SharingObjects/</url>
      
        <content type="html"><![CDATA[<h4 id="非原子的64操作"><a href="#非原子的64操作" class="headerlink" title="非原子的64操作"></a>非原子的64操作</h4><ul><li>非volatile类型的64位数值变量(double和long),JVM允许将64位的读或写操作分解为两个32位操作,因此在多线程中使用共享且可变的long与double类型的变量是不安全的,需要使用volatile声明或者用锁保护起来</li></ul><h4 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h4><ul><li>保证可见性且防止重排序</li></ul><h4 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h4><blockquote><p>发布: 使对象能够在当前作用域之外的代码中使用</p></blockquote><ul><li><strong>不安全的发布</strong></li></ul><pre><code>/** * 私有的数组states已经逸出了它所在的作用域,致使调用者可以修改这个数组的内容 */class UnsafeStates{    private String[] states = new String[]{"A","B"};    public String[] getStates(){ return states; }}</code></pre><ul><li><strong>this引用逸出</strong></li></ul><pre><code>public class ThisEscape{    public ThisEscape(EventSource source){        source.registerListener(            new EventListener(Event e){                //this对象(ThisEscape)逸出,仅当ThisEscape构造函数返回时this对象才算完整,                //此处发布不完整的this对象(对象可能没有构造完成,就共享给其他线程使用)                doSomething(e);            }        );    }    void doSomething(Event e){}}</code></pre><ul><li><strong>使用工厂方法防止this引用在构造过程中逸出</strong></li></ul><pre><code>/** * 使用工厂方法防止this引用在构造过程中逸出 */public class SafeListener{    //必须用final修饰    private final EventListener listener;    private SafeListener() {        listener = new EventListener() {            public void onEvent(Event e){                doSomething(e);            }        };    }    void doSomething(Event e){}    //工厂方法    public static SafeListener newInstance(){        //先创建完整的对象(this)        SafeListener safe = new SafeListener();        //再将(this)发布使用        source.registerListener(safe.listener);        return safe;    }}</code></pre><h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><blockquote><p>多线程间不共享数据,就不需要同步,称为线程封闭</p></blockquote><ol><li><p><strong>Ad-hoc线程封闭</strong></p><p>完全由实现着控制的线程封闭,非常脆弱,没有任何一种语言特性能将对象封闭到目标线程上</p></li><li><p><strong>栈封闭</strong> </p><p>局部变量就为栈封闭,局部变量是不被多个线程共享的,局部变量封闭在执行线程中,位于执行线程的栈中,其他线程无法访问,优于Ad-hoc封闭</p></li><li><p><strong>ThreadLocal类</strong></p><p>使用ThreadLocal类可以实现线程封闭,ThredLocal使得各个线程都能够保持各自独立的一个对象,每个线程都会重新创建一个对象与线程绑定(以空间换时间),而线程是否安全取决于初始化方法中你如何创建该对象.(使用ThreadLocal可以达到线程内全局变量效果)</p></li></ol><pre><code>    private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;(){        //重写初始化方法(为每个线程创建单独对象进行绑定时调用,        //是否线程安全(达到线程封闭效果)取决于初始化方法如何创建对象)        @Override        protected Connection initialValue() {            //返回一个新的数据库链接(Connection)对象            return DriverManager.getConnection(DB_URL);        }    };    //获取连接对象,在多线程中使用同一个对象调用该方法,    //则会每个线程获取一个独立的Connection对象与线程绑定(K,V)形式绑定    public static Connection getConnection(){        return connectionHolder.get();    }</code></pre><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><ol><li><strong>不可变对象一定是线程安全的</strong><ul><li>对象创建后其状态就不能修改</li><li>对象的所有域是final类型</li><li>对象是正确创建的(创建期间,this引用没有逸出)</li></ul></li></ol><h4 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h4><ul><li><strong>不安全的发布</strong></li></ul><pre><code>    //不安全的发布(由于可能指令重排序,不能保证发布时对象的完整性)    //1.可使用final修饰解决,参考final内存语义    //2.或者保证Holder类不可变,也可以安全发布    public Holder holder;    public void initialize(){        //创建对象时,可能存在指令重排序        holder = new Holder(42);    }</code></pre><pre><code>public class Holder {    //问题并不在本类,但是解决不安全发布导致的问题的另一种方式就是该类对象不可变,    //因此使用final修饰n即可,(参考final内存语义)    private int n;    public Holder(int n) {        this.n = n;    }    public void assertSanity() {        if (n != n)            throw new AssertionError("This statement is false.");    }}</code></pre><ul><li><strong>安全发布的常用模式</strong><ul><li>在静态初始化函数中初始化一个对象引用(JVM在类初始化阶段创建,JVM内部存在着同步机制,由jvm保证安全发布)</li><li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中(可见性,原子性)</li><li>将对象引用保存到正确构造对象的final类型域中(参考final内存语义)</li><li>对象的引用保存到一个由锁保护的域中(同步处理,如同步容器)</li></ul></li><li><strong>并发程序中使用共享对象,可用的一些策略</strong><ul><li><strong>线程封闭:</strong> 对象被封闭在线程内,只能由这个线程修改</li><li><strong>只读共享:</strong> 共享的只读对象包含不可变对象,和事实不可变对象</li><li><strong>线程安全共享:</strong> 线程安全的对象在其内部实现同步</li><li><strong>保护对象:</strong> 被保护的对象只能通过持有特定的锁来访问</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据压缩</title>
      <link href="/2019/07/30/DataCompress/"/>
      <url>/2019/07/30/DataCompress/</url>
      
        <content type="html"><![CDATA[<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><blockquote><p>在此主要介绍使用Huffman编码压缩和LZW压缩算法</p></blockquote><h4 id="1-Huffman压缩-霍夫曼压缩"><a href="#1-Huffman压缩-霍夫曼压缩" class="headerlink" title="1.Huffman压缩(霍夫曼压缩)"></a>1.Huffman压缩(霍夫曼压缩)</h4><h5 id="1-1-BitBuffer辅助类-按bit位处理字节数组"><a href="#1-1-BitBuffer辅助类-按bit位处理字节数组" class="headerlink" title="1.1.BitBuffer辅助类 - 按bit位处理字节数组"></a>1.1.BitBuffer辅助类 - 按bit位处理字节数组</h5><pre><code>/** * BitterBuffer * 按bit位处理字节数组,在此仅实现使用到的方法 */public class BitBuffer {    private long mark = -1;    private long position = 0;    private long limit;    private long capacity;    private byte[] hb;    public BitBuffer(int byteCapacity) {        this.hb = new byte[byteCapacity];        this.limit = (long)byteCapacity &lt;&lt; 3;        this.capacity = limit;    }    private BitBuffer(byte[] array,long bitLength){        this.hb = array;        this.limit = bitLength;        this.capacity = limit;    }    public static BitBuffer wrap(byte[] array, long bitLength){        return new BitBuffer(array,bitLength);    }    //byte转无符号    private int toUnsigned(byte value){ return value &lt; 0 ? value &amp; 0xff : value; }    //转ByteBuffer    public ByteBuffer toByteBuffer(){        int length = (int) ((position &amp; 7) == 0 ? position &gt;&gt;&gt; 3 : (position &gt;&gt;&gt; 3) + 1);        ByteBuffer byteBuffer = ByteBuffer.wrap(hb,0,length);        return byteBuffer;    }    //获取底层数组    public byte[] array(){ return hb; }    //取出bits位的值返回    public long get(int bits){        if(position + bits &gt; limit) throw new RuntimeException("超出BitBuffer范围无法取出");        if(bits &gt; 64) throw new RuntimeException("单次取出超过64bit位,无法取出");        int index = (int) (position &gt;&gt;&gt; 3);        int remain = (int)(8 - (position &amp; 7));        //更新position        position += bits;        int num = remain - bits;        if(num &gt;= 0) return (toUnsigned(hb[index]) &gt;&gt;&gt; num) &amp; ((1 &lt;&lt; bits) - 1);        else{            long code = toUnsigned(hb[index]) &amp; ((1 &lt;&lt; remain) - 1);            return get(code,-num,index+1);        }    }    private long get(long code,int bits,int index){        if(bits &lt;= 8){            int num = 8 - bits;            int tail = (toUnsigned(hb[index]) &gt;&gt;&gt; num) &amp; ((1 &lt;&lt; bits) - 1);            return (code &lt;&lt; bits) | tail;        }        code = (code &lt;&lt; 8) | toUnsigned(hb[index]);        return get(code,bits-8,index+1);    }    //将code的bits位(低位-&gt;高位数bits位)放入    public void put(long code,int bits){        if(position + bits &gt; limit) throw new RuntimeException("超出BitBuffer范围无法取出");        if(bits &gt; 64) throw new RuntimeException("单次放入超过64bit位,无法放入");        int index = (int)(position &gt;&gt;&gt; 3);        int remain = (int)(8 - (position &amp; 7));        //更新position        position += bits;        int num = remain - bits;        if(num &gt;= 0) hb[index] |= code &lt;&lt; num;        else{            hb[index] |= code &gt;&gt;&gt; -num;            put(code,-num,index+1);        }    }    private void put(long code,int bits,int index){        if(bits &lt;= 8){            hb[index] |= code &lt;&lt; 8-bits;            return;        }        hb[index] |= code &gt;&gt;&gt; (bits-=8);        put(code,bits,index+1);    }    public boolean hasRemaining(){ return position &lt; limit; }    //获取当前position值    public long position(){ return position; }    //设置当前position值    public BitBuffer position(long newPosition){        if ((newPosition &gt; limit) || (newPosition &lt; 0))            throw new IllegalArgumentException();        position = newPosition;        if (mark &gt; position) mark = -1;        return this;    }    public long remaining(){ return limit-position; }}</code></pre><h5 id="1-2-Huffman压缩"><a href="#1-2-Huffman压缩" class="headerlink" title="1.2.Huffman压缩"></a>1.2.Huffman压缩</h5><pre><code>/** * Huffman压缩 * 概述: 通过huffman编码来重新表示字符,使得出现频率高的字符编码短,出现少的字符编码长 *      整体来说,所需的总的bit位是减少的,但对于字符频率均匀的数据几乎没有压缩效果 * 实现: 压缩后头部第1个字节存储压缩后结尾长度(结尾时可能一个字节没占满), *      紧接着4个字节存储压缩后字节长度(对于大文件分批次构建不同huffman树进行压缩,确定长度,可以分批次解压) * 细节: 分别使用bio与nio实现,解压时使用多线程并行优化 */public class Huffman {    private int max = 1 &lt;&lt; 24; //单次最大读取字节数,对nio性能影响大(ByteBuffer大小影响)    private int R = 256;//码表范围    private int bufferLength = 8192; //写入时缓冲区大小8K    //huffman节点类    private class Node implements Comparable&lt;Node&gt;{        private char ch;        private int freq;        private Node left;        private Node right;        public Node(char ch, int freq, Node left, Node right) {            this.ch = ch;            this.freq = freq;            this.left = left;            this.right = right;        }        public boolean isLeaf(){            return left == null &amp;&amp; right == null;        }        @Override        public int compareTo(Node o) { return this.freq - o.freq; }    }    //压缩: 使用bio    public void compress(InputStream in, OutputStream out){        int length;        byte[] buff = null;        try{            while (true) {                //对于大文件分批次构建huffman树进行压缩                length = (length = in.available()) &gt; max ? max : length;                if(buff == null) buff = new byte[length];                length = in.read(buff);                if(length == -1 || length == 0) break; //读取结束                //统计频率                int[] freq = new int[R];                for (int i = 0; i &lt; length; ++i)                    freq[toUnsigned(buff[i])]++;                //创建huffman树                Node root = buildTrie(freq);                //生成编码表(是用long类型,防止code超过范围)                long[] st = new long[R];                buildCodeTable(root, st, 0L, 0);                //写入huffman树                BitBuffer bitBuffer = new BitBuffer(length+(R &lt;&lt; 1));                bitBuffer.position(40);//第一个字节标记压缩数据末尾bit数,后面4个字节记录压缩后字节长度                writeTrie(root,bitBuffer);                //写入压缩数据                long mixCode,code;                int bit;                for(int i = 0;i&lt;length;++i){                    mixCode = st[toUnsigned(buff[i])];                    bit = (int) (mixCode &amp; 0xff);                    code = mixCode &gt;&gt;&gt; 8;                    bitBuffer.put(code,bit);                }                //维护头部5字节                long gap = bitBuffer.position() - 40;                byte tail = (byte) (gap &amp; 7);                //压缩数据长度(不包含头部长度5)                int compressLength = (int) (tail == 0 ? gap &gt;&gt;&gt; 3 : (gap &gt;&gt;&gt; 3) + 1);                long position = bitBuffer.position();                bitBuffer.position(0);                bitBuffer.put(tail,8);                bitBuffer.put(compressLength &gt;&gt;&gt; 16,16);                bitBuffer.put(compressLength,16);                //写入压缩数据                byte[] buf = bitBuffer.array();                int maxLength = (int) ((position &amp; 7) == 0 ? position &gt;&gt;&gt; 3 : (position &gt;&gt;&gt; 3) + 1);                //分段写入                for(int k = 0;k&lt;maxLength;k+=bufferLength){                    if(k + bufferLength &gt; maxLength)                        out.write(buf,k,maxLength - k);                    else                        out.write(buf,k,bufferLength);                }            }        } catch (IOException e){            e.printStackTrace();        } finally {            try {                out.close();                in.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    //压缩: 使用nio    public void nioCompress(FileInputStream in, FileOutputStream out){        long length = 0;        int capacity;        try (FileChannel channel = in.getChannel();FileChannel outChannel = out.getChannel()) {            long size = channel.size();            //大文件分段压缩            while(length &lt; size){                capacity = (int) ((length += max) &lt;= size ? max : size - length + max);                MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_ONLY,length-max,capacity);                //统计频率                int[] freq = new int[R];                for (int i = 0; i &lt; capacity; ++i)                    freq[toUnsigned(mappedByteBuffer.get())]++;                //创建huffman树                Node root = buildTrie(freq);                //生成编码表(是用long类型,防止编码过长)                long[] st = new long[R];                buildCodeTable(root, st, 0L, 0);                //写入huffman树                BitBuffer bitBuffer = new BitBuffer(capacity+(R &lt;&lt; 1));                bitBuffer.position(40);//第一个字节标记压缩数据末尾bit数,后面4个字节记录压缩后字节长度                writeTrie(root,bitBuffer);                //压缩数据放入字节数组                long mixCode,code;                int bit;                mappedByteBuffer.flip();                for(int i = 0;i&lt;capacity;++i){                    mixCode = st[toUnsigned(mappedByteBuffer.get())];                    bit = (int) (mixCode &amp; 0xff);                    code = mixCode &gt;&gt;&gt; 8;                    bitBuffer.put(code,bit);                }                //维护头部5字节                long gap = bitBuffer.position() - 40;                byte tail = (byte) (gap &amp; 7);                //压缩数据长度(不包含头部长度5)                int compressLength = tail == 0 ? (int)(gap &gt;&gt;&gt; 3) : (int)((gap &gt;&gt;&gt; 3) + 1);                long position = bitBuffer.position();                bitBuffer.position(0);                bitBuffer.put(tail,8);                bitBuffer.put(compressLength &gt;&gt;&gt; 16,16);                bitBuffer.put(compressLength,16);                //写入压缩数据                bitBuffer.position(position);                ByteBuffer byteBuffer = bitBuffer.toByteBuffer();                outChannel.write(byteBuffer);            }        } catch(IOException e){            e.printStackTrace();        }    }    //解压: 使用bio    public void expand(InputStream in,OutputStream out){        //确定线程数与容量        int capacity = Runtime.getRuntime().availableProcessors();        LinkedBlockingQueue&lt;Future&lt;ByteBuffer&gt;&gt; blockingQueue = new LinkedBlockingQueue&lt;&gt;(capacity);        CountDownLatch latch = new CountDownLatch(1); //闭锁: 作用等待数据写入线程结束再放行        //数据写入线程: 负责将解压数据写入        Thread thread = new Thread(() -&gt;{            try {                while(!blockingQueue.isEmpty()) {                    Future&lt;ByteBuffer&gt; future = blockingQueue.poll();                    ByteBuffer byteBuffer = future.get();                    //写入                    byte[] buf = byteBuffer.array();                    int maxLength = byteBuffer.limit();                    //分段写入                    for(int k = 0;k&lt;maxLength;k+=bufferLength){                        if(k + bufferLength &gt; maxLength)                            out.write(buf,k,maxLength - k);                        else                            out.write(buf,k,bufferLength);                    }                }                latch.countDown();            } catch (Exception e) { //异常不做处理                e.printStackTrace();            }        });        try {            //解压线程池: 负责解压数据            ExecutorService executor = Executors.newWorkStealingPool(capacity);            while(true) {                //大文件可能分多段压缩,确定当前段长度                byte[] head = new byte[5];                int length = in.read(head); //读取头部信息                if(length == -1 || length == 0) break;                ByteBuffer headByte = ByteBuffer.wrap(head);                int tailBit = headByte.get();//获取尾部bit位                if (length != 5) throw new RuntimeException("头部信息缺失");                length = headByte.getInt();//获取到当前段压缩字节长度                byte[] buff = new byte[length]; //读取当前压缩段数据                //读取压缩段                long len = in.read(buff);                if(length == -1 || length == 0) break;                if (len != length) throw new RuntimeException("读取压缩信息失败");                //解压并写入数据到byte数组: 并行提高效率                Future&lt;ByteBuffer&gt; future = executor.submit(()-&gt;{                    long bitLength = tailBit == 0 ? len &lt;&lt; 3 : (len &lt;&lt; 3) + tailBit - 8;                    BitBuffer bitBuffer = BitBuffer.wrap(buff,bitLength);                    //读取huffman树                    Node root = readTrie(bitBuffer);                    //解压后先写入byte数组                    byte[] buf = new byte[max];                    int bufIndex = 0;                    //特殊处理: root为叶子节点,仅一个节点                    if(root.isLeaf()){                        long p = bitBuffer.position();                        long limit = bitBuffer.limit();                        for(;p&lt;limit;p++)                            buf[bufIndex++] = (byte)root.ch;                        return ByteBuffer.wrap(buf,0,bufIndex);                    }                    //解码                    while(bitBuffer.hasRemaining()){                        Node x = root;                        //此处每次读取1bit位处理,效率低,多线程并行优化                        while(!x.isLeaf() &amp;&amp; bitBuffer.hasRemaining()){                            boolean bit = bitBuffer.get(1) == 1;                            if(bit) x = x.right;                            else x = x.left;                        }                        buf[bufIndex++] = (byte) x.ch;                    }                    return ByteBuffer.wrap(buf,0,bufIndex);                });                blockingQueue.put(future); //将任务放入阻塞队列,put放入速度必定比take处理速度快                if(!thread.isAlive()) thread.start(); //启动数据写入线程            }            latch.await();        } catch (Exception e) {//异常不做处理            e.printStackTrace();        } finally {            try {                out.close();                in.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    //解压: 使用nio    public void nioExpand(FileInputStream in,FileOutputStream out){        //确定线程数与容量        int capacity = Runtime.getRuntime().availableProcessors();        LinkedBlockingQueue&lt;Future&lt;ByteBuffer&gt;&gt; blockingQueue = new LinkedBlockingQueue&lt;&gt;(capacity);        CountDownLatch latch = new CountDownLatch(1); //闭锁: 作用等待数据写入线程结束再放行        //数据写入线程: 负责将解压数据写入        Thread thread = new Thread(() -&gt;{            try {                FileChannel outChannel = out.getChannel();                while(!blockingQueue.isEmpty()) {                    Future&lt;ByteBuffer&gt; future = blockingQueue.poll();                    ByteBuffer byteBuffer = future.get();                    //写入                    outChannel.write(byteBuffer);                }                latch.countDown();            } catch (Exception e) { //异常不做处理                e.printStackTrace();            }        });        try(FileChannel inChannel = in.getChannel()){            //解压线程池: 负责解压数据            ExecutorService executor = Executors.newWorkStealingPool(capacity);            while(true) {                //大文件可能分多段压缩,确定当前段长度                byte[] head = new byte[5];                ByteBuffer headByte = ByteBuffer.wrap(head);                int length = inChannel.read(headByte);                if(length == -1 || length == 0) break;                headByte.flip();                int tailBit = headByte.get();//获取尾部bit位                if (length != 5) throw new RuntimeException("头部信息缺失");                length = headByte.getInt();//获取到当前段压缩字节长度                byte[] buff = new byte[length]; //读取当前压缩段数据                ByteBuffer dataByte = ByteBuffer.wrap(buff);                long len = inChannel.read(dataByte);                if(length == -1 || length == 0) break;                if (len != length) throw new RuntimeException("读取压缩信息失败");                //解压并写入数据到byte数组: 并行提高效率                Future&lt;ByteBuffer&gt; future = executor.submit(()-&gt;{                    long bitLength = tailBit == 0 ? len &lt;&lt; 3 : (len &lt;&lt; 3) + tailBit - 8;                    BitBuffer bitBuffer = BitBuffer.wrap(buff,bitLength);                    //读取huffman树                    Node root = readTrie(bitBuffer);                    //解压后先写入byte数组                    byte[] buf = new byte[max];                    int bufIndex = 0;                    //特殊处理: root为叶子节点,仅一个节点                    if(root.isLeaf()){                        long p = bitBuffer.position();                        long limit = bitBuffer.limit();                        for(;p&lt;limit;p++)                            buf[bufIndex++] = (byte)root.ch;                        return ByteBuffer.wrap(buf,0,bufIndex);                    }                    //解码                    while(bitBuffer.hasRemaining()){                        Node x = root;                        //此处每次读取1bit位处理,效率低,多线程并行优化                        while(!x.isLeaf() &amp;&amp; bitBuffer.hasRemaining()){                            boolean bit = bitBuffer.get(1) == 1;                            if(bit) x = x.right;                            else x = x.left;                        }                        buf[bufIndex++] = (byte)x.ch;                    }                    return ByteBuffer.wrap(buf,0,bufIndex);                });                blockingQueue.put(future); //将任务放入阻塞队列,put放入速度比take处理速度快                if(!thread.isAlive()) thread.start(); //启动数据写入线程            }            latch.await();        } catch(Exception e){            e.printStackTrace();        }    }    //压缩: 文件夹/文件    public void compress(File inFile,FileOutputStream out){        Queue&lt;Map.Entry&lt;Integer,File&gt;&gt; queue = new ArrayDeque&lt;&gt;();        Queue&lt;File&gt; fileQueue = new ArrayDeque&lt;&gt;();        queue.offer(new AbstractMap.SimpleEntry&lt;&gt;(-1,inFile));        //对文件名再编码: 防止同名文件名导致的问题        Integer dKey = 0;//文件夹,被3整除        Integer fKey = 1;//非空文件,余1        Integer eKey = 2;//空文件,余2        Integer key; //当前文件对应的编码        StringBuilder table = new StringBuilder();        StringBuilder paths = new StringBuilder();        while(!queue.isEmpty()){            Map.Entry&lt;Integer,File&gt; entity = queue.poll();            Integer parentKey = entity.getKey();            File file = entity.getValue();            if(file.isDirectory()){                key = dKey;                dKey+=3;                File[] files = file.listFiles();                for(File f : files) queue.offer(new AbstractMap.SimpleEntry&lt;&gt;(key,f));            }            else {                if (file.length() == 0) {//空文件                    key = eKey;                    eKey += 3;                } else {                    key = fKey;                    fKey += 3;                    fileQueue.offer(file);                }            }            paths.append(parentKey);            paths.append("/");            paths.append(key);            paths.append("?");            table.append(key);            table.append(":");            table.append(file.getName());            table.append("&lt;");        }        table.append("&gt;");        table.append(paths);        try{            //记录文件名长度(int值)+文件名            byte[] pathsBuff = table.toString().getBytes();            int len = pathsBuff.length;            byte[] head = new byte[]{(byte)(len &gt;&gt;&gt; 24),(byte)(len &gt;&gt;&gt; 16),(byte)(len &gt;&gt;&gt; 8),(byte)len};            out.write(head);            out.write(pathsBuff);            //依次压缩文件            while(!fileQueue.isEmpty()){                File file = fileQueue.poll();                long length = 0;                int capacity;                try(FileChannel channel = new FileInputStream(file).getChannel()){                    long size = channel.size();                    //大文件分段压缩                    while(length &lt; size){                        capacity = (int) ((length += max) &lt;= size ? max : size - length + max);                        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_ONLY,length-max,capacity);                        //统计频率                        int[] freq = new int[R];                        for (int i = 0; i &lt; capacity; ++i)                            freq[toUnsigned(mappedByteBuffer.get())]++;                        //创建huffman树                        Node root = buildTrie(freq);                        //生成编码表(是用long类型,防止编码过长)                        long[] st = new long[R];                        buildCodeTable(root, st, 0L, 0);                        //写入huffman树                        BitBuffer bitBuffer = new BitBuffer(capacity+(R &lt;&lt; 1));                        bitBuffer.position(40);//第一个字节标记压缩数据末尾bit数,后面4个字节记录压缩后字节长度                        writeTrie(root,bitBuffer);                        //压缩数据放入字节数组                        long mixCode,code;                        int bit;                        mappedByteBuffer.flip();                        for(int i = 0;i&lt;capacity;++i){                            mixCode = st[toUnsigned(mappedByteBuffer.get())];                            bit = (int) (mixCode &amp; 0xff);                            code = mixCode &gt;&gt;&gt; 8;                            bitBuffer.put(code,bit);                        }                        //维护头部5字节                        long gap = bitBuffer.position() - 40;                        byte tail = (byte) (gap &amp; 7);                        //压缩数据长度(不包含头部长度5)                        int compressLength = tail == 0 ? (int)(gap &gt;&gt;&gt; 3) : (int)((gap &gt;&gt;&gt; 3) + 1);                        long position = bitBuffer.position();                        bitBuffer.position(0);                        //若到文件末尾时标记0001                        if(length &gt;= size) {                            bitBuffer.put(1,4);                            bitBuffer.put(tail,4);                        }else{                            bitBuffer.put(tail,8);                        }                        bitBuffer.put(compressLength &gt;&gt;&gt; 16,16);                        bitBuffer.put(compressLength,16);                        //写入压缩数据                        byte[] buf = bitBuffer.array();                        int maxLength = (int) ((position &amp; 7) == 0 ? position &gt;&gt;&gt; 3 : (position &gt;&gt;&gt; 3) + 1);                        //分段写入                        for(int k = 0;k&lt;maxLength;k+=bufferLength){                            if(k + bufferLength &gt; maxLength)                                out.write(buf,k,maxLength - k);                            else                                out.write(buf,k,bufferLength);                        }                    }                }catch (Exception e){                    e.printStackTrace();                }            }        } catch (Exception e){            e.printStackTrace();        } finally {            try {                out.close();                System.gc();//通知尽快释放MappedByteBuffer            } catch (IOException e) {                e.printStackTrace();            }        }    }    //解压: 文件夹/文件    public void expand(FileInputStream in,File outFile){        try{            byte[] headBuff = new byte[4];            int len = in.read(headBuff);            if(len != 4) throw new RuntimeException("头部信息缺失");            ByteBuffer headByte = ByteBuffer.wrap(headBuff);            //获取文件名字符串长度            int length = headByte.getInt();            byte[] pathByte = new byte[length];            //读取文件名字符串            len = in.read(pathByte);            if (len != length) throw new RuntimeException("读取压缩信息失败");            String[] arrs = new String(pathByte).split("&gt;");            HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;&gt;(); //值: 文件名            Queue&lt;Map.Entry&lt;Integer,File&gt;&gt; dirsQueue = new ArrayDeque&lt;&gt;();//保存文件夹键值            //创建对照表            for(String e : arrs[0].split("&lt;")){                String[] entity = e.split(":");                hashMap.put(Integer.parseInt(entity[0]),entity[1]);            }            //创建文件            File f;            Integer key = -1;            for(String e : arrs[1].split("\\?")){                String[] entity = e.split("/");                int parentKey = Integer.parseInt(entity[0]);                int childKey = Integer.parseInt(entity[1]);                int mod = childKey % 3;                if(parentKey == -1 &amp;&amp; mod == 0){ //处理文件夹根目录                    f = new File(outFile,hashMap.get(childKey));                    f.mkdir();                    dirsQueue.offer(new AbstractMap.SimpleEntry&lt;&gt;(childKey,f));                    outFile = f;                    key = childKey;                    continue;                }                Map.Entry&lt;Integer,File&gt; entry = null;                while(key != parentKey){                    entry = dirsQueue.poll();                    key = entry.getKey();                }                outFile = entry == null ? outFile : entry.getValue();                //处理                f = new File(outFile,hashMap.get(childKey));                if(mod == 0){ //文件夹                    f.mkdir();                    dirsQueue.offer(new AbstractMap.SimpleEntry&lt;&gt;(childKey,f));                }                else if(mod == 1){ //文件直接解压                    f.createNewFile();                    expandFile(in,new FileOutputStream(f));                }                else f.createNewFile(); //空文件            }        } catch (Exception e){            e.printStackTrace();        } finally {            try {                in.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    public void expandFile(InputStream in,OutputStream out){        //确定线程数与容量        int capacity = Runtime.getRuntime().availableProcessors();        LinkedBlockingQueue&lt;Future&lt;ByteBuffer&gt;&gt; blockingQueue = new LinkedBlockingQueue&lt;&gt;(capacity);        CountDownLatch latch = new CountDownLatch(1); //闭锁: 作用等待数据写入线程结束再放行        //数据写入线程: 负责将解压数据写入        Thread thread = new Thread(() -&gt;{            try {                while(!blockingQueue.isEmpty()) {                    Future&lt;ByteBuffer&gt; future = blockingQueue.poll();                    ByteBuffer byteBuffer = future.get();                    //写入                    byte[] buf = byteBuffer.array();                    int maxLength = byteBuffer.limit();                    //分段写入                    for(int k = 0;k&lt;maxLength;k+=bufferLength){                        if(k + bufferLength &gt; maxLength)                            out.write(buf,k,maxLength - k);                        else                            out.write(buf,k,bufferLength);                    }                }                latch.countDown();            } catch (Exception e) { //异常不做处理                e.printStackTrace();            }        });        try {            //解压线程池: 负责解压数据            ExecutorService executor = Executors.newWorkStealingPool(capacity);            while(true) {                //大文件可能分多段压缩,确定当前段长度                byte[] head = new byte[5];                int length = in.read(head); //读取头部信息                if(length == -1 || length == 0) break;                ByteBuffer headByte = ByteBuffer.wrap(head);                int bits = headByte.get();//获取尾部bit位                boolean flag = false;                if(bits &gt; 7) {                    bits &amp;= 0xf;                    flag = true;                }                int tailBit = bits;//获取尾部bit位                if (length != 5) throw new RuntimeException("头部信息缺失");                length = headByte.getInt();//获取到当前段压缩字节长度                byte[] buff = new byte[length]; //读取当前压缩段数据                //读取压缩段                long len = in.read(buff);                if(length == -1 || length == 0) break;                if (len != length) throw new RuntimeException("读取压缩信息失败");                //解压并写入数据到byte数组: 并行提高效率                Future&lt;ByteBuffer&gt; future = executor.submit(()-&gt;{                    long bitLength = tailBit == 0 ? len &lt;&lt; 3 : (len &lt;&lt; 3) + tailBit - 8;                    BitBuffer bitBuffer = BitBuffer.wrap(buff,bitLength);                    //读取huffman树                    Node root = readTrie(bitBuffer);                    //解压后先写入byte数组                    byte[] buf = new byte[max];                    int bufIndex = 0;                    //特殊处理: root为叶子节点,仅一个节点                    if(root.isLeaf()){                        long p = bitBuffer.position();                        long limit = bitBuffer.limit();                        for(;p&lt;limit;p++)                            buf[bufIndex++] = (byte)root.ch;                        return ByteBuffer.wrap(buf,0,bufIndex);                    }                    //解码                    while(bitBuffer.hasRemaining()){                        Node x = root;                        //此处每次读取1bit位处理,效率低,多线程并行优化                        while(!x.isLeaf() &amp;&amp; bitBuffer.hasRemaining()){                            boolean bit = bitBuffer.get(1) == 1;                            if(bit) x = x.right;                            else x = x.left;                        }                        buf[bufIndex++] = (byte) x.ch;                    }                    return ByteBuffer.wrap(buf,0,bufIndex);                });                blockingQueue.put(future); //将任务放入阻塞队列,put放入速度必定比take处理速度快                if(!thread.isAlive()) thread.start(); //启动数据写入线程                if(flag) break;            }            latch.await();        } catch (Exception e) {//异常不做处理            e.printStackTrace();        } finally {            try {                out.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    //byte转无符号    private int toUnsigned(byte value){ return value &lt; 0 ? value &amp; 0xff : value; }    //根据统计的频率freq构建huffman树    private Node buildTrie(int[] freq){        PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;();        for(char c=0;c&lt;R;++c)            if (freq[c] &gt; 0) pq.offer(new Node(c, freq[c], null, null));        while(pq.size() &gt; 1){            Node left = pq.poll();            Node right = pq.poll();            Node parent = new Node('\0',left.freq+right.freq,left,right);            pq.offer(parent);        }        return pq.poll();    }    //根据huffman树构建huffman码表,st为码表,int值的前3个字节保存码值,最后1个字节保存码值长度    private void buildCodeTable(Node x,long[] st,long code,int length){        if(!x.isLeaf()){            code &lt;&lt;= 1;            buildCodeTable(x.left,st,code,length+1);            buildCodeTable(x.right,st,code+1,length+1);        }        else if(length == 0){ //只有一个根节点            st[x.ch] = 1&lt;&lt;8|1;        }        else {            if (length &gt; 56) throw new RuntimeException("错误,编码过长超过long[] st无法保存码表");            st[x.ch] = code&lt;&lt;8|length; //7个字节(码值)+1个字节(码值长度)        }    }    //将huffman树存储到字节数组中,非叶子节点0,叶子节点1后面紧跟8bit位为叶子节点的码值    private void writeTrie(Node x,BitBuffer buff){        if(x.isLeaf()){            buff.put(1,1);            buff.put(x.ch,8);            return;        }        else buff.position(buff.position()+1);        writeTrie(x.left,buff);        writeTrie(x.right,buff);    }    //读取头部存储的huffman树并创建(读取到叶子节点会自动递归结束)    private Node readTrie(BitBuffer buff){        boolean isLeaf = buff.get(1) == 1;        if(isLeaf){            Node node = new Node((char)buff.get(8),-1,null,null);            return node;        }        else return new Node('\0',-1,readTrie(buff),readTrie(buff));    }}</code></pre><h4 id="2-LZW算法"><a href="#2-LZW算法" class="headerlink" title="2.LZW算法"></a>2.LZW算法</h4><blockquote><p>使用到的三向单词查找树(仅保留用到的方法)-<strong>稍作改动直接处理字节数组</strong></p></blockquote><pre><code>/** * 稍作改动的三向字符串查找树 * 概述: 稍作改动可以直接处理字符数组 */public class TST&lt;V&gt; {    private Node&lt;V&gt; root;//根节点    private class Node&lt;V&gt;{  //节点        private char c; //字符        private Node&lt;V&gt; left; //左连接 &lt;c        private Node&lt;V&gt; mid;  //中连接 =c        private Node&lt;V&gt; right;//右连接 &gt;c        private V value;    //保存键值    }    //获取: 键-buff[begin,end]组成的字符串    public V get(byte[] buff,int begin,int end){        Node x = get(root,buff,begin,end);        if(x != null) return (V)x.value;        if(x == null) System.out.println("x为null" + begin + ":" + end);        return null;    }    private Node get(Node x,byte[] buff,int begin,int end){        if(buff == null || buff.length == 0 || begin &gt; end) return null;        if(x == null) {            System.out.println("x.为null" + begin+":"+end);            return null;        }        char c = toUnsigned(buff[begin]);        if(x.c &gt; c) return get(x.left,buff,begin,end);        else if(x.c &lt; c) return get(x.right,buff,begin,end);        else if(begin &lt; end) return get(x.mid,buff,begin+1,end);        else {            if(x.value == null) System.out.println("begin:"+ begin+" end:"+end);            return x;        }    }    //插入: 键-byte数组buff[begin,end]组成的字符串,值-value    public void put(byte[] buff,int begin,int end,V value){        if(buff == null || buff.length == 0 || begin &gt; end) return;        root = put(root,buff,begin,end,value);    }    private Node put(Node x,byte[] buff,int begin,int end,V value){        char c = toUnsigned(buff[begin]);        if(x == null){            x = new Node();            x.c = c;        }        if(x.c &gt; c) x.left = put(x.left,buff,begin,end,value);        else if(x.c &lt; c) x.right = put(x.right,buff,begin,end,value);        else if(begin &lt; end) x.mid = put(x.mid,buff,begin+1,end,value);        else x.value = value;        return x;    }    //获取最长前缀并所在byte数组的索引    public int longestPrefixof(byte[] buff,int begin,int end){        if(buff == null || buff.length == 0 || begin &gt; end) return -1;        int index = 0;        Node x = root;        while(x != null &amp;&amp; begin &lt;= end){            char c = toUnsigned(buff[begin]);            if(x.c &gt; c) x = x.left;            else if(x.c &lt; c) x = x.right;            else{                if(x.value != null) index = begin;                begin++;                x = x.mid;            }        }        return index;    }    //插入    public void put(String key, V value){        if(key == null || key.length() == 0) return;        root = put(root,key,value,0);    }    /**插入: 与获取思路相同,只是遇到空节点创建新节点,到末尾时保存键值*/    private Node put(Node x,String key,V value,int d){        char c = key.charAt(d);        if(x == null) { //没有节点就创建            x = new Node();            x.c = c;        }        if(x.c &gt; c) x.left = put(x.left,key,value,d);        else if(x.c &lt; c) x.right = put(x.right,key,value,d);        else if(d &lt; key.length()-1) x.mid = put(x.mid,key,value,d+1);        else x.value = value;   //末尾时保存键值        return x;    }    //byte转无符号    private char toUnsigned(byte value){ return (char)(value &lt; 0 ? value &amp; 0xff : value); }}</code></pre><h5 id="2-1-LZW算法-12位定长bit位编码"><a href="#2-1-LZW算法-12位定长bit位编码" class="headerlink" title="2.1.LZW算法-12位定长bit位编码"></a>2.1.LZW算法-12位定长bit位编码</h5><pre><code>/** * LZW算法 * 概述: gif格式用到此算法思想,适合有大量重复值的数据,如果重复数据很少,反而会有反效果 * 实现: 1.使用定长的12bit位码表,码表满时,停止扩展,不适合大文件 *      2.JDK1.7+之后substring方法性能下降,在此直接处理字节数组,不再像算法4中转为字符串处理 *      3.因为要处理字节数组,因此对三向字符串查找树稍作更改,直接处理字符 */public class LZW {    private int buffLength = 8192;    private int R = 256;    private int W = 12;    private int L = 1 &lt;&lt; W;    /** 压缩 **/    public void compress(InputStream in, OutputStream out){        try {            byte[] buff = new byte[in.available()];            int length = in.read(buff);            //基础表            TST&lt;Integer&gt; st = new TST&lt;&gt;(); //稍作更改的三向单词查找树(直接处理字节数组)            for(int i=0;i&lt;R;++i)                st.put(""+(char)i,i);            int code = R+1;            BitBuffer bitBuffer = new BitBuffer(length &lt;&lt; 1);            //压缩            for(int i=0;i&lt;length;){                //获取最长前缀索引                int index = st.longestPrefixof(buff,i,length-1);                //压缩后写入缓冲区                Integer value = st.get(buff,i,index);                bitBuffer.put(value,W);                //扩展表                if(index &lt; length-1 &amp;&amp; code &lt; L) //W位表满之后就不再扩展                    st.put(buff,i,index+1,code++);                i = index + 1;            }            long position = bitBuffer.position();            int len = (int)((position &amp; 7 ) == 0 ? position &gt;&gt;&gt; 3 : (position &gt;&gt;&gt; 3) + 1);            byte[] buf = bitBuffer.array();            //分段写入            for(int k = 0;k&lt;len;k+=buffLength){                if(k + buffLength &gt; len)                    out.write(buf,k,len - k);                else                    out.write(buf,k,buffLength);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                out.close();                in.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    /** 解压 **/    public void expand(InputStream in,OutputStream out){        try {            byte[] buff = new byte[in.available()];            int length = in.read(buff);            String[] st = new String[L]; //确定码表长度,直接使用定长数组存储解码表            int i;            //基础表            for(i=0;i&lt;R;++i)                st[i] = ""+(char)i;            st[i++] = "";            BitBuffer bitBuffer = BitBuffer.wrap(buff,length &lt;&lt; 3);            if(bitBuffer.remaining() &lt; W) return; //达到末尾结束            //先取出第一个编码字符            int codeword = (int) bitBuffer.get(W);            String val = st[codeword]; //解码第一个字符            StringBuilder builder = new StringBuilder(); //存储解码后的字符串            while(true){                builder.append(val);                if(bitBuffer.remaining() &lt; W) break; //达到末尾结束                codeword = (int) bitBuffer.get(W); //读取一个编码字符                String s = st[codeword];                //扩展表                if(i == codeword) s = val+ val.charAt(0); //特殊情况,当前解码字符刚好是下一个要加入码表的字符                if(i &lt; L) st[i++] = val + s.charAt(0);                val = s;                if(builder.length() &gt; buffLength){ //分次写入                    out.write(builder.toString().getBytes("ISO8859-1"));                    builder.delete(0,builder.length());                }            }            out.write(builder.toString().getBytes("ISO8859-1"));        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                out.close();                in.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><h5 id="2-2-LZW算法-从9bit位开始变长编码"><a href="#2-2-LZW算法-从9bit位开始变长编码" class="headerlink" title="2.2.LZW算法-从9bit位开始变长编码"></a>2.2.LZW算法-从9bit位开始变长编码</h5><pre><code>/** * LZW算法 * 概述: gif格式用到此算法思想,适合有大量重复值的数据,如果重复数据很少,反而会有反效果 * 实现: 1.在LZW算法基础上使用变长的编码,从9bit位开始,用完时扩展,并使用最后一位L-1作为变更标记 *      2.JDK1.7+之后substring方法性能下降,在此直接处理字节数组,不再像算法4中转为字符串处理 *      3.压缩性能有待改进 */public class LZW {    private int buffLength = 8192; //缓冲大小8M    private int R = 256; //基本码表    private int W = 9; //从9bit位开始扩展码表    private int maxW = 24; //最大扩展bit位    private int L = 1 &lt;&lt; W; //码表大小    /** 压缩 **/    public void compress(InputStream in, OutputStream out){        try {            byte[] buff = new byte[in.available()];            int length = in.read(buff);            //基础表            TST&lt;Integer&gt; st = new TST&lt;&gt;(); //稍作更改的三向单词查找树(直接处理字节数组)            for(int i=0;i&lt;R;++i)                st.put(""+(char)i,i);            int code = R+1;            BitBuffer bitBuffer = new BitBuffer(length &lt;&lt; 1);            //压缩            for(int i=0;i&lt;length;){                //获取最长前缀索引                int index = st.longestPrefixof(buff,i,length-1);                //压缩后写入缓冲区                Integer value = st.get(buff,i,index);                bitBuffer.put(value,W);                //扩展表                if(index &lt; length-1 &amp;&amp; code &lt; L-1) //W位表没有满就扩展码表                    st.put(buff,i,index+1,code++);                else if(code == L-1){   //L-1标记当前M bit位码表编满,扩展码表为M+1 bit位                    bitBuffer.put(L-1,W);                    if(W == maxW){ //达到最大就重新创建码表                        st = new TST&lt;&gt;();                        for(int k=0;k&lt;R;++k)                            st.put(""+(char)k,k);                        code = R+1;                        W = 9;                    }                    else {  //没有达到最大就增加bit位扩展码表                        code++;                        if (index &lt; length - 1)                            st.put(buff, i, index + 1, code++);                        W++;                    }                    L = 1 &lt;&lt; W;                }                i = index + 1;            }            long position = bitBuffer.position();            int len = (int)((position &amp; 7 ) == 0 ? position &gt;&gt;&gt; 3 : (position &gt;&gt;&gt; 3) + 1);            byte[] buf = bitBuffer.array();            //分段写入            for(int k = 0;k&lt;len;k+=buffLength){                if(k + buffLength &gt; len)                    out.write(buf,k,len - k);                else                    out.write(buf,k,buffLength);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                out.close();                in.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    /** 解压 **/    public void expand(InputStream in,OutputStream out){        try {            byte[] buff = new byte[in.available()];            long length = in.read(buff);            //不确定码表总大小,使用hashMap            HashMap&lt;Integer,String&gt; st = new HashMap&lt;&gt;(L);            int i;            //基础表            for(i=0;i&lt;R;++i)                st.put(i,""+(char)i);            st.put(i++,"");            BitBuffer bitBuffer = BitBuffer.wrap(buff,length &lt;&lt; 3);            if(bitBuffer.remaining() &lt; W) return; //达到末尾结束            //先取出第一个编码字符            int codeword = (int) bitBuffer.get(W);            String val = st.get(codeword); //解码第一个字符            StringBuilder builder = new StringBuilder(); //存储解码后的字符串            while(true){                builder.append(val); //解码后存入StringBuilder                if(bitBuffer.remaining() &lt; W) break; //达到末尾结束                codeword = (int) bitBuffer.get(W); //读取一个编码字符                if(codeword == L-1){ //达到最大码表,增加一bit位或者重置                    if(W == maxW){ //达到最大bit位重置码表                        W = 9;                        L = 1 &lt;&lt; W;                        st = new HashMap&lt;&gt;(L);                        //基础表                        for(i=0;i&lt;R;++i)                            st.put(i,""+(char)i);                        st.put(i++,"");                        if(bitBuffer.remaining() &lt; W) return; //结束                        codeword = (int) bitBuffer.get(W);                        val = st.get(codeword);                        continue;                    }                    else {                        W++;                        L = 1 &lt;&lt; W;                        if(bitBuffer.remaining() &lt; W) return; //结束                        codeword = (int) bitBuffer.get(W);                        i++; //L-1作为标记,不再使用跳过                    }                }                String s = st.get(codeword);                //扩展表                if(i == codeword) s = val+ val.charAt(0); //特殊情况,当前解码字符刚好是下一个要加入码表的字符                if(i &lt; L) st.put(i++,val+s.charAt(0));                val = s; //更新                if(builder.length() &gt; buffLength){ //分次写入                    out.write(builder.toString().getBytes("ISO8859-1"));                    builder.delete(0,builder.length());                }            }            //写入最后部分            out.write(builder.toString().getBytes("ISO8859-1"));        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                out.close();                in.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/07/16/NFA/"/>
      <url>/2019/07/16/NFA/</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote><p>对于任意正则表达式都存在一个与之对应的非确定有限状态自动机(NFA),反之亦然</p></blockquote><h4 id="1-正则匹配"><a href="#1-正则匹配" class="headerlink" title="1.正则匹配"></a>1.正则匹配</h4><pre><code>/** * 正则表达式的模式匹配 * 概述: 每个正则表达式都对应一个NFA,反之亦然 * 思路: 将正则表达式转换为有向图(仅将元字符"(*|)"转换为可直接比较的特定字符),这样就可以直接对字符进行匹配 */public class NFA {    private DiGraph graph; //有向图    private String regexp; //正则表达式    private final int m;   //正则表达式字符数    public NFA(String regexp) {        this.regexp = regexp; //正则表达式        this.m = regexp.length(); //长度        this.graph = new DiGraph(m+1); //0-m状态, m为终态        ArrayDeque&lt;Integer&gt; ops = new ArrayDeque&lt;&gt;(); //使用栈进行括号匹配,遇到'('入栈,遇到')'出栈        for(int i=0;i&lt;m;++i){            int lp = i;            char ch = regexp.charAt(i);            if(ch == '(' || ch == '|') ops.push(i);            else if(ch == ')'){                int or = ops.pop();                if(regexp.charAt(or) == '|'){ //处理或| ,只能处理单个|(改进:直接处理? 额外加上括号?)                    graph.addEdge(or,i);                    lp = ops.pop();                    graph.addEdge(lp,or+1);                }                else if(regexp.charAt(or) == '(')                    lp = or;            }            if(i&lt;m-1 &amp;&amp; regexp.charAt(i+1) == '*'){ //处理闭包*,返回到本身或者进入下一个状态                graph.addEdge(lp,i+1);                graph.addEdge(i+1,lp);            }            if(ch == '(' || ch == '*' || ch == ')') //处理元字符(不能直接比较,将其转换到特定的可比较的字符)                graph.addEdge(i,i+1);        }        if(!ops.isEmpty()) throw new RuntimeException("格式不支持");    }    //整个txt和regexp是否完全匹配(通过有向图可达性(到达特定字符),计算出当前状态所有可能匹配情况)    public boolean recognizes(String txt){        DirectedDFS dfs = new DirectedDFS(graph,0); //有向图深度优先搜索计算可达性        HashSet&lt;Integer&gt; current = new HashSet&lt;&gt;();        HashSet&lt;Integer&gt; match = new HashSet&lt;&gt;();        for(int i=0;i&lt;txt.length();++i){            for(int v=0;v&lt;graph.V();++v)                if(dfs.marked(v)) current.add(v); //所有可达的特定字符            char ch = txt.charAt(i);            if("()*|".indexOf(ch) != -1) throw new RuntimeException("txt中不能包含元字符: "+ch);            for(int v: current){    //匹配所有可能情况                if(v == m) continue;                if(ch == regexp.charAt(v) || ch == '.')                    match.add(v+1);            }            if(match.isEmpty()) return false; //不可达            dfs = new DirectedDFS(graph,match); //深度优先搜索,所有当前匹配的状态match集合可达的下一特定字符            current.clear();            match.clear();        }        for(int v=0;v&lt;graph.V();++v) //匹配到结尾,是否可达终态            if(dfs.marked(v) &amp;&amp; v == m) return true;        return false;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子字符串查找</title>
      <link href="/2019/07/15/StringSearch/"/>
      <url>/2019/07/15/StringSearch/</url>
      
        <content type="html"><![CDATA[<h3 id="子字符串查找"><a href="#子字符串查找" class="headerlink" title="子字符串查找"></a>子字符串查找</h3><blockquote><p>给定一段长度为n的文本txt和一个长度为m的pattern模式串,在文本中找到和该模式匹配的字串</p></blockquote><h4 id="1-BruteForce算法-暴力子字符串查找算法"><a href="#1-BruteForce算法-暴力子字符串查找算法" class="headerlink" title="1.BruteForce算法(暴力子字符串查找算法)"></a>1.BruteForce算法(暴力子字符串查找算法)</h4><pre><code>/** * 暴力子字符串查找:  * 时间复杂度: 一般情况1.1N 最坏情况:MN * 概述:模式串与文本对齐开始查找匹配,失配时,模式串向后移动一位,重新开始查找匹配 */public class BruteForce {    //方案一    public static int search(String pattern,String txt){        int m = pattern.length();        int n = txt.length();        for(int i=0;i&lt;=n-m;++i){            int j;            for(j=0;j&lt;m;++j)                if(txt.charAt(i+j) != pattern.charAt(j)) break; //失配            if(j == m) return i;        }        return -1;    }    //方案二    public static int searchB(String pattern,String txt){        int m = pattern.length();        int n = txt.length();        int i = 0,j = 0;        for(;i&lt;n &amp;&amp; j&lt;m;++i){            if(txt.charAt(i) == pattern.charAt(j)) j++;            else{ //失配                i -= j;                j = 0;            }        }        if(j == m) return i-j;        return -1;    }}</code></pre><h4 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2.KMP算法"></a>2.KMP算法</h4><h5 id="2-1-基于DFA的KMP算法"><a href="#2-1-基于DFA的KMP算法" class="headerlink" title="2.1.基于DFA的KMP算法"></a>2.1.基于DFA的KMP算法</h5><pre><code>/** * Knuth-Morris-Pratt 子字符串查找算法 * 时间复杂度: 一般情况1.1N 最坏情况:2N * 概述: 通过构造DFA方式实现,关键理解DFA的含义 * 特点: 与next数组方式不同(另见本章)时,失配时不会停留在再较当前失配字符,会一直前进不断比较下一个字符 *       dfa[i][j]中i为输入字符(将要与模式串比较的字符),j为当前状态(0~pattern.length()-1),值为比较后进入的下一个状态 * 关键点: 状态也表示最大公共前后缀长度!,遇到失配时需要将模式串移动使公共前后缀对齐,继续比较下一个字符 */public class KMP {    private String pattern; //模式串    private int[][] dfa;    //限定有限状态自动机,dfa[i][j]中i为将输入的字符,j为当前状态,值为将会进入的下一个状态    private int R; //字符编码表长度    public KMP(String pattern){        this.R = 256;        setPattern(pattern);    }    public KMP(String pattern,int R){        this.R = R;        setPattern(pattern);    }    public KMP setPattern(String pattern){        if(pattern == null || "".equals(pattern)) throw new RuntimeException("pattern模式字符串不能为空");        this.pattern = pattern;        int m = pattern.length();        dfa = new int[R][m];        dfa[pattern.charAt(0)][0] = 1; // dfa[i][0] = 0,当匹配时进入下一个状态1        for(int k=0,j=1;j&lt;m;++j){            for(int c=0;c&lt;R;++c)                dfa[c][j] = dfa[c][k]; //失配时,k状态记录了到上一个字符为止匹配的最大公共前后缀长度,重新对齐后,输入当前字符匹配            dfa[pattern.charAt(j)][j] = j+1; //匹配时状态+1            k = dfa[pattern.charAt(j)][k]; //更新状态,即当前匹配的最大公共前后缀长度(关键)        }        return this;    }    public int search(String txt){        if(txt == null || "".equals(txt)) throw new RuntimeException("匹配字符串txt不能为空");        int m = pattern.length();        int n = txt.length();        int i = 0, j = 0;        for(;i&lt;n &amp;&amp; j&lt;m;++i)            j = dfa[txt.charAt(i)][j]; //失配时对齐到当前字符的最大公共前后缀,继续比较下一个字符(索引刚好=长度)        if(j == m) return i-m;        return -1;    }}</code></pre><h5 id="2-2-基于next数组的KMP算法"><a href="#2-2-基于next数组的KMP算法" class="headerlink" title="2.2.基于next数组的KMP算法"></a>2.2.基于next数组的KMP算法</h5><pre><code>/** * Knuth-Morris-Pratt 子字符串查找算法 * 时间复杂度: 线性  一般情况1.1N 最坏情况:3N * 概述: 通过next数组(此处维护了最大公共前后缀长度)方式实现 * next数组求解: 递推关系,假设next[i] = k,值表示pattern中0-i子字符串最大公共前后缀长度为k,当next[i+1]失配时 *      求解next[i+1],将next[i]的最大公共前后缀与其对齐,比较i+1字符位置是否相同,即pattern[k] == pattern[i+1] *      如果相同则next[i+1] = k+1,否则将前k个字符的最大公共前后缀长度next[k]与其对齐,继续比较i+1字符即pattern[next[k]] == pattern[i+1] *      如果相同则next[i+1] = next[k]+1;以此类推,一直查找,如果当k=0时还没找到,则,next[i+1] = 0; */public class KMPSearch {    private int[] next; //维护了最大公共前后缀长度    private String pattern; //模式串    public KMPSearch(String pattern) {        setPattern(pattern);    }    public KMPSearch setPattern(String pattern){        if(pattern == null || "".equals(pattern)) throw new RuntimeException("pattern模式字符串不能为空");        this.pattern = pattern;        next = new int[pattern.length()];        next[0] = 0;        for(int i = 1,k = 0; i &lt; pattern.length();++i){            while(k &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(k))                k = next[k-1]; //失配时,将0~k子字符串的最大公共前后缀与其对齐,继续与i字符比较            if(pattern.charAt(i) == pattern.charAt(k)) ++k; //匹配成功时最大公共前后缀+1            next[i] = k; //更新当前的最大公共前后缀        }        return this;    }    public int search(String txt){        if(txt == null || "".equals(txt)) throw new RuntimeException("匹配字符串txt不能为空");        int m = pattern.length();        int n = txt.length();        int i = 0,j = 0;        for(;i&lt;n&amp;&amp;j&lt;m;++i){            if(txt.charAt(i) == pattern.charAt(j)) ++j;            else{//失配时,对齐最大公共前后缀,继续比较当前字符,会停留                if(j == 0) continue;                --i;                j = next[j-1];            }        }        if(j == m) return i-m;        return -1;    }}</code></pre><h4 id="3-BoyerMoore算法"><a href="#3-BoyerMoore算法" class="headerlink" title="3.BoyerMoore算法"></a>3.BoyerMoore算法</h4><h5 id="3-1-仅基于坏字符规则的BoyerMoore算法"><a href="#3-1-仅基于坏字符规则的BoyerMoore算法" class="headerlink" title="3.1.仅基于坏字符规则的BoyerMoore算法"></a>3.1.仅基于坏字符规则的BoyerMoore算法</h5><pre><code>/** * BoyerMoore 子字符串查找算法 * 时间复杂度: 亚线性 一般情况N/M 最坏情况MN * 概述: 此处仅仅使用了坏字符规则,好后缀+坏字符规则另见本章 *        整体从左向右,与模式串比较时,(模式串结束位置)从右向左(模式串开始位置)比较 *       失配时,寻找模式串最右边与其相同的字符对齐(如果导致倒退就模式串向后移动一位),没找到则是模式串开始位置与下一个字符对齐,继续从右向左匹配, */public class BoyerMoore {    private String pattern;    private int R;    private int[] right;    public BoyerMoore(String pattern) {        this.R = 256;        setPattern(pattern);    }    public BoyerMoore(String pattern,int R) {        this.R = R;        setPattern(pattern);    }    public BoyerMoore setPattern(String pattern){        if(pattern == null || "".equals(pattern)) throw new RuntimeException("pattern模式字符串不能为空");        this.pattern = pattern;        //坏字符规则        right = new int[R]; //键为任意字符,值为当前字符在模式串中出现的最大索引        for(int c=0;c&lt;R;++c) //默认没找到为-1            right[c] = -1;        for(int i=0;i&lt;pattern.length();++i)            right[pattern.charAt(i)] = i; //在模式串中出现的字符更新最大索引        return this;    }    public int search(String txt){        int m = pattern.length();        int n = txt.length();        int skip;        for(int i=0;i&lt;=n-m;i += skip){            int j;            for(j=m-1;j&gt;=0 &amp;&amp; pattern.charAt(j) == txt.charAt(i+j);--j);            if(j&lt;0) return i;            else skip = Math.max(j-right[txt.charAt(i+j)],1); //如果导致倒退,就向后移动一位        }        return -1;    }}</code></pre><h5 id="3-2-基于坏字符与好后缀的BoyerMoore算法"><a href="#3-2-基于坏字符与好后缀的BoyerMoore算法" class="headerlink" title="3.2.基于坏字符与好后缀的BoyerMoore算法"></a>3.2.基于坏字符与好后缀的BoyerMoore算法</h5><pre><code>/** * BoyerMoore 子字符串查找算法 * 时间复杂度: 亚线性  一般情况: N/M * 概述: 失配时,选取坏字符与好后缀规则中最大的跳跃距离进行模式串移动 * 坏字符: 失配字符出现在模式串中的最大索引位置,下次比较对齐该字符重新进行比较 * 好后缀: 记录模式串中与当前匹配的后缀相同的,或者模式串开始位置与该后缀部分相同的, *         则失配时对齐该相同部分,继续重新开始匹配 */public class BoyerMooreSearch {    private String pattern;    private int R;    private int[] bad;    //bad character坏字符(值保存在模式串中找到的最大索引)    private int[] good;   //good suffix好后缀(值为下次比较模式串应该跳跃的距离)    public BoyerMooreSearch(String pattern) {        R = 256;        setPattern(pattern);    }    public BoyerMooreSearch(String pattern,int R){        this.R = R;        setPattern(pattern);    }    public BoyerMooreSearch setPattern(String pattern){        if(pattern == null || "".equals(pattern)) throw new RuntimeException("pattern模式字符串不能为空");        this.pattern = pattern;        int m = pattern.length();        //坏字符(此处记录出现的最大索引)        bad = new int[R];        for(int i=0;i&lt;R;++i)            bad[i] = -1;        for(int i=0;i&lt;m;++i)            bad[pattern.charAt(i)] = i;        //好后缀        good = new int[m];        int[] suffix  = getSuffix();        //case1: 不存在和好后缀匹配的字符串        Arrays.fill(good,m);        //case2: 模式串开头部分匹配        int j=0;        for(int i=m-2;i&gt;=0;--i){            if(suffix[i] == i+1){                for(;j&lt;m-1-i;++j)                    if(good[j] == m) good[j] = m-1-i;            }        }        //case3: 存在与好后缀完全匹配的字符串        for(int i=0;i&lt;=m-2;++i)            good[m-1-suffix[i]] = m-1-i;        return this;    }    //计算后缀数组(暴力查找: 所有后缀情况全部查询一遍)    private int[] getSuffix_old(){        int m = pattern.length();        int[] suffix  = new int[m];        suffix[m-1] = m;        for(int i= m-2;i&gt;=0;--i){            int j = i;            while(j&gt;=0 &amp;&amp; pattern.charAt(j) == pattern.charAt(m-1-i+j)) --j;            suffix[i] = i-j;        }        return suffix;    }    //计算后缀数组,稍微改进    private int[] getSuffix(){        int m = pattern.length();        int[] suffix = new int[m];        suffix[m-1] = m;        int j = m-1,prei=0;        for(int i=m-2;i&gt;=0;--i){            if(i&gt;j &amp;&amp; suffix[m-1-prei+i] &lt; i-j) //与前面计算过的的后缀相同,无需计算,直接赋值为以前计算过的好后缀                suffix[i] = suffix[m-1-prei+i];            else {                if(i&lt;j) j = i;                while (j &gt;= 0 &amp;&amp; pattern.charAt(j) == pattern.charAt(m - 1 - i + j)) --j;                suffix[i] = i - j;                prei = i;            }        }        return suffix;    }    //BM算法查找字串    public int search(String txt){        int m = pattern.length();        int n = txt.length();        int skip;        for(int i=0;i&lt;=n-m;i+=skip){            int j;            for(j=m-1;j&gt;=0 &amp;&amp; pattern.charAt(j) == txt.charAt(i+j);--j);            if(j&lt;0) return i;            else skip = Math.max(j-bad[txt.charAt(i+j)],good[j]); //取坏字符与好后缀中跳跃最大距离的        }        return -1;    }}</code></pre><h4 id="4-RabinKarp算法-指纹子字符串搜索算法"><a href="#4-RabinKarp算法-指纹子字符串搜索算法" class="headerlink" title="4.RabinKarp算法(指纹子字符串搜索算法)"></a>4.RabinKarp算法(指纹子字符串搜索算法)</h4><pre><code>/** * Rabin-Karp 指纹字符串查找算法 * 时间复杂度: 线性 7N * 概述: 按照暴力匹配的策略,但是比较的是与模式串相同长度的整个子串的hash值 *       一个长度为m的字符串可以看做一个R进制m位数 * 关键: 通过已经计算出当前子串的hash值快速计算下一个将要比较的字串的hash值 *       如: 3123 第一次使用霍纳法则算出312的hash值,下次需要计算123的hash值,则为(312-300)*10+3的hash值 *       然后使用同余定理对该式求解hash值(即余数) */public class RabinKarp {    private String pattern; //模式串    private long patternHash; //模式串hash值    private int m; //模式串长度    private long q; //一个大质数    private int R; //基数(字符集数),一个长度为m的字符串可以看做R进制m位数    private long RM; //R^(m-1) % q(即第m-1位数除以q的余数)    public RabinKarp(String pattern) {        this.R = 256;        setPattern(pattern);    }    public RabinKarp(String pattern, int R) {        this.R = R;        setPattern(pattern);    }    public RabinKarp setPattern(String pattern){        if(pattern == null || "".equals(pattern)) throw new RuntimeException("pattern模式字符串不能为空");        this.pattern = pattern;        this.m = pattern.length();        this.q = longRandomPrime(); //31位质数,q足够大时,几乎没有hash冲突,可以不再进行hash冲突验证        //预计算RM的值        RM = 1;        for(int i=1;i&lt;m;++i)            RM = (RM*R)%q;        patternHash = hash(pattern,m);        return this;    }    //Horner Rule(霍纳法则): 计算字符串[0...m-1]的hash值    private long hash(String key,int m){        long h = 0;        for(int i=0;i&lt;m;++i)            h = (R*h + key.charAt(i))%q;        return h;    }    //随机生成一个31位的质数    private long longRandomPrime(){        return BigInteger.probablePrime(31,new Random()).longValue();    }    /**     * 正确性验证: 可能存在hash冲突     * 1.蒙特卡罗算法: 采样越多，越逼近最优解     *   策略: q的取值越大,hash冲突的可能性越小,使用非常大的q值时几乎不可能发生hash冲突,在实际应用中寻找匹配是可靠的     * 2.拉斯维加斯算法: 采样越多，越有可能找到最优解     *   策略: 对RK算法找到的匹配字串再进行验证     */    //拉斯维加斯算法验证正确性    private boolean check(String txt,int i){        for(int j=0;j&lt;m;++j)            if(pattern.charAt(j) != txt.charAt(i+j))                return false;        return true;    }    /**     * 同余定理     * (A*B) mod m = ((A mod m) * (B mod m)) mod m     * (A+B) mod m = ((A mod m) + (B mod m)) mod m     * (A-B) mod m = ((A mod m) - (B mod m)+ m) mod m     */    public int search(String txt){        int n = txt.length();        if(n &lt; m) return -1;        long txtHash = hash(txt,m);        if(txtHash == patternHash &amp;&amp; check(txt,0))            return 0;        for(int i = m;i&lt;n;++i){            //同余定理,Horner Rule(霍纳法则)            //(A-B) mod m = ((A mod m) - (B mod m)+ m) mod m            txtHash = (txtHash - RM * txt.charAt(i - m) % q + q) % q;            txtHash = (txtHash * R + txt.charAt(i)) % q;            int offset = i-m+1;            if(txtHash == patternHash &amp;&amp; check(txt,offset)) //可以不验证,Q值足够大: 蒙特卡罗算法                return offset;        }        return -1;    }}</code></pre><h4 id="5-Sunday算法"><a href="#5-Sunday算法" class="headerlink" title="5.Sunday算法"></a>5.Sunday算法</h4><pre><code>/** * Sunday算法 * 概述: 与BM算法思路相似,只是从左向右进行比较,匹配随机字符串最快 * 时间复杂度: o(n)-o(n*m) * 思路: 将文本与字符串对齐从左向右比较,失配时,找到文本中与模式串对齐的末尾的下一个字符, *       同时找到该字符出现在模式串中最大索引位置,然后将该字符与模式串中相同的那个最大索引字符对齐,继续比较 */public class Sunday {    private String pattern; //模式串    private int R;          //字符表长度    private int[] right;    //维护字符在模式串中出现的最大索引    public Sunday(String pattern) {        this.R = 256;        setPattern(pattern);    }    public Sunday(String pattern, int R) {        this.R = R;        setPattern(pattern);    }    public Sunday setPattern(String pattern){        if(pattern == null || "".equals(pattern)) throw new RuntimeException("pattern模式字符串不能为空");        this.pattern = pattern;        //记录字符在模式串中出现的最大索引        right = new int[R];        Arrays.fill(right,-1);        for(int i=0;i&lt;pattern.length();++i)            right[pattern.charAt(i)] = i;        return this;    }    public int search(String txt){        int m = pattern.length();        int n = txt.length();        int skip;        for(int i=0;i&lt;=n-m;i+=skip){            int j;            for(j=0;j&lt;m &amp;&amp; pattern.charAt(j) == txt.charAt(i+j);++j);            if(j == m) return i; //完全匹配            else skip = m - right[txt.charAt(i+m)]; //失配时,模式串移动距离,与模式串匹配字符越多,移动距离越小        }        return -1;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词查找树</title>
      <link href="/2019/06/24/Trie/"/>
      <url>/2019/06/24/Trie/</url>
      
        <content type="html"><![CDATA[<h3 id="单词查找树"><a href="#单词查找树" class="headerlink" title="单词查找树"></a>单词查找树</h3><blockquote><p>利用字符串的性质构建比通用的查找算法更有效的查找算法</p></blockquote><h4 id="1-R向单词查找树"><a href="#1-R向单词查找树" class="headerlink" title="1.R向单词查找树"></a>1.R向单词查找树</h4><pre><code>/** * R向单词查找树 * 概述: 1.每个节点都含有R个连接,对应着每个可能出现的字符 *       2.字符和键隐式的保存在数据结构中 * 缺点: 1.空节点也分配内存,空间开销比较大 *       2.不适合处理大型字母表,尤其是含有大量长键 */public class TrieST&lt;V&gt;{    private static final int R = 256; //256字符的字母表    private Node root;    //节点    private static class Node{        private Object value;    //键值不为null时表示存在键        private Node[] next = new Node[R];  //节点数组表示R向    }    //获取    public V get(String key){        if(key == null) return null;        Node x = get(root,key,0);        if(x != null) return (V) x.value;        return null;    }     /**获取: 从root根节点开始查找,多维护一个变量d标记当前查找的字符*/    private Node get(Node x,String key,int d){        if(x == null) return null;        if(d == key.length()) return x;        return get(x.next[key.charAt(d)],key,d+1);    }    //插入    public void put(String key,V value){        if(key == null) return;        if(value == null) delete(key);        root = put(root,key,value,0);    }    /**插入: 先查找,在赋值即可,查询过程中没有就创建,找到结尾就保存键值 */    private Node put(Node x,String key,V value,int d){        if(x == null) x = new Node();        if(d == key.length()){  //查询到末尾,赋值            x.value = value;            return x;        }        char c = key.charAt(d);        x.next[c] = put(x.next[c],key,value,d+1);        return x;    }    //删除    public void delete(String key){        if(key == null) return;        root = delete(root,key,0);    }    /**删除: 先查找到节点,值设置为null,然后判断当前节点的R条子链接全为null     *       则删除当前节点,否则返回当前节点     */    private Node delete(Node x,String key,int d){        if(x == null) return null;        if(d == key.length()){//找到            x.value = null;            for(char c=0;c&lt;R;++c) //当前节点的R条子连接节点不为null,返回当前节点                if(x.next[c] != null) return x;            return null;    //否则都为null,删除当前节点        }        char c = key.charAt(d);        x.next[c] = delete(x.next[c],key,d+1);        return x;    }    //键总数量    public int size(){ return size(root); }    /**键总量: 遍历所有节点,值不为null时为一个键,标记为1,递归相加 */    private int size(Node x){        if(x == null) return 0;        int count = 0;        if(x.value != null) ++count;//存在值,有一个键位,标记为1        for(char c=0;c&lt;R;++c)            count += size(x.next[c]);//递归相加        return count;    }    //包含    public boolean contains(String key){ return get(key) != null; }    //是否为空    public boolean isEmpty(){ return size() == 0; }    //所有键    public Iterable&lt;String&gt; keys(){ return keysWithPrefixOf(""); }    //指定前缀的所有键    public Iterable&lt;String&gt; keysWithPrefix(String prefix){        ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();        collect(get(root,prefix,0),prefix,queue);        return queue;    }    /**指定前缀的所有键:      *   与统计键总量思路相同,额外维护一个变量保存当前递归过的节点字符集合     *   当键的值存在时将该变量入队保存     */    private void collect(Node x,String prefix,Queue&lt;String&gt; queue){        if(x == null) return;        if(x.value != null) queue.offer(prefix);    //存在值,入队        for(char c=0;c&lt;R;++c)            collect(x.next[c],prefix+c,queue); //递归进入下一层,更新当前递归过的字符集合        //prefix+c会产生很多字符串,可使用StringBuilder优化    }    //指定前缀的所有键(使用StringBuilder优化)    public Iterable&lt;String&gt; keysWithPrefixOf(String prefix){        ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();        collect(get(root,prefix,0),new StringBuilder(prefix),queue);        return queue;    }    private void collect(Node x,StringBuilder prefix,Queue&lt;String&gt; queue){        if(x == null) return;        if(x.value != null) queue.offer(prefix.toString());        for(char c=0;c&lt;R;++c) {            prefix.append(c);   //递归进入增加当前节点字符            collect(x.next[c], prefix, queue);            prefix.deleteCharAt(prefix.length()-1); //递归结束删除增加的字符        }    }    //通配符匹配(仅"."通配符,如.a.表示包含3个字符中间为a的字符串)    public Iterable&lt;String&gt; keysThatMatch(String pattern){        ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();        collect(root,"",pattern,queue);        return queue;    }    /**通配符匹配: 按照遍历指定前缀所有键的思路,遇到.时不变,遇到特定字符时,只遍历特定子节点即可*/    private void collect(Node x,String prefix,String pattern,Queue&lt;String&gt; queue){        if(x == null) return;        int d = prefix.length();        if(d == pattern.length() &amp;&amp; x.value != null)//存在键,且匹配到pattern时保存            queue.offer(prefix);        if(d == pattern.length()) return;        int ch = pattern.charAt(d);        for(char c=0;c&lt;R;++c){            if(ch =='.' || ch == c){//'.'字符时遍历所有,特定字符ch时遍历特定子节点                collect(x.next[c],prefix+c,pattern,queue);                //1.prefix+c会创建大量字符串,可使用StringBuilder优化                //ch==c 时依然会进行循环判断,可优化, 不放到循环中            }        }    }    //通配符匹配(仅"."通配符)(使用StringBuilder优化)    public Iterable&lt;String&gt; keysThatMatchOf(String pattern){        ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();        collect(root,new StringBuilder(),pattern,queue);        return queue;    }    private void collect(Node x,StringBuilder prefix,String pattern,Queue&lt;String&gt; queue){        if(x == null) return;        int d = prefix.length();        if(d == pattern.length() &amp;&amp; x.value != null)            queue.offer(prefix.toString());        if(d == pattern.length()) return;        char ch = pattern.charAt(d);        if(ch =='.'){            for(char c=0;c&lt;R;++c) {                prefix.append(c);                collect(x.next[c], prefix, pattern, queue);                prefix.deleteCharAt(prefix.length() - 1);            }        }        else{   //去掉不必要的循环            prefix.append(ch);            collect(x.next[ch], prefix, pattern, queue);            prefix.deleteCharAt(prefix.length() - 1);        }    }    //前缀最长的键(与s从第一位开始匹配往后匹配最多字符的键)    public String longestPrefixOf(String s){        return s.substring(0,longestPrefixOf(root,s,0,0));    }    /**前缀最长的键: 按照给定的键遍历指定的子节点,同时额外维护当前匹配到的最长键,查询到最后一个字符返回维护的值*/    private int longestPrefixOf(Node x,String s,int d,int length){        if(x == null) return length;        if(x.value != null) length = d; //存在键更新当前匹配的最长键        if(d == s.length()) return length;  //查询到s末尾时返回维护的最长键长度        return longestPrefixOf(x.next[s.charAt(d)],s,d+1,length);    }}</code></pre><h4 id="2-三向单词查找树"><a href="#2-三向单词查找树" class="headerlink" title="2.三向单词查找树"></a>2.三向单词查找树</h4><pre><code>/** * 三向单词查找树 * 概述: 每个节点含有一个字符,三条链接和一个值,三条链接分辨对应着小于,等于,大于当前字符的键 * 优点: 1.避免了R向单词查找树过度的空间消耗 *       2.可以用于大型字母表 */public class TST&lt;V&gt; {    private int n;  //维护键的数量    private Node&lt;V&gt; root;//根节点    private class Node&lt;V&gt;{  //节点        private char c; //字符        private Node&lt;V&gt; left; //左连接 &lt;c        private Node&lt;V&gt; mid;  //中连接 =c        private Node&lt;V&gt; right;//右连接 &gt;c        private V value;    //保存键值    }    //获取    public V get(String key){        Node x = get(root,key,0);        if(x != null) return (V) x.value;        return null;    }    /**获取: 额外维护一个变量保存当前需要查询第几个字符,找到时返回节点 */    private Node get(Node x,String key,int d){        if(key == null || key.length() == 0) return null;        if(x == null) return null;        char c = key.charAt(d);//当前需要查询键的的字符        if(x.c &gt; c) return get(x.left,key,d);        else if(x.c &lt; c) return get(x.right,key,d);        else if(d &lt; key.length()-1) return get(x.mid,key,d+1);        else return x;  //找到返回节点    }    //插入    public void put(String key, V value){        if(key == null || key.length() == 0) return;        if(!contains(key)) ++n;        root = put(root,key,value,0);    }    /**插入: 与获取思路相同,只是遇到空节点创建新节点,到末尾时保存键值*/    private Node put(Node x,String key,V value,int d){        char c = key.charAt(d);        if(x == null) { //没有节点就创建            x = new Node();            x.c = c;        }        if(x.c &gt; c) x.left = put(x.left,key,value,d);        else if(x.c &lt; c) x.right = put(x.right,key,value,d);        else if(d &lt; key.length()-1) x.mid = put(x.mid,key,value,d+1);        else x.value = value;   //末尾时保存键值        return x;    }    //包含    public boolean contains(String key){ return get(key) != null; }    //键数量    public int size(){ return n; }    //返回所有键    public Iterable&lt;String&gt; keys(){        Queue&lt;String&gt; queue = new ArrayDeque&lt;&gt;();        collect(root, new StringBuilder(), queue);        return queue;    }    //指定前缀的所有键    public Iterable&lt;String&gt; keysWithPrefix(String prefix){        ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();        if(prefix == null) return queue;        Node x = get(root,prefix,0);        if(x == null) return queue;        if(x.value != null) queue.offer(prefix);        collect(x.mid,new StringBuilder(prefix),queue);        return queue;    }    /**遍历所有节点,同时使用一个额外的变量维护当前递归过的字符,中连接时才增加字符,当值存在时,将键入队*/    private void collect(Node x,StringBuilder prefix,Queue&lt;String&gt; queue){        if(x == null) return;        collect(x.left,prefix,queue);//递归遍历左子树        if(x.value != null) queue.offer(prefix.toString()+x.c);//中子树开始,增加字符        collect(x.mid,prefix.append(x.c),queue);//递归遍历右子树        prefix.deleteCharAt(prefix.length()-1); //递归结束删除字符        collect(x.right,prefix,queue); //递归遍历右子树    }    //通配符匹配(仅"."通配符,如.a.表示包含3个字符中间为a的字符串)    public Iterable&lt;String&gt; keysThatMatch(String pattern){        ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();        collect(root,new StringBuilder(),pattern,queue);        return queue;    }    /**与上面思路相同,只需要做不同筛选即可*/    private void collect(Node x,StringBuilder prefix,String pattern,Queue&lt;String&gt; queue){        if(x == null) return;        int d = prefix.length();        char c = pattern.charAt(d);        if(c == '.' || c &lt; x.c) collect(x.left,prefix,pattern,queue);   //增加额外判断,减少不必要的递归        if(c == '.' || c &gt; x.c) collect(x.right,prefix,pattern,queue);  //增加额外判断,减少不必要的递归        if(c == '.' || c == x.c){   //当'.'时匹配所有,遍历所有中子树,当为c时遍历指定的中子树            if(d == pattern.length()-1){ //找到匹配的键                if(x.value != null) queue.offer(prefix.toString() + x.c); //如果值存在就入队                return;            }            collect(x.mid,prefix.append(x.c),pattern,queue);            prefix.deleteCharAt(prefix.length()-1); //递归结束,删除增加的字符        }    }    //前缀最长的键(与s从第一位开始匹配往后匹配最多字符的键)    public String longestPrefixOf(String s){        if(s == null || s.length() ==0) return null;        int d = 0; //保存当前需要查询的字符位置        int len = 0; //保存当前查询到的最长键长度        Node x = root;        while(x != null &amp;&amp; d &lt; s.length()){            char c = s.charAt(d);            if(x.c &gt; c) x = x.left;            else if(x.c &lt; c) x = x.right;            else{   //匹配到一个字符                d++;//更新需要查询的字符位置为下一个字符                if(x.value != null) len = d;    //存在值,更新最长键                x = x.mid;            }        }        return s.substring(0,len);    }    //删除    public void delete(String key){        if(key == null || key.length() == 0) return;        root = delete(root,key,0);    }    /**     * 删除键     * 1.查询到删除的键的最后一个字符节点,将值设置为null     * 2.如果中子树存在,此时不能删除该节点     * 3.如果中子树不存在,则可以删除该节点,使用当前节点右子树的最左边的节点或者为中子树替换掉当前节点     * 4.递归返回时,如果当前节点的中子树为null且当前节点值为null,该节点也可以删除,同上述方法删除,知道根节点结束     */    private Node delete(Node x,String key,int d){        if(x == null) return null; //没找到        char c = key.charAt(d);        if(x.c &gt; c)  x.left = delete(x.left,key,d);        else if(x.c &lt; c)  x.right = delete(x.right,key,d);        else if(d &lt; key.length()-1)  x.mid = delete(x.mid,key,d+1);        else{//找到            if(x.value != null) --n; //找到删除            x.value = null;            if(x.mid != null) return x;//中子树存在,不能删除当前节点,直接返回            /**中子树不存在,当前节点可以删除*/            if(x.left == null) return x.right;            if(x.right == null) return x.left;            //左右子节点不为null,中节点为null时,使用右子树最左边节点或为中子树替换x            Node t = x;            x = min(t.right); //最左边节点,可能含x.mid子树            x.right = delMin(t.right);            x.left = t.left;        }        /**递归返回时删除没有中子树,并且当前节点值为null的节点*/        if(x.mid == null &amp;&amp; x.value == null){            if(x.left == null) return x.right;            if(x.right == null) return x.left;            //左右子节点不为null,中节点为null时,使用右子树最左边节点或为中子树替换x            Node t = x;            x = min(t.right); //最左边节点,可能含x.mid子树            x.right = delMin(t.right);            x.left = t.left;        }        return x;    }    //获取最左边节点或中子树    private Node min(Node x){        if(x.left == null) return x;        return min(x.left);    }    //删除最左边节点或中子树    private Node delMin(Node x){        if(x.left == null) return x.right;        x.left = delMin(x.left);        return x;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串排序</title>
      <link href="/2019/06/21/StringSort/"/>
      <url>/2019/06/21/StringSort/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h3><blockquote><p>利用字符串的特殊性质将字符串排序,比通用的排序算法效率更高</p></blockquote><h4 id="1-低位优先的字符串排序-LSD"><a href="#1-低位优先的字符串排序-LSD" class="headerlink" title="1.低位优先的字符串排序(LSD)"></a>1.低位优先的字符串排序(LSD)</h4><pre><code>/** * 低位优先的字符串排序(LSD) * 概述: 适合相同长度的字符串排序,是稳定排序 * 思想: 键索引计数法 * 步骤: 从低位开始每轮取一个字符,使用键索引计数法排序,直到最高位结束 */public class LSD {    public static void sort(String[] a,int w){        int N = a.length;        int R = 256;        String[] aux = new String[N];        int[] count = new int[R+1];        for(int d=w-1;d&gt;=0;d--) {//使用键索引计数法进行w轮排序            //统计频率            for(int i=0;i&lt;N;++i)                count[a[i].charAt(d)+1]++;            //计算索引            for(int i=0;i&lt;R;++i)                count[i+1] += count[i];            //数据分类            for(int i=0;i&lt;N;++i)                aux[count[a[i].charAt(d)]++] = a[i];            //回写            for(int i=0;i&lt;N;++i)                a[i] = aux[i];            Arrays.fill(count,0);        }    }}</code></pre><h4 id="2-高位优先的字符串排序-MSD"><a href="#2-高位优先的字符串排序-MSD" class="headerlink" title="2.高位优先的字符串排序(MSD)"></a>2.高位优先的字符串排序(MSD)</h4><pre><code>/** * 高位优先的字符串排序(MSD) * 概述: 通用的字符串排序算法 *       缺点: 对于较长相同前缀的字符串进行排序会产生大量小数组 * 思想: 键索引计数法 * 步骤: 使用键索引计数法每轮去一个字符从高位开始排序 */public class MSD {    private static int R = 256;    private static int M = 15;    private static String[] aux;    public static void sort(String[] a){        int N = a.length;        aux = new String[N];        int[] count = new int[R+2];        sort(a,0,N,0);    }    private static void sort(String[] a,int lo,int hi,int d){        //if(lo &gt;= hi-1) return;        if (hi &lt;= lo + M) { //较短时使用插入排序进行优化            Insertion.sort(a, lo, hi, d);            return;        }        /**         * 键索引计数法         */        //统计频率        int[] count = new int[R+2];        for(int i=lo;i&lt;hi;++i)            count[charAt(a[i],d)+2]++;        //计算索引        for(int i=0;i&lt;R+1;++i)            count[i+1] += count[i];        //数据分类        for(int i=lo;i&lt;hi;++i)            aux[count[charAt(a[i],d)+1]++] = a[i];        //回写        for(int i=lo;i&lt;hi;++i)            a[i] = aux[i-lo];        //递归:字符相同的,对下一位字符进行排序        for(int i=0;i&lt;R;i++)            sort(a,lo+count[i],lo+count[i+1],d+1);    }    private static int charAt(String s,int d){        if(d &lt; s.length()) return s.charAt(d);        return -1;    }}</code></pre><h5 id="2-1插入排序"><a href="#2-1插入排序" class="headerlink" title="2.1插入排序"></a>2.1插入排序</h5><pre><code>/** * 插入排序 */public class Insertion {    public static void sort(String[] a,int lo,int hi,int d){        for(int i=lo+1;i&lt;hi;++i){            for(int j=i;j&gt;lo &amp;&amp; less(a[j],a[j-1],d);j--)                exch(a,j,j-1);        }    }    //比较    private static boolean less(String a,String b,int d){        int alen = a.length();        int blen = b.length();        int min = Math.min(alen,blen);        while(d &lt; min){            int c1 = a.charAt(d);            int c2 = b.charAt(d);            if(c1 != c2) return c1 - c2 &lt; 0;            d++;        }        return alen - blen &lt; 0;        //return a.substring(d).compareTo(b.substring(d)) &lt; 0;    }    //交换    private static void exch(String[] a,int i,int j){        String temp = a[i];        a[i] = a[j];        a[j] = temp;    }}</code></pre><h4 id="3-三向字符串快速排序"><a href="#3-三向字符串快速排序" class="headerlink" title="3.三向字符串快速排序"></a>3.三向字符串快速排序</h4><pre><code>/** * 三向字符串快速排序 * 概述: 通用字符串排序算法,适合处理含有较长相同前缀的字符串 * 步骤: 从高位开始对单个字符进行三向切分的快速排序,若按照v切分,则一轮结束后 *       小于v部分 &lt; 等于v部分 &lt; 大于v部分, 对于等于v部分的下一位字符进行排序 *       其他部分正常排序 */public class Quick3String {    public static void sort(String[] a){        sort(a,0,a.length-1,0);    }    private static void sort(String[] a,int lo,int hi,int d){        if(lo &gt;= hi) return;    //可以在较短时使用插入排序优化        int v = charAt(a[lo],d); //取第一个为切分点,v = -1时为没有字符        int lt = lo,gt = hi;        int i = lt + 1;        while(i &lt;= gt){//从切分点下一个开始逐个归位            int t = charAt(a[i],d);            if(t &lt; v) exch(a,i++,lt++); //小于v放到v左边            else if(t &gt; v) exch(a,i,gt--);//大于v放到右边(往末尾放)            else i++;        }        // v == -1 时不会有小于v的部分,等于v的部分无需再排序        if(v &gt;= 0 ) sort(a,lo,lt-1,d);        if(v &gt;= 0 ) sort(a,lt,gt,d+1);        sort(a,gt+1,hi,d);    }    //交换    private static void exch(String[] a,int i, int j){        String temp = a[i];        a[i] = a[j];        a[j] = temp;    }    private static int charAt(String s,int d){        if(d &lt; s.length()) return s.charAt(d);        return -1;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="/2019/06/11/ShortestPath/"/>
      <url>/2019/06/11/ShortestPath/</url>
      
        <content type="html"><![CDATA[<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><blockquote><p>加权有向图的最短路径</p></blockquote><h4 id="1-加权有向边API"><a href="#1-加权有向边API" class="headerlink" title="1. 加权有向边API"></a>1. 加权有向边API</h4><pre><code>/** * 加权有向边API * v -&gt; w */public class DirectedEdge {    private double weight;  //边的权重    private int v;          //边的起点    private int w;          //边的终点    public DirectedEdge(int v, int w,double weight) {        this.weight = weight;        this.v = v;        this.w = w;    }    //有向边的权重    public double weight(){ return weight; }    public int from(){ return v; }    public int to(){ return w; }    public String toString(){ return v +"-&gt;" + w + " " + weight; }}</code></pre><h4 id="2-加权有向图API"><a href="#2-加权有向图API" class="headerlink" title="2.加权有向图API"></a>2.加权有向图API</h4><pre><code>/** * 加权有向图API */public class EdgeWeightDiGraph {    private int v;  //顶点数    private int e;  //边数    private LinkedList&lt;DirectedEdge&gt;[] adj;   //邻接表    //含有v个顶点的空有向图    public EdgeWeightDiGraph(int v) {        this.v = v;        e = 0;        adj = (LinkedList&lt;DirectedEdge&gt;[]) new LinkedList[v];        for(int i=0;i&lt;v;++i)            adj[i] = new LinkedList&lt;&gt;();    }    //从输入流中读取创建一幅图    public EdgeWeightDiGraph(InputStream input) {        BufferedReader reader = new BufferedReader(new InputStreamReader(input));        String value = null;        try {            int v = Integer.parseInt(reader.readLine());            this.v = v;            adj = (LinkedList&lt;DirectedEdge&gt;[]) new LinkedList[v];            for(int i = 0 ; i &lt; v;i++)                adj[i] = new LinkedList&lt;&gt;();            int e = Integer.parseInt(reader.readLine());            double weight = 1;            for(int i=0; i&lt;e; i++){                String[] str = reader.readLine().split(" +");                if(str.length == 3)                    weight = Double.parseDouble(str[2]);                addEdge(new DirectedEdge(Integer.parseInt(str[0]),Integer.parseInt(str[1]),weight));            }        } catch (IOException e1) {            e1.printStackTrace();        } finally {            try {                reader.close();            } catch (IOException e1) {                e1.printStackTrace();            }        }    }    //顶点总数    public int V(){ return v; }    //边的总数    public int E(){ return e; }    //添加一条有向边    public void addEdge(DirectedEdge e){        adj[e.from()].add(e);        ++this.e;    }    //从顶点v指出的所有边    public Iterable&lt;DirectedEdge&gt; adj(int v){ return adj[v]; }    //该图中的所有边    public Iterable&lt;DirectedEdge&gt; edges(){        ArrayDeque&lt;DirectedEdge&gt; queue = new ArrayDeque&lt;&gt;();        for(int i=0;i&lt;v;++i)            adj[i].forEach(queue::add);        return queue;    }    //图的字符串表示    public String toString(){        String s = v + " vertices, " + e + " edges\n";        for(int i=0;i&lt;v;++i){            s += i + ": ";            for(DirectedEdge e : adj[i])                s += e +", ";            s += "\n";        }        return s;    }}</code></pre><h4 id="3-Dijkstra算法"><a href="#3-Dijkstra算法" class="headerlink" title="3.Dijkstra算法"></a>3.Dijkstra算法</h4><pre><code>/** * Dijkstra算法 * 概述: 使用索引优先队列优化(快速取出最小边),无法处理负权环,单源最短路径算法 *      负权边: 标准的Dijkstra算法无法处理负权边 *             此例允许重入队,可以处理负权边,但是如果在终点出队以后终止查询,则不能处理负权边 * 思想:与Prim算法思想类似,(依据的权重(计算方式)不同) * 步骤: 从起点s开始,找出所有s指向的顶点入队,找出权重最小者(适合优先队列保存),s-v,即为s-&gt;v的最短边, *      然后找出s和v顶点指向其他顶点的边入队(s的已入队),找出权重最下者,又更新一条最短边,重复即可 * * 改进(A*算法思想): 权重只和起点有关,在我们知道起点和终点的情况下,如果能预估到当前查询顶点到终点的权重, *       我们可以获取到起点然后经过当前点再到终点的总权重,依此权重生成优先队列,然后依此优先队列顺序进行放松操作 *       可以更快速的找到终点,一般适合二维平面中起点和终点最短路径的查找(可以估算到达终点的距离) */public class DijkstraSP {    private DirectedEdge[] edgeTo;  //维护到达当前顶点的最短路径的边,索引为顶点,值为到达此顶点的边    private double[] distTo;        //距离起点s的总权重,索引为顶点,值为权重    private IndexMaxPQ&lt;Double&gt; pq;  //索引优先队列,维护将要放松的边    //private ArrayDeque&lt;Integer&gt; queue;    //可以使用队列,但是此时相当于BellmanFord算法    public DijkstraSP(EdgeWeightDiGraph g,int s) {        edgeTo = new DirectedEdge[g.V()];        distTo = new double[g.V()];        Arrays.fill(distTo,Double.POSITIVE_INFINITY);        distTo[s] = 0.0;        pq = new IndexMaxPQ&lt;&gt;(g.V(),(x,y) -&gt; -x.compareTo(y));  //创建索引优先队列,传入比较器        pq.insert(s,0.0);   //起点放入索引优先队列中        while(!pq.isEmpty()) relax(g,pq.delMax());  //每次都放松最小的边        /**上可以添加终点出队后终止循环,此时不能处理负权边*/        //使用队列: 相当于BellmanFord算法        //queue = new ArrayDeque&lt;&gt;();        //queue.offer(s);        //while(!queue.isEmpty()) relax(g,queue.poll());    }    //放松操作    private void relax(EdgeWeightDiGraph g,int v){        for(DirectedEdge e : g.adj(v)){            int w = e.to();            if(distTo[w] &lt;= distTo[v] + e.weight()) continue; //到达顶点w的总权重更小,跳过            distTo[w] = distTo[v] + e.weight(); //否则更新顶点w的总权重            edgeTo[w] = e; //维护到达顶点w的边            /**在此更改权重为预估的起点到终点的值F,则可进行启发式搜索,如 F = G + H ,G=distTo[w], H为w到达终点的预估值*/            if(pq.contains(w)) pq.change(w,distTo[w]); //维护顶点w,可重入队,因此可以处理负权边            else pq.insert(w,distTo[w]);            //使用队列: contains方法可能影响效率,可以额外维护一个数组用来标记是否在队列中            //if(!queue.contains(w)) queue.offer(w);        }    }    public double distTo(int v){ return distTo[v]; }    public boolean hasPathTo(int v){ return distTo[v] &lt; Double.POSITIVE_INFINITY; }    public Iterable&lt;DirectedEdge&gt; pathTo(int v){        if(!hasPathTo(v)) return null;        ArrayDeque&lt;DirectedEdge&gt; stack = new ArrayDeque&lt;&gt;();        for(DirectedEdge x = edgeTo[v];x != null;x = edgeTo[x.from()])            stack.push(x);        return stack;    }}</code></pre><h4 id="4-无环加权有向图最短路径"><a href="#4-无环加权有向图最短路径" class="headerlink" title="4.无环加权有向图最短路径"></a>4.无环加权有向图最短路径</h4><pre><code>/** * 加权有向无环图最短路径 * 概述: 按照拓扑排序的顺序放松顶点即可,效率最高 */public class AcyclicSP {    private DirectedEdge[] edgeTo;  //维护路径    private double[] distTo;        //维护权重    public AcyclicSP(EdgeWeightDiGraph g,int v) {        edgeTo = new DirectedEdge[g.V()];        distTo = new double[g.V()];        Arrays.fill(distTo,Double.POSITIVE_INFINITY);        distTo[v] = 0.0;        TopoOrder topo = new TopoOrder(g);  //对加权有向无环图进行拓扑排序        topo.order().forEach(e -&gt; relax(g,e));  //按照拓扑排序顺序进行放松顶点    }    //松弛操作    private void relax(EdgeWeightDiGraph g,int v){        for(DirectedEdge e : g.adj(v)) {            int w = e.to();            if(distTo[w] &lt; distTo[v] + e.weight()) continue;            distTo[w] = distTo[v] + e.weight();            edgeTo[w] = e;        }    }    //起点到达该顶点的路径总权重    public double distTo(int v){ return distTo[v]; }    //是否存在路径    public boolean hasPathTo(int v){ return distTo[v] != Double.POSITIVE_INFINITY; }    //路径    public Iterable&lt;DirectedEdge&gt; pathTo(int v){        if(!hasPathTo(v)) return null;        ArrayDeque&lt;DirectedEdge&gt; stack = new ArrayDeque&lt;&gt;();        for(DirectedEdge e = edgeTo[v];e!=null;e = edgeTo[e.from()])            stack.push(e);        return stack;    }}</code></pre><h5 id="4-1-无环加权有向图拓扑排序"><a href="#4-1-无环加权有向图拓扑排序" class="headerlink" title="4.1.无环加权有向图拓扑排序"></a>4.1.无环加权有向图拓扑排序</h5><pre><code>/** * 无环加权有向图的拓扑排序 * 概述: 即图的深度优先搜索的逆后序排列,另见有向图 */public class TopoOrder {    private boolean[] marked;   //标记遍历过的顶点    private boolean[] onStack;  //标记递归进入的顶点,当有内层顶点指向外层顶点的边时,形成环    private ArrayDeque&lt;Integer&gt; stack;  //维护拓扑排序: 出栈顺序    public TopoOrder(EdgeWeightDiGraph g) {        marked = new boolean[g.V()];        onStack = new boolean[g.V()];        stack = new ArrayDeque&lt;&gt;();        for(int i=0;i&lt;g.V();++i)            if(!marked[i]) dfs(g,i);    }    public void dfs(EdgeWeightDiGraph g,int v){        marked[v] = true;        onStack[v] = true;  //标记递归进入        for(DirectedEdge e : g.adj(v))            if(!marked[e.to()]) dfs(g,e.to());            else if(onStack[e.to()]) throw new RuntimeException("存在有向环,无法拓扑排序");        stack.push(v);      //后续放入栈中即为逆后序        onStack[v] = false; //递归结束取消顶点标价    }    public Iterable&lt;Integer&gt; order(){ return stack; }}</code></pre><h4 id="5-BellmanFord算法普通版本"><a href="#5-BellmanFord算法普通版本" class="headerlink" title="5.BellmanFord算法普通版本"></a>5.BellmanFord算法普通版本</h4><pre><code>/** * BellmanFord算法普通版本 * 概述: 无法处理负权环,有很多无效的放松操作,因此可对此进行优化 * 步骤: 放松所有边E,然后重复V轮即可(V为顶点总数) *      其中边总数E为所有顶点v的adj(v)的和 * 简单思考: 先考虑放松一轮,此时必定维护好起点s开始的一条边,此边为最短路径上的其中一条边, *          然后进行第二轮放松,此时在上一轮基础上又能维护好与上一条边相连的一条边,依次类推 *          放松所有顶点即可 */public class BellmanFordCom {    private DirectedEdge[] edgeTo;  //维护到达当前顶点的最短路径的边,索引为顶点,值为到达此顶点的边    private double[] distTo;        //距离起点s的总权重,索引为顶点,值为权重    public BellmanFordCom(EdgeWeightDiGraph g, int s) {        edgeTo = new DirectedEdge[g.V()];        distTo = new double[g.V()];        Arrays.fill(distTo,Double.POSITIVE_INFINITY);        distTo[s] = 0.0;        for(int i=0;i&lt;g.V();++i)        //放松V轮            for(int j=0;j&lt;g.V();++j)    //所有顶点v进行adj(v)即所有边E                relax(g,j);    }    //放松操作    private void relax(EdgeWeightDiGraph g, int v){        for(DirectedEdge e : g.adj(v)){            int w = e.to();            if(distTo[w] &lt;= distTo[v] + e.weight()) continue; //到达顶点w的总权重更小,跳过            distTo[w] = distTo[v] + e.weight();     //否则更新顶点w的总权重            edgeTo[w] = e;      //维护到达顶点w的边        }    }    //起点s到达指定顶点的路径总权重    public double distTo(int v){ return distTo[v]; }    //是否存在最短路径    public boolean hasPathTo(int v){ return distTo[v] &lt; Double.POSITIVE_INFINITY; }    //返回最短路径    public Iterable&lt;DirectedEdge&gt; pathTo(int v){        if(!hasPathTo(v)) return null;        ArrayDeque&lt;DirectedEdge&gt; stack = new ArrayDeque&lt;&gt;();        for(DirectedEdge x = edgeTo[v];x != null;x = edgeTo[x.from()])            stack.push(x);        return stack;    }}</code></pre><h4 id="6-BellmanFord算法"><a href="#6-BellmanFord算法" class="headerlink" title="6.BellmanFord算法"></a>6.BellmanFord算法</h4><pre><code>/** * BellmanFord算法 * 概述: 可以处理负权边,无法处理负权环,单源最短路径算法 *       从BellmanFord普通版本可以看出,有很多无效的放松操作, *       第一轮放松操作实际上只更新了起点开始边指向的顶点,第二轮放松操作在此基础上,向外扩张 *       因此可以使用队列保存需要放松的顶点,然后进行relax操作即可 */public class BellmanFordSP {    private double[] distTo;    //维护当前顶点v到达起点s的总权重,索引为当前顶点v,值为权重    private DirectedEdge[] edgeTo;  //维护指向该达顶点的边,索引为顶点,值为边    private boolean[] onQ;      //标记是否已经入队    private Queue&lt;Integer&gt; queue;   //队列,维护需要放松的顶点    private int cost;           //标记放松操作的次数,    private Iterable&lt;DirectedEdge&gt; cycle;    public BellmanFordSP(EdgeWeightDiGraph g,int s) {        distTo = new double[g.V()];        edgeTo = new DirectedEdge[g.V()];        onQ = new boolean[g.V()];        queue = new ArrayDeque&lt;&gt;();        Arrays.fill(distTo,Double.POSITIVE_INFINITY);        distTo[s] = 0.0;        queue.offer(s);        while(!queue.isEmpty() &amp;&amp; !hasNegativeCycle()){            int v = queue.poll();            onQ[v] = false;            relax(g,v);        }    }    private void relax(EdgeWeightDiGraph g, int v){        for(DirectedEdge e : g.adj(v)){            int w = e.to();            if(distTo[w] &lt;= distTo[v] + e.weight()) continue;            distTo[w] = distTo[v] + e.weight();            edgeTo[w] = e;            if(!onQ[w]) {   //不在队列中入队,已经在队列中的,只更新权重和边即可                queue.offer(w);                onQ[w] = true;            }            if(cost++ % g.V() == 0) {   //负权环检测                findNegativeCycle();                if(hasNegativeCycle()) return;            }        }    }    //返回到达顶点v的总权重    public double distTo(int v){ return distTo[v]; }    public boolean hasPathTo(int v){ return distTo[v] &lt; Double.POSITIVE_INFINITY; }    public Iterable&lt;DirectedEdge&gt; pathTo(int v){        ArrayDeque&lt;DirectedEdge&gt; stack = new ArrayDeque&lt;&gt;();        for(DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[v])            stack.push(e);        return stack;    }    //查找负权环    private void findNegativeCycle(){        int v = edgeTo.length;        EdgeWeightDiGraph spt = new EdgeWeightDiGraph(v);        for(int i=0;i&lt;v;++i)            if(edgeTo[v] != null) spt.addEdge(edgeTo[v]);   //新图spt中不会存在正权环        EdgeWeightedDirectedCycle cfind = new EdgeWeightedDirectedCycle(spt);   //有向环检测,必定为负权环        cycle = cfind.cycle();    }    //是否存在负权环    public boolean hasNegativeCycle(){ return cycle != null; }    //返回负权环    public Iterable&lt;DirectedEdge&gt; NegativeCycle() { return cycle; }}</code></pre><h5 id="6-1-加权有向图中的有向环检测"><a href="#6-1-加权有向图中的有向环检测" class="headerlink" title="6.1.加权有向图中的有向环检测"></a>6.1.加权有向图中的有向环检测</h5><pre><code>/** * 加权有向图中的有向环 * 概述: 与有向图的有向环检测相同,使用深度优先搜索检测 *       即递归遍历的内层顶点连接到外层顶点时,形成有向环 */public class EdgeWeightedDirectedCycle {    private boolean[] marked;   //标记是否遍历,索引为顶点    private DirectedEdge[] edgeTo; //维护指向当前顶点的边,索引为顶点,值为指向该顶点的边    private boolean[] onStack;     //维护递归进入的顶点    private ArrayDeque&lt;DirectedEdge&gt; cycle; //维护有向环    public EdgeWeightedDirectedCycle(EdgeWeightDiGraph g) {        marked = new boolean[g.V()];        edgeTo = new DirectedEdge[g.V()];        onStack = new boolean[g.V()];        for(int i=0;i&lt;g.V();++i)            if(!marked[i]) dfs(g,i);    }    //深度优先搜索    private void dfs(EdgeWeightDiGraph g,int v){        marked[v] = true;        onStack[v] = true; //递归进入时,标记        for(DirectedEdge e : g.adj(v)){            int w = e.to();            if(cycle != null) return;            if(!marked[w]){ //递归遍历没有遍历过的顶点                edgeTo[w] = e;                dfs(g,w);            }            else if(onStack[w]){    //此时有递归内层顶点指向外层顶点的边,形成环                cycle = new ArrayDeque&lt;&gt;();                while(e.from() != w){   //维护该环                    cycle.push(e);                    e = edgeTo[e.from()];                }                cycle.push(e);                return;            }        }        onStack[v] = false; //递归出去时,取消标记    }    //是否有环    public boolean hasCycle(){ return cycle != null; }    //返回加权有向环    public Iterable&lt;DirectedEdge&gt; cycle(){ return cycle; }}</code></pre><h4 id="7-FLoyd算法"><a href="#7-FLoyd算法" class="headerlink" title="7.FLoyd算法"></a>7.FLoyd算法</h4><pre><code>/** * Floyd算法 * 概述: 多源最短路径算法,查询结束,可以获取任意两个顶点的最短路径 * 步骤: 对一个中转顶点k,更新任意两个顶点i,j经过该中转顶点k使得路径更短,一轮结束后 *       那些需要k中转的最短路径必定更新完成k顶点,因此要更新最短路径所有顶点, *       对每个顶点都进行一轮此操作即可 */public class Floyd {    private double[][] dist;    //维护权重的矩阵    private int[][] edge;       //维护路径的矩阵(构造函数中可不做处理,判断是否存在路径是使用dist,                                //edge中只维护好存在的路径即可,不存在的不维护不影响)    public Floyd(EdgeWeightDiGraph g) {        dist = new double[g.V()][g.V()];        edge = new int[g.V()][g.V()];        //初始化        for(int i=0;i&lt;g.V();++i)            for(int j=0;j&lt;g.V();++j) {                edge[i][j] = -1;                if (i == j) {                    dist[i][j] = 0.0;                    edge[i][j] = i;                }                else dist[i][j] = Double.POSITIVE_INFINITY;            }        //将图的信息更新到矩阵中        for(int i=0;i&lt;g.V();++i){            for(DirectedEdge e : g.adj(i)) {                dist[i][e.to()] = e.weight();                edge[i][e.to()] = i;            }        }        floyd();    }    //floyd算法    private void floyd(){        for(int k=0;k&lt;dist.length;++k)            for(int i=0;i&lt;dist.length;++i)                for(int j=0;j&lt;dist.length;++j) {                    if(dist[i][j] &lt;= dist[i][k] + dist[k][j]) continue;                    dist[i][j] = dist[i][k] + dist[k][j];   //更新权重                    edge[i][j] = edge[k][j];                //更新路径:i-j更新为i-k-j;                }    }    public double disTo(int s,int v){ return dist[s][v];}    public boolean hasPathTo(int s,int v){ return dist[s][v] &lt; Double.POSITIVE_INFINITY; }    public Iterable&lt;Integer&gt; pathTo(int s,int v){        if(!hasPathTo(s,v)) return null;        ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();        for(int i=v;i!=s;i=edge[s][i])            stack.push(i);        stack.push(s);        return stack;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2019/06/05/MinimumSpanningTree/"/>
      <url>/2019/06/05/MinimumSpanningTree/</url>
      
        <content type="html"><![CDATA[<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><blockquote><p>加权无向图的最小生成树</p></blockquote><h4 id="1-加权边API"><a href="#1-加权边API" class="headerlink" title="1.加权边API"></a>1.加权边API</h4><pre><code>//加权边APIpublic class Edge implements Comparable&lt;Edge&gt;{    private final int v; //边的一个顶点    private final int w; //边的另一个顶点    private final double weight;    //边的权重    public Edge(int v,int w,double weight) {        this.v = v;        this.w = w;        this.weight = weight;    }    public double weight(){ return weight; }    public int either(){ return v; }    //获取其中一个顶点    public int other(int vertex){       //获取另一个顶点        if(vertex == v) return w;        else if(vertex == w) return v;        else throw new RuntimeException("不包含顶点"+v);    } //方便遍历所有边    public int compareTo(Edge that) {   //可比较        if(weight-that.weight &lt; 0) return -1;        else if(weight-that.weight &gt; 0) return 1;        else return 0;    }    public String toString() {  //字符串表示        return v + "-" + w +" " + weight;    }}</code></pre><h4 id="2-加权无向图API"><a href="#2-加权无向图API" class="headerlink" title="2.加权无向图API"></a>2.加权无向图API</h4><pre><code>//加权无向图APIpublic class EdgeWeightedGraph {    private int v;    //顶点数    private int e;    //边数    private LinkedList&lt;Edge&gt;[] adj;   //邻接表    public EdgeWeightedGraph(int v) {   //创建一副含有v个顶点的空图        this.v = v;        e = 0;        adj = new LinkedList[v];        for(int i=0;i&lt;v;++i)            adj[i] = new LinkedList&lt;&gt;();    }    public EdgeWeightedGraph(InputStream input) {   //从输入流中读取一幅图        BufferedReader reader = new BufferedReader(new InputStreamReader(input));        String value = null;        try {            int v = Integer.parseInt(reader.readLine());            this.v = v;            adj = (LinkedList&lt;Edge&gt;[]) new LinkedList[v];            for(int i = 0 ; i &lt; v;i++)                adj[i] = new LinkedList&lt;&gt;();            int e = Integer.parseInt(reader.readLine());            for(int i=0; i&lt;e; i++){                String[] str = reader.readLine().split(" +");                addEdge(new Edge(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Double.parseDouble(str[2])));            }        } catch (IOException e1) {            e1.printStackTrace();        } finally {            try {                reader.close();            } catch (IOException e1) {                e1.printStackTrace();            }        }    }    //顶点数    public int V(){ return v; }    //边数    public int E(){ return e; }    //向图中添加一条边e    public void addEdge(Edge e){        adj[e.either()].add(e);        adj[e.other(e.either())].add(e);        this.e++;    }    //和v相连的所有边    public Iterable&lt;Edge&gt; adj(int v){ return adj[v]; }    //图的所有边    public Iterable&lt;Edge&gt; edges(){        ArrayDeque&lt;Edge&gt; queue = new ArrayDeque&lt;&gt;();        for(int i=0;i&lt;v;++i)    //按照顶点从小到大顺序遍历            for(Edge e : adj[i])                if(e.other(i) &gt; i) queue.offer(e);  //大顶点-小顶点的边肯定在之前被遍历过        return queue;    }    //图的字符串表示    public String toString() {        String s = V() + "vertices, " + E() + " edges\n";        for(int v = 0;v &lt; V();v++){            s += v + ": ";            for(Edge e : adj(v))                s += e.toString() + " ";            s += "\n";        }        return s;    }}</code></pre><h4 id="3-Prim算法延时版本-最小生成树"><a href="#3-Prim算法延时版本-最小生成树" class="headerlink" title="3.Prim算法延时版本(最小生成树)"></a>3.Prim算法延时版本(最小生成树)</h4><pre><code>/** * 最小生成树的Prim延时算法 *    (假设为连通图,非连通时取每个连通分量的最小生成树合并为森林即可) * 概述: 将图所有顶点分为两个非空且不重复的两个集合,横切边是连接两个属于不同集合的边, *       而连接这两个集合的所有横切边中最小边必然属于最小生成树 * 实现: 以任意一个顶点开始,作为最小生成树的初始阶段,将图分为2部分(一个顶点为一部分(最小生成树起始阶段),剩余顶点为一部分) *       获取连接这两个集合的所有横切边的最小者,加入最小生成树中,此时最小生成树的2个顶点和其余顶点作为图的两部分, *       重复上面的步骤继续取横切边中最小的边加入最小生成树,直到得到v-1条边为止 */public class LazyPrimMST {    private boolean[] marked;   //标记是否已加入到最小生成树中    private Queue&lt;Edge&gt; mst;    //维护最小生成树的边    private PriorityQueue&lt;Edge&gt; pq; //使用优先队列保存横切边(包含失效的),每次可取出最小的横切边    private double weight;    public LazyPrimMST(EdgeWeightedGraph g) {        marked = new boolean[g.V()];        mst = new ArrayDeque&lt;&gt;();        pq = new PriorityQueue&lt;&gt;();        visit(g,0);     //假设g连通        while(!pq.isEmpty()){            Edge e = pq.poll(); //取出最小的横切边            int v = e.either(), w = e.other(v); //横切边的两个顶点v-w            if(marked[v] &amp;&amp; marked[w]) continue; //顶点都在树中,失效的横切边跳过            mst.offer(e);   //有效的最小横切边加入最小生成树中            weight += e.weight();   //更新总权重            if(marked[v]) visit(g,w); //将刚加入的顶点加入树中,并遍历相连的边            if(marked[w]) visit(g,v);        }    }    private void visit(EdgeWeightedGraph g,int v){        marked[v] = true;   //标记顶点V已经加入树中        for(Edge e : g.adj(v))  //遍历新加入顶点相连的所有边            if(!marked[e.other(v)]) pq.offer(e); //将加入顶点后新增加的横切边加入优先队列        /**        * 可在此进行优化,只加入有效的横切边,变成及时Prim算法        */    }    //最小生成树所有边    public Iterable&lt;Edge&gt; edges(){ return mst; }    //最小生成树的权重    public double weight(){ return weight; }}</code></pre><h4 id="4-Prim算法及时版本-最小生成树"><a href="#4-Prim算法及时版本-最小生成树" class="headerlink" title="4.Prim算法及时版本(最小生成树)"></a>4.Prim算法及时版本(最小生成树)</h4><pre><code>/** *  Prim算法及时版本(最小生成树) *  概述: 只需对延时版本的Prim算法稍作更改即可,只将有效的横切边加入优先队列 *        此处使用索引优先队列,索引为顶点,按权重(到达顶点的边的权重)构造优先队列 *        生成的索引优先队列可获取最小权重的顶点,还可以取出指定顶点的权重 *        索引优先队列api在以前博客记录 */public class PrimMST {    private boolean[] marked;   //标记是否已加入最小生成树    private Edge[] edgeTo;      //索引为顶点,值为到达该顶点的边,最后保存了最小生成树的边    private IndexMaxPQ&lt;Double&gt; pq; //索引优先队列(见堆排序)维护有效的横切边    public PrimMST(EdgeWeightedGraph g) {        marked = new boolean[g.V()];        edgeTo = new Edge[g.V()];        pq = new IndexMaxPQ&lt;&gt;(g.V(),(x,y) -&gt; -x.compareTo(y));        pq.insert(0,0.0);   //起始顶点        while(!pq.isEmpty())            visit(g,pq.delMax());    }    private void visit(EdgeWeightedGraph g,int v){        marked[v] = true;        for(Edge e : g.adj(v)){            int w = e.other(v);            if(marked[w]) continue;     //如果另一个顶点已经加入最小生成树,则跳过            if(!pq.contains(w)) pq.insert(w,e.weight()); //与新顶点构成的横切边,直接加入            else if(pq.peek(w) &lt; e.weight()) continue;   //无效横切边跳过:以前记录的到达w顶点的横切边权重更小            else pq.change(w,e.weight());   //新的横切边权重更小,更新权重            edgeTo[w] = e;  //执行到此为有效横切边,加入或者替换        }    }    //最小生成树的边    public Iterable&lt;Edge&gt; edges(){ return Arrays.stream(edgeTo).skip(1).collect(Collectors.toList()); }    //最小生成树的权重    public double weight(){ return Arrays.stream(edgeTo).skip(1).mapToDouble(x -&gt; x.weight()).sum(); }}</code></pre><h4 id="5-Kruskal算法-最小生成树"><a href="#5-Kruskal算法-最小生成树" class="headerlink" title="5.Kruskal算法(最小生成树)"></a>5.Kruskal算法(最小生成树)</h4><pre><code>/** * Kruskal算法 * 概述: 将所有边按照边的权重加入优先队列,每次取出一个最小的边,该边不会与已经加入的边构成环, *       则加入最小生成树,直到含有v-1条边为止 * 实现: 使用union-find数据结构维护顶点的连通性,可以判断两个顶点是否连通, *       如果在加入一条边时,此边的两个顶点已经连通, 则会构成环,此时为无效边 */public class KruskalMST {    private Queue&lt;Edge&gt; mst;    //维护最小生成树的边    private double weight;      //维护权重    public KruskalMST(EdgeWeightedGraph g) {        mst = new ArrayDeque&lt;&gt;();        PriorityQueue&lt;Edge&gt; minPQ = new PriorityQueue&lt;&gt;();        g.edges().forEach(minPQ::offer);    //将所有边按照边的权重加入优先队列        WeightedQuickUnion un = new WeightedQuickUnion(g.V());//union-find(见union-find算法)        while(!minPQ.isEmpty() &amp;&amp; mst.size() &lt; g.V()-1){    //v-1条边为止            Edge e = minPQ.poll();  //取出最小边            int v = e.either(),w = e.other(v);            if(un.connected(v,w)) continue; //跳过无效边: v与w已经连通,此时再加入该边会构成环            un.union(v,w);  //加入新的边,更新连通性            mst.offer(e);   //加入新边            weight += e.weight(); //更新总权重        }    }    //最小生成树的所有边    public Iterable&lt;Edge&gt; edges(){ return mst; }    //最小生成树的权重    public double weight(){ return weight; }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有向图</title>
      <link href="/2019/05/22/Directedgraph/"/>
      <url>/2019/05/22/Directedgraph/</url>
      
        <content type="html"><![CDATA[<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><blockquote><p>概述: 使用邻接表的数据结构表示有向图</p></blockquote><h4 id="1-有向图数据结构"><a href="#1-有向图数据结构" class="headerlink" title="1.有向图数据结构"></a>1.有向图数据结构</h4><pre><code>public class DiGraph {    private int v; //顶点数目    private int e; //边数    private LinkedList&lt;Integer&gt;[] adj; //邻接表    //创建含有v个顶点但没有边的有向图    public DiGraph(int v) {        this.v = v;        this.e = 0;        adj = new LinkedList[v];        for(int i=0;i&lt;v;++i)            adj[i] = new LinkedList&lt;&gt;();    }    //从输入流中读取一副有向图    public DiGraph(InputStream input) {        BufferedReader reader = new BufferedReader(new InputStreamReader(input));        String value = null;        try {            int v = Integer.parseInt(reader.readLine());            this.v = v;            adj = (LinkedList&lt;Integer&gt;[]) new LinkedList[v];            for(int i = 0 ; i &lt; v;i++)                adj[i] = new LinkedList&lt;&gt;();            int e = Integer.parseInt(reader.readLine());            for(int i=0; i&lt;e; i++){                String[] str = reader.readLine().split(" +");                addEdge(Integer.parseInt(str[0]),Integer.parseInt(str[1]));            }        } catch (IOException e1) {            e1.printStackTrace();        } finally {            try {                reader.close();            } catch (IOException e1) {                e1.printStackTrace();            }        }    }    //顶点总数    public int V(){ return v; }    //边总数    public int E(){ return e;}    //向图中添加一条边 v -&gt; w    public void addEdge(int v,int w){        adj[v].add(w);        e++;    }    //由v指出的所有边连接的所有顶点    public Iterable&lt;Integer&gt; adj(int v){ return adj[v]; }    //该图的反向图    public DiGraph reverse(){        DiGraph r = new DiGraph(v);        for(int i=0;i&lt;v;++i) {            for (int w : adj(i))                r.addEdge(w, i);        }        return r;    }    //字符串表示    public String toString(){        String s = V() + "vertices, " + E() + " edges\n";        for(int v = 0;v &lt; V();v++){            s += v + ": ";            for(int w : adj(v))                s += w + " ";            s += "\n";        }        return s;    }}</code></pre><h4 id="2-使用深度优先搜索解决单点可达性"><a href="#2-使用深度优先搜索解决单点可达性" class="headerlink" title="2.使用深度优先搜索解决单点可达性"></a>2.使用深度优先搜索解决单点可达性</h4><blockquote><p>概述: 给定一副有向图和一个起点s,是否存在一条从s到达给定顶点v的有向路径</p><p>思路: 无向图的深度优先搜索稍作更改即可</p></blockquote><pre><code>public class DirectedDFS {    private boolean[] marked;   //标记顶点是否被访问    //在有向图g中找到从s可达的所有顶点    public DirectedDFS(DiGraph g,int s) {        marked = new boolean[g.V()];        dfs(g,s);    }    //在g中找到从source中的所有顶点可达的所有顶点    public DirectedDFS(DiGraph g,Iterable&lt;Integer&gt; source){        marked = new boolean[g.V()];        source.forEach(e -&gt; {            if(!marked[e]) dfs(g,e);        });    }    //与无向图的深度优先搜索相同    private void dfs(DiGraph g,int v){        marked[v] = true;        for(int w : g.adj(v))            if(!marked[w]) dfs(g,w);    }    //v是否可达    public boolean marked(int v){ return marked[v]; }}</code></pre><h4 id="3-有向图的路径"><a href="#3-有向图的路径" class="headerlink" title="3.有向图的路径"></a>3.有向图的路径</h4><blockquote><p>概述: 和无向图中深度优先搜索查找路径与广度优先搜索查找路径相同,只需将无向图对象改为有向图对象即可</p></blockquote><h4 id="4-有向图中的环"><a href="#4-有向图中的环" class="headerlink" title="4.有向图中的环"></a>4.有向图中的环</h4><blockquote><p>概述: 有向图中是否存在有向环,如果有找出一个有向环</p><p>思路: 对深度优先搜索稍作改动即可,递归遍历中内层遍历到外层经过的顶点则形成有向环</p><p>​      因此额外维护一个数组标记正在递归遍历的顶点,当层递归结束回到上层时取消标记</p><p>​      当递归内层访问到外层标记的顶点时形成有向环</p><p>​      即: 如果把递归调用看做入栈出栈过程,如果遍历到了栈内的已经标记过的顶点则形成有向环</p></blockquote><pre><code>public class DirectedCircle {    private boolean[] marked;   //标记是否被访问    private int[] edgeTo;       //记录路径    private ArrayDeque&lt;Integer&gt; circle; //有向环中的所有顶点(若存在)    private boolean[] onStack;          //标记递归调用的栈上的所有顶点    public DirectedCircle(DiGraph g) {        onStack = new boolean[g.V()];        marked = new boolean[g.V()];        edgeTo = new int[g.V()];        for(int v=0;v&lt;g.V();++v)            if(!marked[v]) dfs(g,v);    }    private void dfs(DiGraph g,int v){   //深度优先搜索        onStack[v] = true;  //递归进入: 入栈时标记该顶点为true        marked[v] = true;   //标记当前顶点被遍历过        for(int w : g.adj(v)) {            if (hasCycle()) return;            else if(!marked[w]){                edgeTo[w] = v;  //记录路径 v -&gt; w                dfs(g,w);            }            else if(onStack[w]){    //如果遍历到已经遍历过的顶点,且在递归调用的栈中,则形成有向环                circle = new ArrayDeque&lt;&gt;();                for(int x=v;x!=w;x=edgeTo[x])   //将有向环保存到circle中                    circle.push(x);                circle.push(w);                circle.push(v);            }        }        onStack[v] = false; //递归出去: 出栈时标记该顶点为false    }    //是否含有有向环    public boolean hasCycle(){ return circle != null;}    //有向环中的所有顶点    public Iterable&lt;Integer&gt; cycle(){ return circle; }}</code></pre><h4 id="5-有向图中基于深度优先搜索的顶点排序"><a href="#5-有向图中基于深度优先搜索的顶点排序" class="headerlink" title="5.有向图中基于深度优先搜索的顶点排序"></a>5.有向图中基于深度优先搜索的顶点排序</h4><blockquote><p>意义: 有向无环图的逆后序排列即为该图的拓扑排序</p></blockquote><pre><code>public class DepthFirstOrder {    private boolean[] marked;    private Queue&lt;Integer&gt; pre;                 //所有顶点的前序排列    private Queue&lt;Integer&gt; post;                //所有顶点的后序排列    private ArrayDeque&lt;Integer&gt; reversePost;    //所有顶点的逆后序排列(若为有向无环图,则就是拓扑排序)    public DepthFirstOrder(DiGraph g) {        pre = new ArrayDeque&lt;&gt;();        post = new ArrayDeque&lt;&gt;();        reversePost = new ArrayDeque&lt;&gt;();        marked = new boolean[g.V()];        for(int v=0;v&lt;g.V();++v)            if(!marked[v]) dfs(g,v);    }    private void dfs(DiGraph g, int v){        pre.offer(v);       //前序排列: 递归进入时顺序        marked[v] = true;        for(int w : g.adj(v))            if(!marked[w]) dfs(g,w);        post.offer(v);      //后序排列: 递归出去时顺序        reversePost.push(v);//逆后序排列: 后序排列的反序,后序排列压入栈中即可    }    public Iterable&lt;Integer&gt; pre(){ return pre; }    public Iterable&lt;Integer&gt; post(){ return post; }    public Iterable&lt;Integer&gt; reversePost(){ return reversePost; }}</code></pre><h4 id="6-拓扑排序"><a href="#6-拓扑排序" class="headerlink" title="6.拓扑排序"></a>6.拓扑排序</h4><blockquote><p>概述: 只有有向无环图才能进行拓扑排序</p><p>思路: 有向无环图的深度优先搜索的逆后序排列即为拓扑排序</p></blockquote><pre><code>public class TopoLogical {    private Iterable&lt;Integer&gt; order; //顶点拓扑排序    public TopoLogical(DiGraph g) {        if(!new DirectedCircle(g).hasCycle())   //1. 有向无环图            order = new DepthFirstOrder(g).reversePost(); //2.逆后序排列即为拓扑排序    }    public Iterable&lt;Integer&gt; order(){ return order; }    public boolean isDAG(){ return order != null; }}</code></pre><h4 id="7-找出有向图的所有强连通分量-kosaraju算法"><a href="#7-找出有向图的所有强连通分量-kosaraju算法" class="headerlink" title="7.找出有向图的所有强连通分量(kosaraju算法)"></a>7.找出有向图的所有强连通分量(kosaraju算法)</h4><blockquote><p>实现步骤: </p><p>​    1.求出给定的有向图g的反向图gr的逆后序排列</p><p>​    2.在g中进行标准的深度优先搜索,但是要按照第一步中获得的逆后序排列顺序进行</p><p>​    3.在构造函数中,所有在同一个dfs()调用中被访问的顶点都在同一个强连通分量中</p><p>简单思考: </p><p>​    将有向图的每个强连通分量看做一个整体,则形成一个新的有向无环图,</p><p>​    此时每个顶点表示一个强连通分量,我们只要每次只遍历一个顶点,就能找到一个强连通分量</p><p>证明: 参考算法第四版证明下面两条即可</p><p><strong>1.</strong>每个和s强连通的顶点v都会在构造函数调用的dfs(g,s)中被访问到</p><p>​             反证: 假如一个和s强连通的顶点v不会再dfs(g,s)中被访问,因为存在s-&gt;v路径,所以v在之前肯定</p><p>​                       被访问过,又s与v强连通即v-&gt;s存在路径,所以访问v时s一定被访问,后续就不会调用dfs(g,s),矛盾</p><p><strong>2.</strong>构造函数的调用的dfs(g,s)所到达的任意顶点v都必然和s强连通</p><p>​            如果dfs(g,s)到达某顶点v,则<strong>g 中 s -&gt; v 存在</strong>,且反向图gr的逆后序排列中s在v前面</p><p>​            目前只需要证明v-&gt;s存在即可证明s与v强连通,即<strong>只需证明反向图gr中s-&gt;v连通</strong></p><p>​            因为gr逆后序排列中s在v前面,且gr中v-&gt;s连通(因为g中s-v连通),因此只有一种可能</p><p>​                case1: dfs(gr,v)调用并结束在dfs(gr,s)之前(不可能,v-&gt;s不连通)</p><p>​                case2: dfs(gr,v)调用并结束在dfs(gr,s)调用中间(必为此情况: 此时gr中s-&gt;v连通)</p></blockquote><pre><code>public class KosarajuSCC {    private boolean[] marked;    private int[] id;       //维护顶点的强连通分量值    private int count;      //连通分量个数    public KosarajuSCC(DiGraph g) {        marked = new boolean[g.V()];        id = new int[g.V()];        for(int s : new DepthFirstOrder(g.reverse()).reversePost()) //1,2.按照反向图的逆后序排列进行深度优先搜索            if(!marked[s]){                dfs(g,s);       //3.每次执行访问到的所有顶点都在一个强连通分量中                ++count;            }    }    private void dfs(DiGraph g,int v){        marked[v] = true;        id[v] = count;      //标记当前顶点强连通分量值        for(int w : g.adj(v))            if(!marked[w]) dfs(g,w);    }    //顶点v与w是否强连通    public boolean stronglyConnected(int v,int w){ return id[v] == id[w]; }    //顶点v的强连通分量值    public int id(int v){ return id[v]; }    //强连通分量个数    public int count(){ return count; }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无向图</title>
      <link href="/2019/05/14/Undirectedgraph/"/>
      <url>/2019/05/14/Undirectedgraph/</url>
      
        <content type="html"><![CDATA[<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><blockquote><p><strong>概述:</strong> 在此使用邻接表的数据结构表示无向图</p></blockquote><h4 id="1-无向图数据结构"><a href="#1-无向图数据结构" class="headerlink" title="1.无向图数据结构"></a>1.无向图数据结构</h4><pre><code>public class Graph {    private int v; //顶点数目    private int e; //边数    private LinkedList&lt;Integer&gt;[] adj; //邻接表    //创建v个顶点,没有边的图    public Graph(int v){        this.v = v;        this.e = 0;        //初始化邻接表        adj = (LinkedList&lt;Integer&gt;[]) new LinkedList[v];        for(int i = 0 ; i &lt; v;i++)            adj[i] = new LinkedList&lt;Integer&gt;();    }    //从标准输入流读取一幅图,给定顶点数,与边数,然后读入所有边    public Graph(InputStream in){        BufferedReader reader = new BufferedReader(new InputStreamReader(in));        String value = null;        try {            int v = Integer.parseInt(reader.readLine());            this.v = v;            adj = (LinkedList&lt;Integer&gt;[]) new LinkedList[v];            for(int i = 0 ; i &lt; v;i++)                adj[i] = new LinkedList&lt;Integer&gt;();            int e = Integer.parseInt(reader.readLine());            for(int i=0; i&lt;e; i++){                String[] str = reader.readLine().split(" ");                addEdge(Integer.parseInt(str[0]),Integer.parseInt(str[1]));            }        } catch (IOException e1) {            e1.printStackTrace();        }    }    //顶点数    public int V(){ return v; }    //边数    public int E(){ return e;}    //向图中添加一条边v-w    public void addEdge(int v, int w){        adj[v].add(w);        adj[w].add(v);        e++;    }    //和v相邻的所有顶点    public Iterable&lt;Integer&gt; adj(int v){ return adj[v]; }    //对象字符串表示(邻接表字符串表示)    public String toString(){        String s = V() + "vertices, " + E() + " edges\n";        for(int v = 0;v &lt; V();v++){            s += v + ": ";            for(int w : adj(v))                s += w + " ";            s += "\n";        }        return s;    }}</code></pre><h4 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2.深度优先搜索"></a>2.深度优先搜索</h4><blockquote><p>概述:给定一个图和起点s,遍历所有与起点s连通的顶点</p><p>思路: </p><p>1.将起点s标记为已访问</p><p>2.递归的遍历它的所有没有被标记过的邻居顶点</p></blockquote><pre><code>public class DepthFirstSearch {    private boolean[] marked;   //用来标记顶点是否被访问过    private int count;          //统计    public DepthFirstSearch(Graph g,int s){        marked = new boolean[g.V()];        dfs(g,s);   //从起点s开始遍历    }    private void dfs(Graph g,int v){        marked[v] = true;           //被访问过的顶点标记为true        count++;        for(int w : g.adj(v))       //遍历其邻居顶点            if(!marked[w]) dfs(g,w);    //递归遍历没有被访问过的顶点(使用FIFO队列代替递归即可变成广度优先搜索)    }    public boolean marked(int v){ return marked[v]; }    public int count(){ return count; }}</code></pre><h4 id="3-使用深度优先搜索解决单点路径问题"><a href="#3-使用深度优先搜索解决单点路径问题" class="headerlink" title="3.使用深度优先搜索解决单点路径问题"></a>3.使用深度优先搜索解决单点路径问题</h4><blockquote><p>概述: 给定一幅图和一个起点s,找出是否存在从s到给定的一个终点s的一条路径,如果有,找出该路径</p><p>思路: 在深度优先搜索的基础上维护一个数组,索引为当前顶点,值保存前一个连通顶点即可</p></blockquote><pre><code>public class DepthFirstPaths {    private boolean[] marked;    private int[] edgeTo;   //维护数组,索引为当前顶点,值保存前一个连通的顶点    private final int s;    //开始顶点    public DepthFirstPaths(Graph g,int s) {//给定一个图和开始顶点s        marked = new boolean[g.V()];        edgeTo = new int[g.V()];        this.s = s;        dfs(g,s);    }    private void dfs(Graph g,int v){    //与深度优先搜索相同,只须额外维护一个保存路径信息的数组        marked[v] = true;        for(int w : g.adj(v))            if(!marked[w]){                edgeTo[w] = v;  //维护与其连通的前一个顶点                dfs(g, w);            }    }    public boolean hasPathTo(int v){ return marked[v]; }    //起点s与给定的顶点v是否连通    public Iterable&lt;Integer&gt; pathTo(int v){ //获取与顶点v到起点s的一条路径,在edgeTo数组中从v找到s即可        if(!hasPathTo(v)) return null;        ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();        for(int x=v;x!=s;x=edgeTo[x]) stack.push(x);        stack.push(s);        return stack;    }}</code></pre><h4 id="4-深度优先搜索搜索最短路径"><a href="#4-深度优先搜索搜索最短路径" class="headerlink" title="4.深度优先搜索搜索最短路径"></a>4.深度优先搜索搜索最短路径</h4><pre><code>/** * 深度优先搜索搜索最短路径 * 思路: 在深度优先搜索查找单点路径的基础上稍做修改,维护一个起点s,一个数组min, *       索引为顶点v,值min[v]记录了起点s到顶点v的路径值(在此用递归层数表示) *       遍历所有经过的路径,记录最小值的路径即可 */public class ShortPathDFS {    private boolean[] marked; //标记是否被访问过    private int count;       //记录递归层数,同时也代表了距离起点的路径距离    private int[] edgeTo;    //记录路径,索引为顶点,值为顶点相连的前一个顶点    private final int s;     //起点    private int[] min;       //记录起点到当前顶点v的距离min[v]值表示    public ShortPathDFS(Graph g,int s) {        marked = new boolean[g.V()];        edgeTo = new int[g.V()];        min = new int[g.V()];        this.s = s;        dfs(g,s);   //从起点开始进行深度优先搜索遍历    }    private void dfs(Graph g,int v){        marked[v] = true;        ++count;        min[v] = count;        for(int w : g.adj(v)) {            if (!marked[w]) {                if(min[w] != 0 &amp;&amp; min[w] &lt; count+1) continue; //此时下层顶点已经记录的路径更小,无需再遍历更新最短路径                edgeTo[w] = v;      //如果有更小路径则更新路径                dfs(g, w);            }        }        marked[v] = false;  //递归返回上层时,下层顶点全部标记为未访问,这样可以继续遍历所有上层顶点到下层顶点的其他路径        --count;    //递归返回上层,层数-1,即路径距离-1    }    public boolean hasPathTo(int v){ return min[v] != 0; }    public Iterable&lt;Integer&gt; pathTo(int v){   //获取起点s到v的最短路径        if(!hasPathTo(v)) return null;        ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();        for(int x=v;x!=s;x=edgeTo[x]) stack.push(x);        stack.push(s);        return stack;    }    public boolean marked(int v){ return marked[v]; }}</code></pre><h4 id="5-深度优先搜索找出图中的所有连通分量"><a href="#5-深度优先搜索找出图中的所有连通分量" class="headerlink" title="5.深度优先搜索找出图中的所有连通分量"></a>5.深度优先搜索找出图中的所有连通分量</h4><blockquote><p>概述: 连通分量即为图中的极大连通子图</p><p>思路: 使用深度优先搜索遍历,执行一次即可获取一个连通分量,如果存在没有遍历过的顶点,则继续对该顶点进行深度优先搜索,此时又获取一个连通分量,直到所有顶点都被遍历过为止</p></blockquote><pre><code>public class CC {    private boolean[] marked;    private int[] id;   //额外维护一个数组标记顶点连通分量,索引为顶点,值相同的表示为同一连通分量内的顶点    private int count;  //统计连通分量个数    public CC(Graph g) {        marked = new boolean[g.V()];        id = new int[g.V()];        for(int s = 0;s&lt;g.V();s++)            if(!marked[s]) {    //遍历没有遍历过的顶点(没有遍历过的即为一个新连通分量)                dfs(g,s);       //使用深度优先搜索遍历与s连通的所有顶点并标记                ++count;        //统计连通分量            }    }    private void dfs(Graph g,int v){        marked[v] = true;        id[v] = count;          //标记该顶点的连通分量        for(int w : g.adj(v))            if(!marked[w]) dfs(g,w);    }    public boolean connected(int v, int w){ return id[v] == id[w]; }   //两个顶点标记的连通分量相同时即连通    public int id(int v){ return id[v]; }       //返回标记的连通分量    public int count(){ return count; }         //返回连通分量数量}</code></pre><h4 id="6-深度优先搜索判断是否为有环图"><a href="#6-深度优先搜索判断是否为有环图" class="headerlink" title="6.深度优先搜索判断是否为有环图"></a>6.深度优先搜索判断是否为有环图</h4><pre><code>/** * 是否为有环图(不考虑自环与平行边) * 思路: 对图的每一个连通分量通过深度优先搜索遍历 *       记录前一个顶点u,当前节点v,下一个将遍历的节点w *       如果顶点w已遍历过且不是前一个顶点u,则形成了环 */public class Cycle {    private boolean[] marked;    private boolean hasCycle;       //标记是否有环    public Cycle(Graph g) {        marked = new boolean[g.V()];        for(int s=0;s&lt;g.V();++s)    //对每个连通分量进行遍历            if(!marked[s]) dfs(g,s,s);    }    private void dfs(Graph g,int v,int u){        marked[v] = true;        for(int w : g.adj(v))            if(!marked[w]) dfs(g,w,v);            else if(w != u) hasCycle = true;    //将遍历的顶点w已遍历过且不是前一个顶点u时形成环    }    public boolean hasCycle(){ return hasCycle; }}</code></pre><h4 id="7-深度优先搜索判断是否为二分图"><a href="#7-深度优先搜索判断是否为二分图" class="headerlink" title="7.深度优先搜索判断是否为二分图"></a>7.深度优先搜索判断是否为二分图</h4><pre><code>/** * 判断是否为二分图 * 等价于: 能够用两种颜色将图的所有顶点着色,使得任意一条边的两个顶点颜色都不同 * 思路: 使用深度优先搜索对图进行着色,保证一条边的两个顶点颜色不同, *       如果遍历到已着色顶点,则进行判断是否还满足条件,如果不满足则不是二分图 */public class TwoColor {    private boolean[] marked;    private boolean[] color;    //额外维护数组维护顶点的颜色,索引为顶点v,值color[v]为颜色值    private boolean isTwoColor = true;  //标记是否为二分图,默认为true    public TwoColor(Graph g) {        marked = new boolean[g.V()];        color = new boolean[g.V()];        for(int s=0;s&lt;g.V();++s)    //深度优先搜索遍历所有连通分量,检测是否满足颜色条件            if(!marked[s]) dfs(g,s);    }    private void dfs(Graph g,int v){        marked[v] = true;        for(int w : g.adj(v))            if(!marked[w]){                color[w] = !color[v];   //正常着色,此时满足条件                dfs(g,w);            }   //遍历到已访问过(已着色)的顶点,如果一条边的两个顶点颜色相同,则不是二分图            else if(color[w] == color[v]) isTwoColor = false;    }    public boolean isToColor(){ return isTwoColor;}}</code></pre><h4 id="8-广度优先搜索"><a href="#8-广度优先搜索" class="headerlink" title="8.广度优先搜索"></a>8.广度优先搜索</h4><blockquote><p>概述: 广度优先搜索中按照与起点的距离顺序遍历所有连通顶点,即从起点开始,依次遍历相邻节点</p><p>思路: 使用FIFO(先进先出)队列代替深度优先搜索的递归(LIFO,后进先出)即可实现广度优先搜索</p></blockquote><h4 id="9-广度优先搜索搜索最短路径"><a href="#9-广度优先搜索搜索最短路径" class="headerlink" title="9.广度优先搜索搜索最短路径"></a>9.广度优先搜索搜索最短路径</h4><pre><code>public class BreadthFirstPaths {    private boolean[] marked;    private int[] edgeTo;   //维护数组,索引为当前顶点,值保存前一个连通的顶点    private final int s;    //开始顶点    public BreadthFirstPaths(Graph g,int s) { //给定一个图和开始顶点s        marked = new boolean[g.V()];        edgeTo = new int[g.V()];        this.s = s;        bfs(g,s);    }    private void bfs(Graph g,int s){        marked[s] = true;       //标记        ArrayDeque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(s);         //加入队列        while(!queue.isEmpty()){    //遍历队列,队列代替了深度优先搜索递归(栈)调用,变成广度优先搜索            int v = queue.poll();   //出队并遍历没有被访问过的顶点            for(int w : g.adj(v)){                if(marked[w]) continue;                edgeTo[w] = v;      //保存最短路径中与其相邻上一个的顶点                marked[w] = true;   //标记                queue.offer(w);     //入队            }        }    }    public boolean hasPathTo(int v){ return marked[v];}    public Iterable&lt;Integer&gt; pathTo(int v){  //获取与顶点v到起点s的一条路径,在edgeTo数组中从v找到s即可        if(!hasPathTo(v)) return null;        ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();        for(int x=v;x!=s;x=edgeTo[x]) stack.push(x);        stack.push(s);        return stack;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准红黑树</title>
      <link href="/2019/01/23/RedBlackTree/"/>
      <url>/2019/01/23/RedBlackTree/</url>
      
        <content type="html"><![CDATA[<h3 id="标准红黑树"><a href="#标准红黑树" class="headerlink" title="标准红黑树"></a>标准红黑树</h3><blockquote><p><strong>概述:</strong> 标准红黑树是2-3-4树的一种表示,</p><p><strong>特性:</strong></p><ul><li>1.节点是红色或黑色。</li></ul><ul><li>2.根是黑色。</li><li>3.所有叶子都是黑色（叶子是NIL节点）。</li><li>4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红节点。）</li><li>5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。</li></ul></blockquote><pre><code>/** * 标准红黑树: 参考TreeMap源码 * 1.节点是红色或黑色。 * 2.根是黑色。 * 3.所有叶子都是黑色（叶子是NIL节点）。 * 4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） * 5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。 */public class RedBlackBST&lt;K,V&gt; {    private Comparator&lt;? super K&gt; comparator;    private boolean RED = true;    private boolean BLACK = false;    private Node&lt;K,V&gt; root;    private int n;    private class Node&lt;K,V&gt;{        K key;        V value;        Node left;        Node right;        Node parent;        boolean color;        public Node(K key, V value, Node parent, boolean color) {            this.key = key;            this.value = value;            this.parent = parent;            this.color = color;        }    }    public RedBlackBST(){        comparator = (x,y) -&gt;{            if(!(x instanceof Comparable) || !(y instanceof Comparable))                throw new RuntimeException("error");            return ((Comparable) x).compareTo(y);        };    }    public RedBlackBST(Comparator&lt;? super K&gt; comparator){ this.comparator = comparator; }    public int size(){ return n; }    //获取    public V get(K key){        Node&lt;K,V&gt; x = getNode(key);        return x == null ? null : x.value;    }    private Node&lt;K,V&gt; getNode(K key){        Node&lt;K,V&gt; x = root;        int cmp;        while(x != null){            cmp = comparator.compare(key,x.key);            if(cmp &gt; 0) x = x.right;            else if(cmp &lt; 0) x = x.left;            else return x;        }        return null;    }    /**     * 插入     * 概述: 按照二叉查找树插入方式进行插入,然后自底向上进行平衡修复     */    public void put(K key,V value){        if(key == null) return;        Node&lt;K,V&gt; x = root;        if(x == null){ //case1: 插入根节点            root = new Node&lt;&gt;(key,value,null,RED);            root.color = BLACK;            n = 1;            return;        }        int cmp;        Node&lt;K,V&gt; parent;        do {            parent = x;            cmp = comparator.compare(key,x.key);            if (cmp &gt; 0) x = x.right;            else if (cmp &lt; 0) x = x.left;            else {                x.value = value;                return;            }        }while(x != null);        Node&lt;K,V&gt; e = new Node&lt;&gt;(key,value,parent,RED);        if(cmp &gt; 0) parent.right = e;        else parent.left = e;        //插入节点后自底向上进行平衡修复        fixAfterPut(e);        ++n;    }    /**     * 删除  (可不拆分处理参考后面remove方法)     * 概述: 借助删除最小节点方法(deleteMin)     *   case1: 待删除节点存在右子树,直接用右子树最小节点替换掉待删除节点,然后删除最小节点     *   case2: 待删除节点右子树为空,左子树不为空(此时只有一个左节点,且为红节点)     *   case3: 待删除节点左右子树都为空,删除当前节点(即最小节点)     */    public void delete(K key){        Node&lt;K,V&gt; p = getNode(key);        if(p == null) return;        if(p.right != null) { //1.右子树不为空,用右子树最小节点替换掉待删除节点            Node&lt;K, V&gt; s = min(p.right);            p.key = s.key;            p.value = s.value;            deleteMin(s);        }        else if(p.left != null){ // 2.右子树为空, 左子树不为空(此时只有一个左节点且为红节点)            p.key = (K)p.left.key;            p.value = (V)p.left.value;            //deleteMin(p.left); //与下面2行代码等价            p.left.parent = null;            p.left = null;        }        else deleteMin(p); // 3.左右子树都为空时    }    //删除最小    public void deleteMin(){ deleteMin(root); }    /**     * 删除指定子树的最小节点     * 概述: 分2种情况处理(最小节点不存在左子节点)     *      1. 待删除节点(最小节点)只有一个右子节点(此时该右子节点为红节点)     *      2. 待删除节点没有子节点     * @param h     */    private void deleteMin(Node&lt;K,V&gt; h){        if(h == null) return;        Node&lt;K,V&gt; min = min(h);        Node&lt;K,V&gt; replace = min.right;        if(replace != null){ //1. 最小节点只有一个右子节点(一定红节点)            min.key = replace.key;            min.value = replace.value;            min.right = null;            replace.parent = null;        }        else{ //2. 最小节点没有右子节点,即左右子节点都为空            if(!isRED(min)) fixAfterDelete(min); //删除的为黑色节点,需要平衡修复            if(min == leftOf(min.parent))                min.parent.left = null;            else if(min == rightOf(min.parent)) //p.right == min(p.right),一直从root节点删除则不需要                min.parent.right = null;            else                root = null;            min.parent = null;        }        --n;    }    public K min(){ return min(root).key; }    private Node&lt;K,V&gt; min(Node&lt;K,V&gt; h){        if(h == null) return null;        while(h.left != null)            h = h.left;        return h;    }    /**     * 标准删除     * 概述: 不借助deleteMin,将上面delete方法稍作修改即可     */    public void remove(K key){        Node&lt;K,V&gt; p = getNode(key);        if(p == null) return;        if(p.left != null &amp;&amp; p.right != null){            Node&lt;K,V&gt; s = min(p.right);            p.key = s.key;            p.value = s.value;            p = s;        }        Node&lt;K,V&gt; replace = p.left != null ? p.left : p.right;        if(replace != null){ //replace必为红节点            p.key = replace.key;            p.value = replace.value;            p.left = null;            p.right = null;            replace.parent = null;        }        else{ //p节点没有子节点时            if(!isRED(p)) fixAfterDelete(p); //修复            if(p == leftOf(p.parent))                p.parent.left = null;            else if(p == rightOf(p.parent))                p.parent.right = null;            else root = null;            p.parent = null;        }        --n;    }    //使用leftOf 与 rightOf 方便处理null值    private Node&lt;K,V&gt; leftOf(Node&lt;K,V&gt; h){ return h == null ? null : h.left; }    private Node&lt;K,V&gt; rightOf(Node&lt;K,V&gt; h){ return h == null ? null : h.right; }    /******************************************     ************* 核心方法 *******************     ******************************************/    //左旋    private void rotateLeft(Node&lt;K,V&gt; h){        if(h == null) return;        Node&lt;K,V&gt; x = h.right;        //左旋        h.right = x.left;        x.left = h;        //更新parent        if(h.right != null) h.right.parent = h;        x.parent = h.parent;        if(x.parent == null) root = x;        else if(h == x.parent.left) x.parent.left = x;        else x.parent.right = x;        h.parent = x;    }    //右旋    private void rotateRight(Node&lt;K,V&gt; h){        if(h == null) return;        Node&lt;K,V&gt; x = h.left;        //右旋        h.left = x.right;        x.right = h;        //更新parent        if(h.left != null) h.left.parent = h;        x.parent = h.parent;        if(x.parent == null) root = x;        else if(h == x.parent.left) x.parent.left = x;        else x.parent.right = x;        h.parent = x;    }    /**     * 插入后修复     * 分情况处理: 具体处理看代码     * case1: 插入为根节点,直接插入变为黑色(put方法中已处理)     * case2: 父节点为黑色时插入红节点不影响平衡     * case3:     *   case3.1:父节点为红色,叔叔节点(父节点的兄弟节点)为红色     *   case3.2:父节点为红色,叔叔节点为黑色     * 核心思想就是变色修复性质4(消除连续红节点),然后旋转保证黑高不变(性质5)     * 具体情况参考代码或者图解,关键是清楚涉及变动分支的黑高变化情况     */    private void fixAfterPut(Node&lt;K,V&gt; h){        while(h != null &amp;&amp; h != root &amp;&amp; isRED(h.parent)){ //此时h, h.parent均不为null            if(h.parent == leftOf(h.parent.parent)){ //此时h.parent.parent不为null                Node&lt;K,V&gt; y = rightOf(h.parent.parent);                if(isRED(y)){               //case3.1修复: 父节点与叔叔节点变黑,祖父节点(父节点的父节点)变红,                    h.parent.color = BLACK; //相当于子树黑高+1,根节点黑高-1,保持黑高不变                    y.color = BLACK;        //接着使用同样方式向上修复变红后的祖父节点                    h.parent.parent.color = RED;                    h = h.parent.parent;                }                else{                       //case3.2修复:将一个红节点颜色转移到祖父节点的右子树,且保证其黑高不变                  if(h == rightOf(h.parent)) {//转为2个连续的左红节点处理                      rotateLeft(h.parent);                      h = h.left;                  }                  h.parent.color = BLACK;   //2个连续红节点都为左节点,变色右旋之后变动分支黑高不变                  h.parent.parent.color = RED;                  rotateRight(h.parent.parent);                  //此时修复完成,将跳出循环                }            }            else{ //于上面对称                Node&lt;K,V&gt; x = leftOf(h.parent.parent);                if(isRED(x)){                   //case3.1修复                    h.parent.color = BLACK;                    x.color = BLACK;                    h.parent.parent.color = RED;                    h = h.parent.parent;                }                else{                           //case3.2修复                    if (h == leftOf(h.parent)) {                        rotateRight(h.parent);                        h = h.right;                    }                    h.parent.color = BLACK;                    h.parent.parent.color = RED;                    rotateLeft(h.parent.parent);                    //此时修复完成,将跳出循环                }            }        }        root.color = BLACK;    }    /**     * 删除时修复     * 概述: 删除黑节点后要想办法让当前分支黑高+1,可转换为(当前分支的父节点黑高+1,兄弟节点黑高-1)     * 分情况处理: 具体处理细节看代码     * case1: 待删除节点为红节点,直接删除不影响平衡     * case2:     *    case2.1: 待删除节点为黑节点,其兄弟节点为红节点     *    case2.2: (待删除节点为黑节点,其兄弟节点(sib)为黑节点)     *       case2.2.1: 再划分,兄弟节点(sib)的子节点均为黑     *       case2.2.2: 兄弟节点(sib)的子节点存在红节点     */    private void fixAfterDelete(Node&lt;K,V&gt; h){        //**case1: 在删除方法(delete,remove方法)中直接删除        while(h != root &amp;&amp; !isRED(h)){   //case2            if(h == leftOf(h.parent)) {                Node&lt;K, V&gt; sib = rightOf(h.parent);                if (isRED(sib)) {        //**case2.1处理: 变色左旋后转换为case2.2的情况                    sib.color = BLACK;                    sib.parent.color = RED;                    rotateLeft(sib.parent);                    sib = rightOf(h.parent);                }                //case2.2                if (!isRED(leftOf(sib)) &amp;&amp; !isRED(rightOf(sib))) { //**case2.2.1处理:                    sib.color = RED;        //此时兄弟节点黑高-1,问题转换为让父节点黑高+1,用同样方法处理父节点即可                    h = sib.parent;         //如果父节点为红,直接变黑即可,否则进入循环相同方法处理                } else {    //**case2.2.2处理: 大概考虑从sib借过来一个黑节点,sib黑高-1,sib的一个红节点变黑+1,黑高不变                    if (!isRED(sib.right)) {                        sib.left.color = BLACK; //sib.left为RED必不为null                        rotateRight(sib);                        sib = rightOf(h.parent);                    }       //处理后sib右子树黑高+1,左子树黑高不变                    sib.color = sib.parent.color;                    sib.right.color = BLACK;   //sib.right不可能为null,此处sib黑高+1,或者不变(经过前面if语句内处理已经+1)                    sib.parent.color = BLACK;                    rotateLeft(sib.parent); //旋转后sib的右子树黑高-1,左子树变为sib兄弟节点(h)的右子树黑高不变,h.left黑高+1                    break; //此时已达到平衡结束修复                }            }            else{ //与上面对称                Node&lt;K,V&gt; sib = leftOf(h.parent);                if(isRED(sib)){                    sib.color = BLACK;                    sib.parent.color = RED;                    rotateRight(sib.parent);                    sib = leftOf(h.parent);                }                if(!isRED(sib.left) &amp;&amp; !isRED(sib.right)){                    sib.color = RED;                    h = h.parent;                }                else{                    if(!isRED(sib.left)){                        sib.right.color = BLACK;                        rotateLeft(sib);                        sib = leftOf(h.parent);                    }                    sib.color = sib.parent.color;                    sib.parent.color = BLACK;                    sib.left.color = BLACK;                    rotateRight(sib.parent);                    break;                }            }        }        h.color = BLACK;    }    /******************************************     ************* 另一种递归实现 *******************     ******************************************/    //一种插入方法的递归实现,不同于上面put方法    public void add(K key,V value){        if(key == null) return;        root = add(root,key,value,false);        root.color = BLACK;    }    private Node&lt;K,V&gt; add(Node&lt;K,V&gt; h,K key,V value,boolean isRight){        if(h == null) return new Node(key,value,null,RED);//不需要维护parent节点        if(isRED(h.left) &amp;&amp; isRED(h.right)) flipColors(h); //沿着查找路径消除4节点        int cmp = comparator.compare(key,h.key);        if(cmp &gt; 0 ){            h.right = add(h.right,key,value,true);            if(isRED(h) &amp;&amp; isRED(h.right) &amp;&amp; !isRight) h = rotateL(h);            if(isRED(h.right) &amp;&amp; isRED(h.right.right)){ //逆着查找路径将右倾连续红节点转为4节点                h = rotateL(h);                h.color = BLACK;            }        }        else if(cmp &lt; 0){            h.left = add(h.left,key,value,false);            if(isRED(h) &amp;&amp; isRED(h.left) &amp;&amp; isRight) h = rotateR(h);            if(isRED(h.left) &amp;&amp; isRED(h.left.left)){ //逆着查找路径将左倾连续红节点转为4节点                h = rotateR(h);                h.color = BLACK;            }        }        else h.value = value;        return h;    }    private Node&lt;K,V&gt; rotateL(Node&lt;K,V&gt; h){        Node&lt;K,V&gt; x = h.right;        h.right = x.left;        x.left = h;        x.color = h.color;        h.color = RED;        return x;    }    private Node&lt;K,V&gt; rotateR(Node&lt;K,V&gt; h){        Node&lt;K,V&gt; x = h.left;        h.left = x.right;        x.right = h;        x.color = h.color;        h.color = RED;        return x;    }    private void flipColors(Node&lt;K,V&gt; h){        h.color = !h.color;        h.left.color = !h.left.color;        h.right.color = !h.right.color;    }    private boolean isRED(Node&lt;K,V&gt; h){        if(h == null) return false;        return h.color == RED;    }    //中序遍历方法    public Iterable&lt;K&gt; keys(){        ArrayDeque&lt;K&gt; queue = new ArrayDeque&lt;&gt;();        keys(root,queue);        return queue;    }    //中序遍历    public void keys(Node&lt;K,V&gt; x, Queue&lt;K&gt; queue){        if(x == null) return;        keys(x.left,queue);        queue.add(x.key);        keys(x.right,queue);    }    /******************************************     ************* 检测是否为红黑 **************     ******************************************/    //检查是否为红黑树    public boolean check(){        if(!isParent(root)) System.out.print("parent维护错误");        if(!isBST()) System.out.println("不是二叉树");        if(isRED(root)) System.out.println("违反性质2");        if(!is4()) System.out.println("违反性质4");        if(!is5()) System.out.println("违反性质5");        return isBST() &amp;&amp; !isRED(root) &amp;&amp; is4() &amp;&amp; is5();    }    //判断是否为二叉查找树    private boolean isBST(){ return isBST(root,null,null); }    private boolean isBST(Node&lt;K,V&gt; x,K max,K min){        if(x == null) return true;        if(max != null &amp;&amp; comparator.compare(x.key,max) &gt;= 0) return false;        if(min != null &amp;&amp; comparator.compare(x.key,min) &lt;= 0) return false;        return isBST(x.left,x.key,min) &amp;&amp; isBST(x.right,max,x.key);    }    //检查红黑树性质4    private boolean is4(){ return is4(root); }    private boolean is4(Node x){  //性质4        if(x == null) return true;        if(isRED(x) &amp;&amp; (isRED(x.left) || isRED(x.right))) return false;        return is4(x.left) &amp;&amp; is4(x.right);    }    //检查红黑树性质5    private boolean is5(){ //性质5        int black = 0;        Node x = root;        while(x != null){            if(!isRED(x)) black++;            x = x.left;        }        return is5(root,black);    }    private boolean is5(Node x,int black){        if(x == null) return black == 0;        if(!isRED(x)) black--;        return is5(x.left,black) &amp;&amp; is5(x.right,black);    }    //检查父节点是否维护正确    private boolean isParent(Node x){        if(x == null) return true;        if(x.left != null &amp;&amp; x.left.parent != x) return false;        if(x.right != null &amp;&amp; x.right.parent != x) return false;        return isParent(x.left) &amp;&amp; isParent(x.right);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表</title>
      <link href="/2019/01/05/HashST/"/>
      <url>/2019/01/05/HashST/</url>
      
        <content type="html"><![CDATA[<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><blockquote><p><strong>优点:</strong> 插入和查找操作的时间复杂度都是O(1) </p><p><strong>缺点:</strong> 性能的保证来自散列函数的质量,是无序符号表,不支持有序性相关操作,是以空间换取时间的数据结构.</p></blockquote><h4 id="1-基于拉链法的散列表"><a href="#1-基于拉链法的散列表" class="headerlink" title="1. 基于拉链法的散列表"></a>1. 基于拉链法的散列表</h4><blockquote><p><strong>概述:</strong> 通过链表方式处理碰撞冲突,将碰撞冲突的键放到链表中</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//基于拉链法的散列表</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SeparateChainingHashST</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INIT_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始容量,第一次put时分配</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//键值对数量</span>    <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//散列表</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        Node next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span>V value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算索引</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span>V value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>table <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> table<span class="token punctuation">.</span>length<span class="token operator">*</span><span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动扩充容量</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">,</span>pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//索引位置为空则直接添加</span>            table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//不为空则添加到链表末尾</span>            <span class="token keyword">do</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                pre <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算索引</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">,</span> pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> null<span class="token punctuation">)</span> pre<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//非链表头部删除</span>                <span class="token keyword">else</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//链表头删除</span>                <span class="token operator">--</span>n<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Iterable<span class="token operator">&lt;</span>K<span class="token operator">></span> <span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>K<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> table<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> x <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> queue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> table <span class="token operator">==</span> null <span class="token operator">?</span> INIT_CAPACITY <span class="token operator">:</span> table<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 常规除留余数法计算索引:  (key.hashCode() &amp; 0x7fffffff) % M,     *      其中M为哈希表长度,一般为质数,减少碰撞冲突     *  优化方式:     *        1. 当 M = 2^n(n为自然数)时，a % M = a &amp; (M - 1)     *           因此可使用与运算(&amp;)代替取余提高效率,key.hashCode() &amp; (2^n - 1)(相当于只取出二进制的前n位二进制数)     *        2. 但是M如果为非质数,会有较严重碰撞冲突,解决办法就是对key.hashCode()的高16位与低16位     *           进行异或减少这种影响,考虑到通过异或方式的开销,综合来说异或一次即可     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token keyword">return</span> key <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自动扩容: 原来的2倍     * 原索引: 取出前n位二进制数的值, 新索引取出前n+1位二进制的值(n为原来table长度)     *      即 新索引 = 原索引 + 第n+1二进制位的实际值,     *      因为二进制位只有0,1,因此只有2种情况(0时等于原索引,1时需要加上1代表的实际值)     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> table <span class="token operator">==</span> null<span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> table<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> newCap <span class="token operator">=</span> oldCap <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">?</span> INIT_CAPACITY  <span class="token operator">:</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//建立新散列表</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>table <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//遍历然后放入新的散列表中</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//单个元素之间放入</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果是多个元素的链表,则分成2个链表(新索引只有2种可能)</span>                        Node loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        Node hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token keyword">do</span><span class="token punctuation">{</span>                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//第n+1位二进制数为0时(n为原table长度)</span>                                <span class="token keyword">if</span><span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span> loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span> loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">else</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//第n+1位二进制数为1时(n为原table长度)</span>                                <span class="token keyword">if</span><span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span> hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span> hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//新索引和原索引相同(第n+1二进制位为0,n为原table长度)</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>i <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//新索引和原索引不同(第n+1二进制位为1,n为原table长度)</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-基于线性探测法的散列表"><a href="#1-基于线性探测法的散列表" class="headerlink" title="1. 基于线性探测法的散列表"></a>1. 基于线性探测法的散列表</h4><blockquote><p>*<em>优点: *</em></p><p>​    更容易进行序列化操作</p><p>​    键值对总数可预知时,可以创建完美哈希函数,处理效率高</p><p><strong>缺点:</strong></p><p>​    键值对数不能超过容量,当接近容量时会严重影响性能,达到一定程度必须扩容</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinearProbingHashST</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INIT_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化容量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最大容量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//容量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//键值对数量</span>    <span class="token keyword">private</span> K<span class="token punctuation">[</span><span class="token punctuation">]</span> keys<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用2个数组分别保存键值对</span>    <span class="token keyword">private</span> V<span class="token punctuation">[</span><span class="token punctuation">]</span> vals<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LinearProbingHashST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">(</span>INIT_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">LinearProbingHashST</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tableSizeFor</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取大于该值的最小2的幂</span>        m <span class="token operator">=</span> cap<span class="token punctuation">;</span>        n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        keys <span class="token operator">=</span> <span class="token punctuation">(</span>K<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        vals <span class="token operator">=</span> <span class="token punctuation">(</span>V<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取大于该值的最小2的幂</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> capacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//插入</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span>V value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">>=</span> m <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">resize</span><span class="token punctuation">(</span>m <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//扩大容量</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//遍历键簇</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已存在更新值</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//新键值对插入</span>        keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>        vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token operator">++</span>n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//遍历键簇</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//找到返回其值</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//没找到</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//遍历键簇,找到后设置为null</span>            i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>m<span class="token punctuation">;</span>        keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//修复null位置后面的键簇(重新插入即可)</span>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>m<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            K tempK <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            V tempV <span class="token operator">=</span> vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>            vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token operator">--</span>n<span class="token punctuation">;</span>            <span class="token function">put</span><span class="token punctuation">(</span>tempK<span class="token punctuation">,</span>tempV<span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">--</span>n<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;</span> m <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token function">resize</span><span class="token punctuation">(</span>m <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调整大小</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历</span>    <span class="token keyword">public</span> Iterable<span class="token operator">&lt;</span>K<span class="token operator">></span> <span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>K<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> queue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>K key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//自动调整容量</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>        LinearProbingHashST<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinearProbingHashST</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>            temp<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keys <span class="token operator">=</span> temp<span class="token punctuation">.</span>keys<span class="token punctuation">;</span>        vals <span class="token operator">=</span> temp<span class="token punctuation">.</span>vals<span class="token punctuation">;</span>        m <span class="token operator">=</span> temp<span class="token punctuation">.</span>m<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左倾红黑树</title>
      <link href="/2018/12/28/LLRedBlackTree/"/>
      <url>/2018/12/28/LLRedBlackTree/</url>
      
        <content type="html"><![CDATA[<h3 id="左倾红黑树"><a href="#左倾红黑树" class="headerlink" title="左倾红黑树"></a>左倾红黑树</h3><blockquote><p>概述: </p><p>​    通过二叉查找树可以发现,在最坏情况下(变成长链),性能很差,</p><p>​    因此理想的情况下就是构建一个完美平衡的树,然而维护完美平衡需要额外的开销</p><p>​    红黑树在性能和维护平衡之间进行协调</p><p>左倾红黑树特点:</p><p>​    2-3树的一种表示,红连接相连的节点为3节点,所有红连接为左倾</p></blockquote><pre><code>/** * 左倾红黑树: 详细请参考&lt;&lt;算法第四版&gt;&gt; * 红黑树的特性: *（1）每个节点或者是黑色，或者是红色。 *（2）根节点是黑色。 *（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] *（4）如果一个节点是红色的，则它的子节点必须是黑色的。 *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 */public class LLRedBlackBST&lt;Key,Value&gt; {    private Comparator comparator;    private Node root;    private boolean RED = true;    private boolean BLACK = false;    private class Node{        private Key key;        private Value val;        private Node left;        private Node right;        private int n;        private boolean color; //当前节点的颜色        public Node(Key key, Value val, int n, boolean color) {            this.key = key;            this.val = val;            this.n = n;            this.color = color;        }    }    public LLRedBlackBST(Comparator comparator) {        this.comparator = comparator;    }    /**************************************************     *  左倾红黑树特有实现(与二叉查找树不同的部分)     **************************************************/    public void put(Key key,Value val){        if(key == null) return;        root = put(root,key,val);        root.color = BLACK;    }    /**     * 插入     * 与二叉查找树相同方式进行插入,然后自底向上进行修复     * 如果插入后形成的为3节点则不需要处理,     * 如果形成了4节点则需要分解为3个2节点(此时高度会增加1打破平衡),     * 为了保证平衡,将其中的根节点传递到上层(与父节点合并为一个3节点或者4节点)(转换颜色即可,红连接相连为同一层)     * 以此类推,如果传递后还为4节点继续向上传递,仅当传递到root节点变为4节点时,树高会增加1,此时依然保持平衡     */    private Node put(Node h,Key key,Value val){        if(h == null) return new Node(key,val,1,RED);        int cmp = comparator.compare(key,h.key);        if(cmp &gt; 0) h.right = put(h.right,key,val);        else if(cmp &lt; 0) h.left = put(h.left,key,val);        else h.val = val;        //查找结束逆着查找路径进行平衡修复        return balance(h);    }    /**     * 删除最小值     * 对于红节点,可以直接删除一个节点不影响平衡     * 因此保证在删除时,查找的当前节点为红节点(3节点或者构造的4节点)     */    public void deleteMin(){        root = deleteMin(root);        if(root != null) root.color = BLACK;    }    private Node deleteMin(Node h){        if(h.left == null) return null;        //左子节点不是红节点,则需要先转换为红节点        if(!isRED(h.left) &amp;&amp; !isRED(h.left.left))            h = moveRedLeft(h); //将左节点转换为红节点        h.left = deleteMin(h.left);        return balance(h);  //删除成功后逆着删除路径修复    }    /**     * 删除最大值     * 只需将路径中左倾红连接转为右倾,然后就和删除最小值相同思路处理即可     */    public void deleteMax(){        root = deleteMax(root);        if(root != null) root.color = BLACK;    }    private Node deleteMax(Node h){        //将左倾红连接转为右倾        if(isRED(h.left)) h = rotateRight(h);        if(h.right == null) return null;        //当前节点右子节点不为红节点,则须先转为红节点        if(!isRED(h.right) &amp;&amp; !isRED(h.right.left))            h = moveRedRight(h);        h.right = deleteMax(h.right);        return balance(h); //删除结束后逆着删除路径修复    }    /**     *删除     * 概述: 找到待删除节点N,然后用该节点N的右子树的最小节点替换掉该节点即可     * 此时问题就转换为,删除待删除节点N的右子树的最小值,因此和删除最小值相同,     * 保证查找时,当前节点为红节点即可     */    public void delete(Key key){        if(key == null || !contains(key)) return;        root = delete(root,key);        if(root != null) root.color = BLACK;    }    private Node delete(Node h,Key key){        int cmp = comparator.compare(key,h.key);        if(cmp &lt; 0){            //下一步查询节点不为红节点则先转为红节点            if(!isRED(h.left) &amp;&amp; !isRED(h.left.left))                h = moveRedLeft(h);            h.left = delete(h.left,key);        }        else{//大于等于时放到一起,因为查找命中时(相等),要删除右子树最小节点            //此时要保证右子树根节点为红节点(可能需要向父节点借一个节点,此时命中节点可能被传递            //这时还需继续向右查找命中,再进行删除操作)            if(isRED(h.left)) {                h = rotateRight(h);                //右旋后当前节点变化须重新比较                cmp = comparator.compare(key,h.key);            }            if(cmp == 0 &amp;&amp; h.right == null) return null;            //下一步查询节点不为红节点则先转为红节点            if(!isRED(h.right) &amp;&amp; !isRED(h.right.left)) {                h = moveRedRight(h);                //转为红节点后当前节点变化,需要重新比较                cmp = comparator.compare(key,h.key);            }            if(cmp == 0){ //命中切右子树根节点为红节点时可以执行删除操作                Node x = min(h.right);                h.key = x.key;                h.val = x.val;                h.right = deleteMin(h.right);            }            else h.right = delete(h.right,key);        }        return balance(h); //逆着查找路径修复    }    /**************************************************     *  核心: 左倾红黑树辅助方法(详细情况参考算法第四版分情况图解)     **************************************************/    //是否为红节点    private boolean isRED(Node x){        if(x == null) return false;        return x.color == RED;    }    /**     * 修复为左倾红黑树     * 1.将右倾红连接转为左倾     * 2.将4节点分解为2个2节点和一个红节点(向上传递)     */    private Node balance(Node h){        if(!isRED(h.left) &amp;&amp; isRED(h.right)) h = rotateLeft(h);        if(isRED(h.left) &amp;&amp; isRED(h.left.left)) h = rotateRight(h);        if(isRED(h.left) &amp;&amp; isRED(h.right)) flipColors(h);        h.n = size(h.left) + size(h.right) + 1;        return h;    }    //左旋: 将右倾红连接变为左倾    private Node rotateLeft(Node h){        Node x = h.right;        h.right = x.left;        x.left = h;        x.color = x.left.color;        x.left.color = RED;        x.n = h.n;        h.n = size(h.left) + size(h.right) + 1;        return x;    }    //右旋: 将左倾红连接变为右倾    private Node rotateRight(Node h){        Node x = h.left;        h.left = x.right;        x.right = h;        x.color = x.right.color;        x.right.color = RED;        x.n = h.n;        h.n = size(h.left) + size(h.right) + 1;        return x;    }    //改变颜色    private void flipColors(Node h){        h.color = !h.color;        h.left.color = !h.left.color;        h.right.color = !h.right.color;    }    /**     * 将当前节点的左子节点(left)变为红节点     * 1.当前节点的右节点(right)为红时,从右节点借一个组成3节点     * 2.否则从当前节点借一个合并左右子节点组成4节点     */    private Node moveRedLeft(Node h){        flipColors(h); //改变颜色(左右子节点+父节点组成4节点)        if(isRED(h.right.left)){ //当前节点的右节点为红节点(左倾红连接相连)            h.right = rotateRight(h.right);            h = rotateLeft(h);            flipColors(h);        }        return h;    }    //将当前节点的右子节点变为红节点    private Node moveRedRight(Node h){        flipColors(h);        if(isRED(h.left.left)){            h = rotateRight(h);            flipColors(h);        }        return h;    }    /**************************************************     *  左倾红黑树其他实现(与二叉查找树相同,详情参考二叉查找树)     **************************************************/    public int size(){ return size(root); }    private int size(Node x){        if(x == null) return 0;        return x.n;    }    //是否为空    public boolean isEmpty(){ return root == null; }    public Value get(Key key){        if(key == null) return null;        return get(root,key);    }    private Value get(Node x,Key key){        while(x != null){            int cmp = comparator.compare(key,x.key);            if(cmp &gt; 0) x = x.right;            else if(cmp &lt; 0) x = x.left;            else return x.val;        }        return null;    }    public boolean contains(Key key){ return get(key) != null; }    public Key min(){        if(root == null) return null;        return min(root).key;    }    private Node min(Node x){        if(x.left == null) return x;        return min(x.left);    }    public Key max(){        if(root == null) return null;        return max(root).key;    }    private Node max(Node x){        if(x.right == null) return x;        return max(x.right);    }    public Key floor(Key key){        Node t = floor(root,key);        if(t == null) return null;        return t.key;    }    private Node floor(Node x,Key key){        if(x == null) return null;        int cmp = comparator.compare(key,x.key);        if(cmp &lt; 0) x = floor(x.left,key);        else if(cmp &gt;0) {            Node t = floor(x.right, key);            if (t != null) x = t;        }        return x;    }    public Key ceiling(Key key){        Node t = ceiling(root,key);        if(t == null) return null;        return t.key;    }    private Node ceiling(Node x,Key key){        int cmp = comparator.compare(x.key,key);        if(cmp &lt; 0) x = ceiling(x.right,key);        else if(cmp &gt; 0){            Node t = ceiling(x.left,key);            if(t != null) x = t;        }        return x;    }    public Key select(int k){        if(k &lt; 0 || k &gt;= size()) return null;        return select(root,k).key;    }    private Node select(Node x,int k){        int t = size(x.left);        if(t &gt; k) return select(x.left,k);        else if(t &lt; k) return select(x.right,k-t-1);        else return x;    }    public int rank(Key key){ return rank(root,key); }    private int rank(Node x,Key key){        if(x == null) return 0;        int cmp = comparator.compare(key,x.key);        if(cmp &lt; 0) return rank(x.left,key);        else if(cmp &gt; 0) return 1 + size(x.left) + rank(x.right,key);        else return size(x.left);    }    public int height(){ return height(root); }    private int height(Node x){        if(x == null) return 0;        return Math.max(height(x.left),height(x.right))+1;    }    public Iterable&lt;Key&gt; keys(){ return keys(min(),max()); }    public Iterable&lt;Key&gt; keys(Key lo,Key hi){        if(lo == null &amp;&amp; hi == null) throw new RuntimeException("参数为null");        ArrayDeque&lt;Key&gt; queue = new ArrayDeque&lt;&gt;();        keys(queue,root,lo,hi);        return queue;    }    private void keys(Queue&lt;Key&gt; queue,Node x,Key lo,Key hi){        if(x == null) return;        int cmplo = comparator.compare(x.key,lo);        int cmphi = comparator.compare(x.key,hi);        if(cmplo &gt; 0) keys(queue,x.left,lo,hi);        if(cmplo &gt;= 0 &amp;&amp; cmphi &lt;= 0)queue.offer(x.key);        if(cmphi &lt; 0) keys(queue,x.right,lo,hi);    }    /**************************************************     *  左倾红黑树验证     **************************************************/    public boolean check(){        if(!isBST()) System.out.println("不是二叉树");        if(!isSizeConsistent()) System.out.println("n错误");        if(!isRankConsistent()) System.out.println("rank或select方法错误");        if(!is23()) System.out.println("不是左倾2-3树");        if(!isBalanced()) System.out.println("不是平衡树");        return isBST() &amp;&amp; isSizeConsistent() &amp;&amp; isRankConsistent() &amp;&amp; is23() &amp;&amp; isBalanced();    }    //是否为二叉查找树    private boolean isBST(){        return isBST(root,null,null);    }    private boolean isBST(Node x,Key min,Key max){        if(x == null) return true;        if(min != null &amp;&amp; comparator.compare(x.key,min) &lt;= 0) return false;        if(max != null &amp;&amp; comparator.compare(x.key,max) &gt;= 0) return false;        return isBST(x.left,min,x.key) &amp;&amp; isBST(x.right,x.key,max);    }    //验证n    private boolean isSizeConsistent(){ return isSizeConsistent(root); }    private boolean isSizeConsistent(Node x){        if(x == null) return true;        if(size(x.left) + size(x.right) + 1 != size(x)) return false;        return isSizeConsistent(x.left) &amp;&amp; isSizeConsistent(x.right);    }    private boolean isRankConsistent(){        for(int i=0;i&lt;size();++i)            if(i != rank(select(i))) return false;        for(Key key : keys())            if(comparator.compare(select(rank(key)),key) != 0) return false;        return true;    }    //验证红黑树性质4,(左倾)    private boolean is23(){ return is23(root); }    private boolean is23(Node x){        if(x == null) return true;        if(isRED(x.right)) return false;        if(isRED(x) &amp;&amp; isRED(x.left)) return false;        return is23(x.left) &amp;&amp; is23(x.right);    }    //是否平衡树,检验红黑树性质5    private boolean isBalanced(){        int black = 0;        Node x = root;        while(x != null) {            if (!isRED(x)) black++;            x = x.left;        }        return isBalanced(root,black);    }    private boolean isBalanced(Node x,int black){        if(x == null) return black == 0;        if(!isRED(x)) black--;        return isBalanced(x.left,black) &amp;&amp; isBalanced(x.right,black);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉查找树</title>
      <link href="/2018/12/20/BinarySearchTree/"/>
      <url>/2018/12/20/BinarySearchTree/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><blockquote><p>二叉查找树的平均查找速度与树高成正比</p><p><strong>优点:</strong> 作为一种有序符号表实现,支持高效的查找丶插入丶删除操作, 平均情况下1.39lgN</p><p><strong>缺点:</strong>  在最坏况下(有序数据构建),二叉查找树会退化成链表,此时的变为o(n)级别,(为解决此问题出现平衡树)</p></blockquote><pre><code>/** * 二叉查找树 * 性质: * 1.若它的左子树不为空，则左子树上的所有节点的值均小于根节点的值 * 2.若它的右子树不为空，则右子树上的所有结点的值均大于根节点的值 * 3.二叉查找树的左右子树也都是二叉查找树 */public class BinarySearchTree&lt;Key,Value&gt; {    private Comparator comparator;    private Node root;    public BinarySearchTree(Comparator comparator) {        this.comparator = comparator;    }    private class Node{        private Key key;        private Value val;        private Node left;  //左子节点        private Node right; //右子节点        private int n; //以当前节点为根节点的二叉查找树总节点数(x.n = x.left.n + x.right.n + 1)        public Node(Key key, Value val, int n) {            this.key = key;            this.val = val;            this.n = n;        }    }    //*************************************1.递归实现部分***************************************    /**     *插入: 递归方式     *概述: 1.从根节点查找是否有与待插入节点相同key的节点,如果有则更新其值val     *       如果一直到树的底部还没有找到则直接在底部正确位置插入新节点即可     *      2. 查找过程中如果待插入节点比当前节点x大,则只需要在x节点右子树中查找     *          如果比当前节点x小则只需要在x节点左子树中查找     */    public void put(Key key,Value val){        root = put(root,key,val);    }    private Node put(Node x,Key key,Value val){        if(x == null) return new Node(key,val,1); //查找树底还没找到,则插入新节点        int cmp = comparator.compare(key,x.key);        if(cmp &gt; 0) x.right = put(x.right,key,val);        else if(cmp &lt; 0) x.left = put(x.left,key,val);        else x.val = val;        x.n = size(x.left) + size(x.right) + 1; //更新节点数        return x;    }    /**     *获取键key对应的值(与put方式查找思路相同)     */    public Value get(Key key){ return get(root,key); }    private Value get(Node x,Key key){        if(x == null) return null;        int cmp = comparator.compare(key,x.key);        if(cmp &gt; 0) return get(x.right,key);        else if(cmp &lt; 0) return get(x.left,key);        else return x.val;    }    /**     *删除节点: 递归     * 概述: 1.从根节点往下进行查找(与get方法思路相同)     *      2.找到时节点为x,此时只需要用x右子树中最小的节点把x节点替换掉即可     *        (或用x左子树中最大的节点替换掉x节点)     */    public void delete(Key key){ root = delete(root,key); }    private Node delete(Node x,Key key){        if(x == null) return null;        int cmp = comparator.compare(key,x.key);        if(cmp &gt; 0) x.right = delete(x.right,key);        else if(cmp &lt; 0) x.left = delete(x.left,key);        else {  //找到,使用x节点右子树中最小的节点替换掉x节点            if(x.left == null) return x.right;            if(x.right == null) return x.left;            Node t = x;            x = min(t.right);            x.right = deleteMin(t.right);            x.left = t.left;        }        x.n = size(x.left) + size(x.right) + 1;        return x;    }    /**     * 删除最小节点     * 概述: 找到最小节点x(与min方法思路相似),用x.right节点替换掉x节点即可     */    public void deleteMin(){ root = deleteMin(root); }    private Node deleteMin(Node x){        if(x.left == null) return x.right; //找到最小节点x,此时返回x.right,替换掉x节点        x.left = deleteMin(x.left);  //在左子树查找删除最小节点        x.n = size(x.left) + size(x.right) + 1;        return x;    }    public void deleteMax(){ root = deleteMax(root); }    private Node deleteMax(Node x){        if(x.right == null) return x.left;        x.right = deleteMax(x.right);        x.n = size(x.left) + size(x.right) + 1;        return x;    }    /**     * 查找最小节点     * 概述: 从根节点开始一直向底部查找每次都查找左节点即可     *      当当前节点x没有左节点时,即为最小值     */    public Key min(){ return min(root).key; }    private Node min(Node x){        if(x.left == null) return x;        return min(x.left);    }    public Key max(){ return max(root).key; }    private Node max(Node x){        if(x.right == null) return x;        return max(x.right);    }    /**     * 小于等于key的最大节点     * 概述: 如果key小于当前节点,则一定在左子树     *       如果key大于当前节点,则在右子树找,如果右子树没有找到,则当前节点即为所需结果     *       如果相等,则当前节点为所需结果     */    public Key floor(Key key){        Node x = floor(root,key);        if(x == null) return null;        return x.key;    }    private Node floor(Node x,Key key){        if(x == null) return null; //结束条件,在子树中没有找到时返回null        int cmp = comparator.compare(key,x.key);        if(cmp &lt; 0) return floor(x.left,key);        else if(cmp &gt;0){            Node t = floor(x.right,key);            if(t != null) return t; //右子树找到,返回找到的结果            //没有找到时返回x        }        return x; //cmp = 0; 或者 cmp &gt;0且右子树没有找到时x为所需结果    }    //大于等于key的最小节点    public Key ceiling(Key key){        Node x = ceiling(root,key);        if(x == null) return null;        return x.key;    }    private Node ceiling(Node x,Key key){        if(x == null) return null;        int cmp = comparator.compare(key,x.key);        if(cmp &gt; 0) return ceiling(x.right,key);        else if(cmp &lt; 0){            Node t = ceiling(x.left,key);            if(t != null) return t;        }        return x;    }    /**     * 小于键key的数量     * 概述: 如果key小于当前节点,则在当前节点左子树查找小于key的数量即可     *       如果key大于当前节点,则在右子树中查找小于key的数量然后加上左子树节点数和一个根节点     *       如果相等,则左子树节点数即为所需结果     */    public int rank(Key key){ return rank(root,key); }    private int rank(Node x,Key key){        if(x == null) return 0;        int cmp = comparator.compare(key,x.key);        if(cmp &lt; 0) return rank(x.left,key);        else if(cmp &gt; 0) return rank(x.right,key) + size(x.left) + 1;        else return size(x.left);    }    /**     * 排名为k的键(树中有k个小于它的键)     * 概述: 先统计当前节点左子树节点数t     *      如果t &gt; k ,则在当前节点左子树中递归查找结果即可     *      如果t &lt; k ,则在右子树查找即可,此时在右子树排名为 k-t-1     *                 (k-t-1值为0时,会递归到右子树最小节点,此时size(x.left)=0,     *                 返回右子树最小节点)     *      如果t = k , 则返回当前节点即可     */    public Key select(int k){        Node x = select(root,k);        if(x == null) return null;        return x.key;    }    private Node select(Node x,int k){        if(x == null) return null;        int t = size(x.left);        if(t &gt; k) return select(x.left,k);        else if(t &lt; k) return select(x.right,k-t-1);        else return x;    }    //二叉树中是否存在键key的节点    public boolean contains(Key key){ return get(key) != null; }    //是否为空    public boolean isEmpty(){ return size() == 0; }    //返回二叉树的节点总数    public int size(){ return size(root); }    private int size(Node x){        if(x == null) return 0;        return x.n;    }    public Iterable&lt;Key&gt; keys(){ return keys(min(),max()); }    public Iterable&lt;Key&gt; keys(Key lo,Key hi){        ArrayDeque&lt;Key&gt; deque = new ArrayDeque&lt;&gt;();        keys(deque,root,lo,hi);        return deque;    }    /**     * 范围查找:     * 中序遍历(递归): left -&gt; root -&gt; right     * 中序遍历节点key值在lo ~ hi之间的节点     * 概述: 将中序遍历稍作修改即可,(增加判断条件只遍历符合的子树)     * 即:  如果需要遍历当前节点x的左子树x.left, 则 lo &lt; x     *      如果需要遍历当前节点x的右子树x.right, 则 hi &gt; x     */    private void keys(Deque deque, Node x, Key lo, Key hi){        if(x == null) return;        int cmplo = comparator.compare(x.key,lo);        int cmphi = comparator.compare(x.key,hi);        if(cmplo &gt; 0) keys(deque,x.left,lo,hi);        if(cmplo &gt;=0 &amp;&amp; cmphi &lt;= 0) deque.offerLast(x.key);        if(cmphi &lt; 0) keys(deque,x.right,lo,hi);    }    public Iterable&lt;Key&gt; keysLoop(Key lo,Key hi){        ArrayDeque&lt;Key&gt; deque = new ArrayDeque&lt;&gt;();        keysLoop(deque,root,lo,hi);        return deque;    }    //***********************************2. 非递归实现部分*************************************    // 没有维护n的值    /**     * 范围查找: 非递归     * 概述: 在非递归中序遍历基础上增加判断条件,不遍历不符合的子树     */    private void keysLoop(Deque deque,Node x,Key lo,Key hi){        ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();        while(x != null || !stack.isEmpty()) {            while (x != null) {                stack.push(x);                int cmplo = comparator.compare(x.key,lo);                if( cmplo &gt;= 0) x = x.left;                else x = null;            }            if(stack.isEmpty()) continue;            x = stack.pop();            int cmplo = comparator.compare(x.key,lo);            int cmphi = comparator.compare(x.key,hi);            if(cmplo &gt;=0 &amp;&amp; cmphi &lt;= 0) deque.offerLast(x.key);            if (x.right != null &amp;&amp;  cmphi &lt;= 0) x = x.right;            else x = null;        }    }    /**     * 前序遍历: 非递归     * root -&gt; left -&gt; right     */    public Iterable&lt;Key&gt; preOrder(){        ArrayDeque&lt;Key&gt; deque = new ArrayDeque&lt;&gt;();        ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();        Node x = root;        while(x != null || !stack.isEmpty()) {            while (x != null) {                deque.offerLast(x.key);                stack.push(x);                x = x.left;            }            if(stack.isEmpty()) continue;            x = stack.pop();            x = x.right;        }        return deque;    }    /**     * 中序遍历: 非递归     * left -&gt; root -&gt; right     */    public Iterable&lt;Key&gt; inOrder(){        ArrayDeque&lt;Key&gt; deque = new ArrayDeque&lt;&gt;();        ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();        Node x = root;        while(x != null || !stack.isEmpty()) {            while (x != null) {                stack.push(x);                x = x.left;            }            if(stack.isEmpty()) continue;            x = stack.pop();            deque.offerLast(x.key);            x = x.right;        }        return deque;    }    /**     * 后序遍历: 非递归     * left -&gt; right -&gt; root     * 概述: 在中序遍历基础上做出修改即可     *       在中序遍历中经过root时,如何存在right没有遍历则root不出栈;     *       即如果上一个遍历节点pre不是当前root节点的right节点则需要先遍历right节点     */    public Iterable&lt;Key&gt; postOrder(){        ArrayDeque&lt;Key&gt; deque = new ArrayDeque&lt;&gt;();        ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();        Node x = root;        Node pre = null; //保存最新出栈节点        do {            while (x != null) {                if(pre == x) break; //已经遍历根节点,无需遍历子树                stack.push(x);                x = x.left;            }            x = stack.peek();            //当存在右节点且右节点没有遍历时(前一个遍历节点不是右节点),先遍历右节点(压栈)            if (x.right != null &amp;&amp; x.right != pre) {                x = x.right;                continue;            }            x = stack.pop();            deque.offerLast(x.key);            pre = x;  //保存最新出栈节点        } while(!stack.isEmpty());        return deque;    }    /**     * 层序遍历: 非递归     * 概述: 利用队列先进先出的特点     *       先将首层节点依次入队,然后出队时,如果有子节点则将子节点再依次入队     */    public Iterable&lt;Key&gt; levelOrder(){        ArrayDeque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();        ArrayDeque&lt;Key&gt; deque = new ArrayDeque&lt;&gt;();        Node x = root;        queue.offerLast(x);        while(!queue.isEmpty()){            Node t = queue.pollFirst();            if(t != null) deque.offerLast(t.key);            if(t.left != null) queue.offerLast(t.left);            if(t.right != null) queue.offerLast(t.right);        }        return deque;    }    //插入: 非递归    public void putLoop(Key key,Value val){        if(root == null) {            root = new Node(key,val,1);            return;        }        Node x = root,parent = null;        while(x != null){            parent = x;            int cmp = comparator.compare(key,x.key);            if(cmp &gt; 0) x = x.right;            else if(cmp &lt; 0) x = x.left;            else {                x.val = val;                return;            }        }        //如果是新元素插入则更新n(或者直接更新,非新元素再撤回)        x = root;        while(x != null){            int cmp = comparator.compare(key,x.key);            if(cmp &gt; 0) {                x = x.right;                if(x != null) x.n ++;            }            else if(cmp &lt; 0) {                x = x.left;                if(x != null) x.n++;            }        }        int cmp = comparator.compare(key,parent.key);        if(cmp &gt; 0) parent.right = new Node(key,val,1);        else parent.left = new Node(key,val,1);    }    //获取: 非递归    public Value getLoop(Key key){        Node x = root;        while(x != null){            int cmp = comparator.compare(key,x.key);            if(cmp &gt; 0) x = x.right;            else if(cmp &lt; 0) x = x.left;            else return x.val;        }        return null;    }    //删除: 非递归    public void deleteLoop(Key key){ root = deleteLoop(root,key); }    private Node deleteLoop(Node x,Key key){        Node r = x;        Node pre = null;        while(x != null){            int cmp = comparator.compare(key,x.key);            if(cmp &gt; 0)            {                pre = x;                x = x.right;            }            else if(cmp &lt; 0)            {                pre = x;                x = x.left;            }            else{                Node t = x;                if(x.left == null) x = x.right;                else if(x.right == null) x = x.left;                else{                    x = minLoop(t.right);                    x.right = deleteMinLoop(t.right);                    x.left = t.left;                }                if(pre == null) r = x;                else if(pre.left == t) pre.left = x;                else pre.right = x;                break;            }        }        return r;    }    //最小值: 非递归    private Node minLoop(Node x){        if(x == null) return null;        while(x.left != null){            x = x.left;        }        return x;    }    //删除最小: 非递归    public void deleteMinLoop(){ root = deleteMinLoop(root); }    private Node deleteMinLoop(Node x){        Node r = x;        Node pre = x;        if(x == null) return null;        while (x.left != null) {            pre = x;            x = x.left;        }        if(pre == x) return pre.right;        pre.left = x.right;        return r;    }    /**     * 树高     * 概述: 当前节点左子树和右子树中最大高度+1即为当前节点树高     */    public int height(){ return height(root); }    private int height(Node x){        if(x == null) return 0;  //假设叶子节点高度为1,若叶子节点高度为0则返回-1;        return Math.max(height(x.left),height(x.right)) + 1;    }    //是否二叉查找树(根据二叉查找树性质判断)(也可以通过中序遍历判断)    public boolean isBST(){ return isBST(root,null,null); }    public boolean isBST(Node x,Key min,Key max){        if(x == null) return true;        if(min != null &amp;&amp; comparator.compare(x.key,min) &lt;= 0) return false;        if(max != null &amp;&amp; comparator.compare(x.key,max) &gt;= 0) return false;        //左子树上的所有节点的值均小于根节点的值,右子树上的所有结点的值均大于根节点的值        return isBST(x.left,min,x.key) &amp;&amp; isBST(x.right,x.key,max);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2018/11/25/HeapSort/"/>
      <url>/2018/11/25/HeapSort/</url>
      
        <content type="html"><![CDATA[<p><strong>二叉堆</strong></p><ol><li>堆中任意节点的值总是不大于(不小于)其子节点的值</li><li>二叉堆是完全二叉树或者是近似完全二叉树</li><li>对于二叉堆中任意一个位置i,其左子节点为2i,右子节点为2i+1</li></ol><h4 id="1-优先队列"><a href="#1-优先队列" class="headerlink" title="1.优先队列"></a>1.优先队列</h4><blockquote><p>优先队列是一种用来维护一组元素构成的集合的数据结构 ,可以使用堆实现.</p><p><strong>缺点:</strong></p><ol><li>无法知道元素在优先队列中的位置,因此无法直接访问对象,从而更新对象</li></ol><p><strong>如下最大优先队列:</strong>  </p><ol><li>插入元素时: 将元素集合构造成最大堆(上浮(swim):插入末尾,再上浮到正确位置)</li><li>取出元素时: 取出堆顶元素(最大值),然后将剩余元素更新为最大堆(下沉(sink): 将末尾元素放入顶部再下沉到正确位置)</li><li>这样每次取出元素都是最大值,便形成了最大优先队列</li></ol></blockquote><pre><code>/** * 使用二叉堆(最大堆)实现的最大优先队列 *  */public class MaxPQ&lt;Key&gt; {    private Object[] pq; //数组作为最大堆    private int N = 0; //记录元素个数    private int DEFAULT_N = 10; //初始大小    private Comparator&lt;? super Key&gt; comparator;    public MaxPQ(Comparator&lt;? super Key&gt; comparator){ //创建对象并传入比较器        pq = new Object[DEFAULT_N];        this.comparator = comparator;    }    //插入元素    public void insert(Key key){        //自动扩展1.5倍        if(N == DEFAULT_N-1) adjust(DEFAULT_N+=DEFAULT_N&gt;&gt;&gt;1);        pq[++N] = key;        swim(N);    }    public Key max(){ return (Key)pq[1]; }    //删除并返回最大元素    public Key delMax(){        //自动缩减一半        if(N&gt;10 &amp;&amp; N &lt; DEFAULT_N/3) adjust(DEFAULT_N&gt;&gt;&gt;=1);        Key max = (Key)pq[1];        pq[1] = pq[N];        pq[N--] = null;        sink(1);        return max;    }    //返回优先队列中元素个数    public int size(){ return N; }    public boolean isEmpty(){ return N == 0;}    /**     *上浮: 将元素上浮到优先队列正确位置(构造最大堆)     *步骤: 1.将arr[k]元素与其父节点arr[2*k]比较,如果大于父节点就交换     *  　　2.重复步骤1直到arr[k]上浮到正确位置     */    public void swim(int k){        while(k&gt;1 &amp;&amp; !less(k,k&gt;&gt;&gt;1)) exch(k, k&gt;&gt;&gt;=1);    }    /**     *下沉: 将元素下沉到优先队列正确位置(构造最大堆)     *步骤: 1.将arr[k]元素与其子节点中较大的元素arr[j]比较,如果子节点较大就交换     *　    2.重复步骤1直到下沉到正确位置     */    public void sink(int k){        while(k&lt;&lt;1 &lt;= N){            int j = k&lt;&lt;1;            if(j &lt; N &amp;&amp; less(j,j+1)) ++j;            if(less(k,j)) exch(k,j);            k = j;        }    }    //交换    public void exch(int i,int j){        Key temp = (Key)pq[i];        pq[i] = pq[j];        pq[j] = temp;    }    //比较    public boolean less(int i,int j){        return comparator.compare((Key)pq[i],(Key)pq[j]) &lt; 0;    }    //调整优先队列大小    public void adjust(int length){        Object[] pqN = new Object[length];        System.arraycopy(pq,1,pqN,1,N);        pq = pqN;    }}</code></pre><h4 id="2-索引优先队列"><a href="#2-索引优先队列" class="headerlink" title="2.索引优先队列"></a>2.索引优先队列</h4><blockquote><p>在优先队列的基础上进行改进</p><ol><li>加入一个索引数组qp,其值记录了元素在优先队列pq中的位置,从而可以访问优先队列中的元素,更新元素</li><li>索引优先队列pq中保存元素的索引,元素数组keys保存元素</li></ol><p>实现: 在优先队列的基础上,同步更新索引数组qp丶元素数组keys以及他们之间的映射关系(pq[qp[i]] = i)即可</p></blockquote><pre><code>/** * 索引优先队列 */public class IndexMaxPQ&lt;Key&gt; {    private int[] pq;  //最大堆,下标为元素位置,值是元素的索引    private int[] qp;  //索引数组,下标是元素的索引,值为元素在最大堆pq中的位置,索引为i则 pq[qp[i]] = i    private Object[] keys; //对象数组,下标为元素索引,值为元素    private int n = 0; //记录元素个数    private Comparator&lt;? super Key&gt; comparator; //比较器    //构造方法-传入比较器    public IndexMaxPQ(int maxN,Comparator&lt;? super Key&gt; comparator){        this.comparator = comparator;        pq = new int[maxN+1];        qp = new int[maxN+1]; //初始化默认值为0        keys = new Object[maxN+1];    }    //构造方法-使用默认比较器    public IndexMaxPQ(int maxN){        comparator = (Key x,Key y) -&gt; {            if(x instanceof Comparable)                return ((Comparable) x).compareTo(y);            throw new RuntimeException("须传入比较器或者实现Comparable接口");        };        pq = new int[maxN+1];        qp = new int[maxN+1]; //初始化默认值为0        keys = new Object[maxN+1];    }    //插入索引为k的元素e    public void insert(int k,Key e){        pq[++n] = k;        qp[k] = n;        keys[k] = e;        swim(n);    }    //删除最大元素并返回索引    public int delMax(){        int maxIndex = pq[1];        exch(1,n--);        sink(1);        //删除映射        pq[n+1] = -1;        qp[maxIndex] = -1;        keys[maxIndex] = null;        return maxIndex;    }    //获取指定索引的值    public Key peek(int k){ return (Key)keys[k]; }    //将索引k的元素设置为key    public void change(int k,Key e){        keys[k] = e;        //更新        sink(qp[k]);        swim(qp[k]);    }    //是否存在索引为k的元素    public boolean contains(int k){        return k&gt;=0 &amp;&amp; k &lt;= qp.length &amp;&amp; qp[k]&gt;0 &amp;&amp; qp[k]&lt;=n;    }    //删除索引k及相关元素    public void delete(int k){        exch(qp[k],n--);        sink(qp[k]);        swim(qp[k]);        //删除映射        pq[n+1] = -1;        qp[k] = -1;        keys[k] = null;    }    //返回最大元素    public Key maxKey(){ return (Key)keys[pq[1]]; }    //返回最大元素的索引    public int maxIndex(){ return pq[1]; }    public boolean isEmpty(){ return n==0; }    public int size(){ return n; }    //上浮    public void swim(int k){        while(k &gt; 1 &amp;&amp; less(k&gt;&gt;&gt;1,k)) exch(k,k&gt;&gt;&gt;=1);    }    //下沉    public void sink(int k){        while(k&lt;&lt;1 &lt;= n){            int j = k&lt;&lt;1;            if(j&lt;n &amp;&amp; less(j,j+1)) ++j;            if(less(k,j)) exch(k,j);            k = j;        }    }    public void exch(int i, int j){        if(i == j) return;        //堆:交换        pq[i] = pq[i] ^ pq[j];        pq[j] = pq[i] ^ pq[j];        pq[i] = pq[i] ^ pq[j];        //更新索引数组        qp[pq[i]] = i;        qp[pq[j]] = j;    }    public boolean less(int i,int j){        return comparator.compare((Key)keys[pq[i]],(Key)keys[pq[j]]) &lt; 0;    }}</code></pre><h4 id="3-原地堆排序"><a href="#3-原地堆排序" class="headerlink" title="3.原地堆排序"></a>3.原地堆排序</h4><blockquote><p>*<em>概述: *</em></p><ol><li>使用下沉将数组构造为一个最大优先队列(最大堆)(即: 从堆底最后一个非叶子节点开始逐个下沉构造堆)</li><li>依次将堆顶元素(最大值)与数组末尾元素交换</li><li>将数组中剩余元素(除了交换到末尾的最大值元素)更新为优先队列(交换后的堆顶元素下沉构造堆)</li><li>重复步骤2,步骤3直到堆大小为1结束</li></ol></blockquote><pre><code>    /**     * 原地堆排序     */    public void heapSort(int[] arr){//0索引不使用        int n = arr.length-1;        //1.构造堆        for(int i=n&gt;&gt;&gt;1;i&gt;0;--i)  //最后一个节点(n)的父节点(n/2)为最后一个非叶子节点            sink(arr,i,n);        //2.将堆顶元素(最大元素)放入数组尾部,然后对新的堆顶元素进行下沉构造堆        while(n &gt; 1){            exch(arr,1,n--);            sink(arr,1,n);        }    }    /**     * 下沉: 将元素arr[k]下沉构造堆,堆结尾为arr[n]     *  即: 如果arr[k]比其子节点中较大的元素arr[j]小,则与其交换     */    public void sink(int[] arr,int k,int n){        while(k&lt;&lt;1 &lt;= n){            int j = k&lt;&lt;1;            if(j&lt;n &amp;&amp; arr[j]&lt;arr[j+1]) ++j;            if(arr[k] &lt; arr[j]) exch(arr,k,j);            k = j;        }    }    //交换    public void exch(int[] arr,int i,int j){        if(i == j) return;        arr[i] = arr[i] ^ arr[j];        arr[j] = arr[i] ^ arr[j];        arr[i] = arr[i] ^ arr[j];    }</code></pre><h4 id="4-堆排序优化"><a href="#4-堆排序优化" class="headerlink" title="4.堆排序优化"></a>4.堆排序优化</h4><blockquote><p>*<em>概述: *</em></p><p>​    原地堆排序时,通过将数组末尾元素与堆顶元素交换,然后arr[1]下沉到正确位置更新堆,</p><p>​    显然arr[1]的正确位置更大概率接近堆底,然而下沉时每次都比较是否到达正确位置,</p><p>​    因此可以直接下沉到堆底,不在进行比较,再通过上浮时比较是否到达正确位置,这样减少比较</p><p><strong>对比:</strong> </p><pre><code>1. **优点:** 与原地堆排序相比减少了很多比较,当比较代价较大时,有优势2. **缺点:** 与原地堆排序相比增加了额外空间</code></pre></blockquote><pre><code>    /**     * 堆排序优化     */    public void heapSort(int[] arr){        int n = arr.length - 1;        for(int i=n&gt;&gt;&gt;1;i&gt;0;--i)    //下沉构造堆            sink(arr,i,n);        while(n &gt; 1){            exch(arr,1,n--);            int k = sinkD(arr,1,n); //直接下沉返回其位置k            swim(arr,k);               //将其上浮到正确位置        }    }    //上浮    public void swim(int[] arr,int k){        while(k &gt; 1 &amp;&amp; arr[k] &gt; arr[k&gt;&gt;&gt;1]) exch(arr,k,k&gt;&gt;&gt;=1);    }    //下沉: 将arr[k]下沉到堆中正确位置    public void sink(int[] arr,int k, int n){        while(k&lt;&lt;1 &lt;= n){            int j = k &lt;&lt; 1;            if(j &lt; n &amp;&amp; arr[j] &lt; arr[j+1]) ++j;            if(arr[k] &lt; arr[j]) exch(arr,k,j);            k = j;        }    }    //直接下沉: 不判断是否到达正确位置,将arr[k]直接下沉到堆底,并返回此时索引k    public int sinkD(int[] arr,int k,int n){        int temp = arr[k];        while(k&lt;&lt;1 &lt;= n){            int j = k&lt;&lt;1;            if(j &lt; n &amp;&amp; arr[j] &lt; arr[j+1]) ++j;            arr[k] = arr[j];            k = j;        }        arr[k] = temp;        return k;    }    //交换    public void exch(int[] arr,int i,int j){        if(i == j) return;        arr[i] = arr[i] ^ arr[j];        arr[j] = arr[i] ^ arr[j];        arr[i] = arr[i] ^ arr[j];    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2018/11/03/Quick/"/>
      <url>/2018/11/03/Quick/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><h4 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h4></blockquote><pre><code>    /**     * 快速排序     * 概述: 将数组按照一个分切元素v(数组中一个值)进行分切,     * 分切后为: 不大于v的序列(左序列),v,不小于v的序列(右序列)     * 继续按照上述步骤,分别将左,右序列进行分切,直到无法分切时结束     * 此时排序完成     */    public void quick(int[] arr,int lo,int hi){        if(lo &gt;= hi) return;        int j = partition(arr,lo,hi);//分切        quick(arr,lo,j-1);        quick(arr,j+1,hi);    }</code></pre><pre><code>    /**     * 分切方法     * 将数组arr的[lo...hi]部分按照v = arr[lo]进行分切,分切后其索引为j     * 分切后, arr[lo...j-1] &lt;= arr[j] &lt;= arr[j+i...hi], 此时arr[j] = v;     * @param arr 数组     * @param lo 起始索引     * @param hi 结束索引     * @return 返回分切元素的索引     */    public int partition(int[] arr,int lo,int hi){        int v = arr[lo]; //分切元素        int i = lo, j = hi+1;        while(true){            while(v &lt; arr[--j]);            while(arr[++i] &lt; v) if(i == j) break;            if(i &gt;= j) break;            //交换            exch(arr,i,j);        }        exch(arr,lo,j);        return j;    }</code></pre><blockquote><h4 id="2-快速排序简单优化"><a href="#2-快速排序简单优化" class="headerlink" title="2.快速排序简单优化"></a>2.快速排序简单优化</h4></blockquote><pre><code>    /**     * 快速排序简单优化     * 1.数组规模小于10时使用插入排序     * 2.每次进行分切时,取首,尾与中间元素的中位数作为分切元素     *   (此时若将最大元素与尾元素交换则可以去除分切时边界判断)     *     * 3.数组规模大时,还可以采用取3组(每组3个数),取每组的中位数(共3个),     *   然后取这3个中位数的中位数作为分切元素(详见快速三向切分代码)     */    public void quickMedian(int[] arr,int lo,int hi){        int len = hi-lo+1;        if(len &lt;= 10){ //1. 数组规模小于10时使用插入排序            insertion(arr,lo,hi);            return;        }        int j = partitionMedian(arr,lo,hi);        quickMedian(arr,lo,j-1);        quickMedian(arr,j+1,hi);    }</code></pre><pre><code>    /**     * 分切方法     */    public int partitionMedian(int[] arr,int lo,int hi){        int len = hi-lo+1;        setMedian(arr,lo,hi); //2. 从lo,hi,中间处mid三个数中找出中位数与lo交换,最大数与hi交换        int v = arr[lo]; //分切元素        int i = lo, j = hi+1;        while(true){            while(v &lt; arr[--j]);            while(arr[++i] &lt; v); // if(i == j) break; 取中位数时,每次最大数与hi交换,因此不需要进行边界判断            if(i &gt;= j) break;            //交换            exch(arr,i,j);        }        exch(arr,lo,j);        return j;    }</code></pre><pre><code>    /**     * 设置中位数     * 取首,尾(lo,hi)与中间元素(mid)的中位数作为分切元素(与lo交换)     * 同时将最大元素与尾(hi)交换(可以去掉分切时边界判断)     */    public void setMedian(int[] arr,int lo,int hi){        int mid = (lo+hi)/2;        int max = lo;        if(arr[max] &lt; arr[mid]) max = mid;        if(arr[max] &lt; arr[hi]) max = hi;        exch(arr,max,hi);        if(arr[lo] &lt; arr[mid]) exch(arr,lo,mid);    }</code></pre><ul><li>交换方法</li></ul><pre><code>    /**     * 交换方法     * 交换arr[i] 与 arr[j]     */    public void exch(int[] arr,int i,int j){        if(i == j) return;        arr[i] = arr[i] ^ arr[j];        arr[j] = arr[i] ^ arr[j];        arr[i] = arr[i] ^ arr[j];    }</code></pre><ul><li>插入排序</li></ul><pre><code>    /**     * 插入排序     *对序列[lo...hi]部分进行插入排序     */    public void insertion(int[] arr,int lo,int hi){        for(int i=lo+1;i&lt;=hi;++i)            for(int j=i;j&gt;lo &amp;&amp; arr[j]&lt;arr[j-1];--j)                exch(arr,j,j-1);    }</code></pre><blockquote><h4 id="3-快速排序—三向切分"><a href="#3-快速排序—三向切分" class="headerlink" title="3.快速排序—三向切分"></a>3.快速排序—三向切分</h4></blockquote><pre><code>    /**     * 三向切分--针对有较多重复元素的序列进行排序     * 将序列按照分切元素v切分为: 序列A(小于v) 序列B(等于v) 序列C(大于v)     * 以此类推,再分别将序列A,序列C切分,直到不可切分时排序完成     * 特点: 额外交换用于与分切元素不等的元素     */    public void quick3Way(int[] arr,int lo,int hi){        if(lo &gt;= hi) return;        int v = arr[lo];        int lt = lo, gt = hi;        //额外交换用于于分切元素不等的元素        for(int i=lo+1;i&lt;=gt;++i){//按照[lo...lt-1] &lt; v = arr[lt...gt] &lt; [gt+1...hi]切分            if (arr[i] &lt; v) exch(arr, lt++, i);            if (arr[i] &gt; v) exch(arr, gt--, i--);        }        //递归        quick3Way(arr,lo,lt-1);        quick3Way(arr,gt+1,hi);    }</code></pre><blockquote><h4 id="4-快速三向切分-熵最优"><a href="#4-快速三向切分-熵最优" class="headerlink" title="4.快速三向切分(熵最优)"></a>4.快速三向切分(熵最优)</h4></blockquote><pre><code>    /**     * 快速三向切分(熵最优)     * 特点: 额外的交换用于与分切元素v相等的元素     */    public void quick3WayPartition(int[] arr,int lo,int hi){        int len = hi-lo+1;        if(len &lt;= 10){  //数组规模小于等于10时使用插入排序            insertion(arr,lo,hi);            return;        }        else if(len &lt;= 40){ //数组规模为(10,40]时取首(lo),尾(hi)与中间元素(mid)的中位数作为分切元素            int mid = (lo+hi)/2;            int med = median(arr,lo,mid,hi);            exch(arr,lo,med);        }        else{//数组规模大于40时,分别取三组(每组3个)的中位数,然后再取3个中位数的中位数作为分切元素            int sep = len / 8;            int mid = lo + len / 2;            int m1 = median(arr,lo,lo+sep,lo+sep*2);            int m2 = median(arr,mid-sep,mid,mid+sep);            int m3 = median(arr,hi-sep*2,hi-sep,hi);            mid = median(arr,m1,m2,m3);            exch(arr,lo,mid);        }        int v = arr[lo]; //分切元素        int i,j,p,q;        i = p = lo; j = q = hi+1;        while(true){            while(v &lt; arr[--j]);            while(arr[++i] &lt; v) if(i == j) break;            //if(i == j &amp;&amp; arr[i] == v) exch(arr,i,++p); (1).判断相等            if(i == j) exch(arr,i,++p); //此时直接交换,则最终边界处可能为arr[p] &lt;= v            if(i &gt;= j) break;            exch(arr,i,j);            //将等于分切元素v的移动到两端            if(arr[i] == v) exch(arr,i,++p);            if(arr[j] == v) exch(arr,j,--q);        }        //此时序列 lo--等于v--p--小于v--i/j--大于v--q--等于v--hi        //此时i==j或i=j+1,i==j时arr[i] &lt; v  arr[i+1] &gt;v        i = j + 1;        //将两端等于分切元素v的元素移动到中间        //for(int k=lo;k&lt;=p;++k) exch(arr,k,j--); (1).判断相等则,k&lt;=p        for(int k=lo;k&lt;p;++k) exch(arr,k,j--);  //直接交换则k&lt;p,因为arr[p] &lt;= v        for(int k=hi;k&gt;=q;--k) exch(arr,k,i++);        //递归        quick3WayPartition(arr,lo,j);        quick3WayPartition(arr,i,hi);    }</code></pre><pre><code>    /**     * 取中位数     * 找出arr[lo],arr[mid],arr[hi]的中位数并返回其索引     */    public int median(int[] arr,int lo,int mid,int hi){        return arr[lo]&lt;arr[mid]?(arr[lo]&lt;arr[hi]?(arr[mid]&lt;arr[hi]?mid:hi):lo)                :(arr[lo]&gt;arr[hi]?(arr[mid]&lt;arr[hi]?hi:mid):lo);    }</code></pre><blockquote><h4 id="5-多线程并行快速排序"><a href="#5-多线程并行快速排序" class="headerlink" title="5.多线程并行快速排序"></a>5.多线程并行快速排序</h4></blockquote><pre><code>public class Quick&lt;E&gt; extends RecursiveAction{    private E[] elements;    private Comparator&lt;E&gt; comparator; //比较器    private int lo;    private int hi;    public Quick(E[] elements, Comparator&lt;E&gt; comparator) {        this.elements = elements;        this.comparator = comparator;        this.lo = 0;        this.hi = elements.length - 1;    }    public Quick(E[] elements) {        this.elements = elements;        this.comparator = (E x,E y) -&gt; {            if(x instanceof Comparable) return ((Comparable) x).compareTo(y);            else throw new RuntimeException("需要传入Comparator或者实现Comparable");        };        this.lo = 0;        this.hi = elements.length - 1;    }    private Quick(E[] elements,int lo,int hi){        this.elements = elements;        this.lo = lo;        this.hi = hi;    }    //快排:单线程    public void sort(){ quickMedian(elements,lo,hi); }    //快排:多线程并行    public void parallelSort(){        ForkJoinPool forkJoin = (ForkJoinPool) Executors.newWorkStealingPool();        try {            forkJoin.submit(this).get();//提交任务并获取等待结束        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        forkJoin.shutdown();    }    @Override    protected void compute() {        if(hi - lo &lt;= 10000) quickMedian(elements,lo,hi);        else{            //分切            int j = partitionMedian(elements,lo,hi);            //剩余两部分作为两个分支任务放入ForkJoinPool            Quick&lt;E&gt; left = new Quick&lt;&gt;(elements,lo,j-1);            Quick&lt;E&gt; right = new Quick&lt;&gt;(elements,j+1,hi);            invokeAll(left,right);        }    }    //快速排序: 对[lo,hi]部分进行快速排序    private void quickMedian(E[] arr,int lo,int hi){        int len = hi-lo+1;        if(len &lt;= 10){ //1. 数组规模小于10时使用插入排序            insertion(arr,lo,hi);            return;        }        int j = partitionMedian(arr,lo,hi);        quickMedian(arr,lo,j-1);        quickMedian(arr,j+1,hi);    }    private int partitionMedian(E[] arr,int lo,int hi){        int len = hi-lo+1;        setMedian(arr,lo,hi); //2. 从lo,hi,中间处mid三个数中找出中位数与lo交换,最大数与hi交换        E v = arr[lo]; //分切元素        int i = lo, j = hi+1;        while(true){            while(((Comparable)v).compareTo(arr[--j]) &lt; 0);            while(((Comparable)arr[++i]).compareTo(v) &lt; 0); // if(i == j) break; 取中位数时,每次最大数与hi交换,因此不需要进行边界判断            if(i &gt;= j) break;            //交换            exch(arr,i,j);        }        exch(arr,lo,j);        return j;    }    private void setMedian(E[] arr,int lo,int hi){        int mid = (lo+hi)/2;        int max = lo;        if(((Comparable)arr[max]).compareTo(arr[mid]) &lt; 0) max = mid;        if(((Comparable)arr[max]).compareTo(arr[hi]) &lt; 0) max = hi;        exch(arr,max,hi);        if(((Comparable)arr[lo]).compareTo(arr[mid]) &lt; 0) exch(arr,lo,mid);    }    private void exch(E[] arr,int i,int j){        if(i == j) return;        E temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }    private void insertion(E[] arr,int lo,int hi){        for(int i=lo+1;i&lt;=hi;++i)            for(int j=i;j&gt;lo &amp;&amp; ((Comparable)arr[j]).compareTo(arr[j-1]) &lt; 0;--j)                exch(arr,j,j-1);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2018/10/19/Merge/"/>
      <url>/2018/10/19/Merge/</url>
      
        <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>概述: 主要思想是将2个已经有序的数组归并为一个有序数组</p></blockquote><h4 id="1-自顶向下归并排序"><a href="#1-自顶向下归并排序" class="headerlink" title="1.自顶向下归并排序"></a>1.自顶向下归并排序</h4><pre><code>    /**     * 自顶向下归并排序(递归)     */    public void merge(int[] arr,int lo,int hi){        if(lo&gt;=hi)            return;        int mid = (lo+hi)/2;        merge(arr,lo,mid);        merge(arr,mid+1,hi);        inPlaceMerge(arr,lo,mid,hi);    }</code></pre><pre><code>    /**     * 归并操作(将2个有序数组归并为一个有序数组)     * @param arr  数组(包含2个有序数组)     * @param lo   第一个数组起始索引     * @param mid  第一个数组结束索引     * @param hi   第二个数组结束索引     */    public static int[] aux;    //辅助数组,最开始初始化与数组arr一致    public void inPlaceMerge(int[] arr,int lo,int mid,int hi){        //将[lo...hi]复制到数组aux中对应位置        for(int i=lo;i&lt;=hi;++i)            aux[i] = arr[i];        //merge(归并)        int i = lo,j = mid+1;   //记录2个有序数组起始索引        for(int k=lo;k&lt;=hi;k++){     //每次确定arr[k]的值即可            if(i&gt;mid) arr[k] = aux[j++];            else if(j&gt;hi) arr[k] = aux[i++];            else if(aux[i]&gt;aux[j]) arr[k] = aux[j++];            else arr[k] = aux[i++];        }    }</code></pre><ul><li>测试<pre><code>  @Test  public void testMerge() {      //创建数组      int[] arr = Arrays.stream(SortTemplate.getArray(111)).mapToInt(x -&gt; (int) x).toArray();      aux = arr.clone(); //辅助数组初始化,与arr相同      merge(arr, 0, arr.length - 1); //归并排序      System.out.println("\n" + SortTemplate.isSorted(arr)); //是否有序  }</code></pre></li></ul><blockquote><ul><li><strong>优化</strong></li></ul></blockquote><p>1.当数组规模小时,不使用归并,采用更高效方式进行排序(例插入排序)<br>2.对已经有序的数组进行判断,不需要再进行归并<br>3.每次归并操作不再往辅助数组复制,而是交替使用arr与aux作为辅助数组,从而减少复制次数</p><blockquote><ul><li>方案一: 递归中传入一个标志参数,从而实现每次交替使用arr与aux作为辅助数组</li></ul></blockquote><pre><code>    /**    * 归并排序优化    */    public void merge(int[] arr,int[] aux,int lo,int hi,boolean flag){        int mid = (lo+hi)/2;        if(hi-lo&lt;=15){  //优化1.数组规模小于15时使用插入排序            if(flag)                insertion(aux,lo,hi);            else                insertion(arr,lo,hi);            return;        }        merge(arr,aux,lo,mid,!flag);        merge(arr,aux,mid+1,hi,!flag);/*        if(arr[mid]&lt;arr[mid+1]) {   //优化2.已经有序,无需进行归并操作            return;                //注意: 交替使用arr与aux作为辅助数组时,不能使用此方法        }*/     //因为每次必须进行归并,如果不归并操作可能会造成[lo...mid]在arr上,而[mid+1...hi]在aux上        if(flag)    //优化3.交替使用arr与aux作为辅助数组(初始传入false时,最终排序结果会在arr上,true时在aux上)            inPlaceMerge(aux,arr,lo,mid,hi);        else            inPlaceMerge(arr,aux,lo,mid,hi);    }</code></pre><pre><code>    /**    * 归并操作    */    public static int[] aux;    //辅助数组,最开始初始化与数组arr一致    public void inPlaceMerge(int[] arr,int[] aux,int lo,int mid,int hi){        //arr为排序后结果数组,aux为归并辅助数组        //无需再将arr[lo...hi]复制到aux辅助数组上,减少了复制次数        int i = lo, j = mid+1;        for(int k=lo;k&lt;=hi;++k){            if(i&gt;mid) arr[k] = aux[j++];            else if(j&gt;hi) arr[k] = aux[i++];            else if(aux[i] &gt; aux[j]) arr[k] = aux[j++];            else arr[k] = aux[i++];        }    }</code></pre><pre><code>    /**     * 插入排序: 对数组arr [lo...hi]部分进行插入排序     */    public void insertion(int[] arr,int lo,int hi){        for(int i=lo+1;i&lt;=hi;++i)            for(int j=i;j&gt;lo &amp;&amp; arr[j]&lt;arr[j-1];--j){                //交换                arr[j] = arr[j]^arr[j-1];                arr[j-1] = arr[j]^arr[j-1];                arr[j] = arr[j]^arr[j-1];            }    }</code></pre><ul><li>测试</li></ul><pre><code>    @Test    public void testMerge() {        //创建数组        int[] arr = Arrays.stream(SortTemplate.getArray(111)).mapToInt(x -&gt; (int) x).toArray();        aux = arr.clone(); //辅助数组初始化,与arr相同        merge(arr,aux,0,arr.length-1,false); //优化后的归并排序        System.out.println("\n" + SortTemplate.isSorted(arr)); //是否有序    }</code></pre><blockquote><ul><li>方案二:使用全局变量作为标志,实现交替使用arr与aux作为辅助数组</li></ul></blockquote><pre><code>    /**    * 归并排序优化    */    public static boolean flag = true; //静态变量,根据静态变量值确定辅助数组    public void merge(int[] arr,int[] aux,int lo,int hi){        if(lo&gt;=hi) return;        int mid = (lo+hi)/2;        flag = !flag;        if(hi-lo&lt;=15){  //数组规模小于15时使用插入排序            if(flag)                insertion(aux,lo,hi); //插入排序            else                insertion(arr,lo,hi);            flag = !flag;            return;        }        merge(arr,aux,lo,mid);        merge(arr,aux,mid+1,hi);/*        if(arr[mid]&lt;arr[mid+1]) {   //已经有序,无需进行归并操作(交替使用arr与aux作为辅助数组时无法使用方式)            return;        }*/        if(flag)            inPlaceMerge(aux,arr,lo,mid,hi);        else            inPlaceMerge(arr,aux,lo,mid,hi);        flag = !flag;    }</code></pre><pre><code>    /**    * 归并操作    */    public static int[] aux;    //辅助数组,最开始初始化与数组arr一致    public void inPlaceMerge(int[] arr,int[] aux,int lo,int mid,int hi){        //arr为排序后结果数组,aux为归并辅助数组        //无需再将arr[lo...hi]复制到aux辅助数组上,减少了复制次数        int i = lo, j = mid+1;        for(int k=lo;k&lt;=hi;++k){            if(i&gt;mid) arr[k] = aux[j++];            else if(j&gt;hi) arr[k] = aux[i++];            else if(aux[i] &gt; aux[j]) arr[k] = aux[j++];            else arr[k] = aux[i++];        }    }</code></pre><pre><code>    /**     * 插入排序: 对数组arr [lo...hi]部分进行插入排序     */    public void insertion(int[] arr,int lo,int hi){        for(int i=lo+1;i&lt;=hi;++i)            for(int j=i;j&gt;lo &amp;&amp; arr[j]&lt;arr[j-1];--j){                //交换                arr[j] = arr[j]^arr[j-1];                arr[j-1] = arr[j]^arr[j-1];                arr[j] = arr[j]^arr[j-1];            }    }</code></pre><ul><li>测试</li></ul><pre><code>    @Test    public void testMerge() {        //创建数组        int[] arr = Arrays.stream(SortTemplate.getArray(111)).mapToInt(x -&gt; (int) x).toArray();        aux = arr.clone(); //辅助数组初始化,与arr相同        merge(arr,aux,0,arr.length-1); //优化后的归并排序        System.out.println("\n" + SortTemplate.isSorted(arr)); //是否有序    }</code></pre><h4 id="2-自底向上的归并排序"><a href="#2-自底向上的归并排序" class="headerlink" title="2.自底向上的归并排序"></a>2.自底向上的归并排序</h4><blockquote><p>概述: </p><ol><li><p>对于需要排序的数组先取子序列长度为1进行两两归并,归并后成为子序列长度为2的多个有序序列(最后一个子序列长度小于等于2)</p></li><li><p>再对子序列为2的多个有序序列进行两两归并,归并后成为子序列长度为4的多个有序序列(末尾子序列长度&lt;=4)</p></li><li><p>依次类推按照8,16,32…进行归并,直到最后归并为一个序列结束,此时数组排序完成</p></li></ol></blockquote><pre><code>    /**     * 自底向上的归并排序     */    public static int[] aux; //辅助数组    public void merge(int[] arr){        aux = arr.clone();        for(int i=1,len=arr.length;i&lt;len;i&lt;&lt;=1)            for(int lo =0;lo&lt;len-i;lo += i&lt;&lt;1)                inPlaceMerge(arr,lo,lo+i-1,Math.min(lo+(i&lt;&lt;1)-1,len-1));    }</code></pre><pre><code>    /**     * 将2个有序序列归并为一个有序序列     */    public void inPlaceMerge(int[] arr,int lo,int mid,int hi){        for(int i=lo;i&lt;=hi;++i)            aux[i] = arr[i];        int i = lo,j = mid+1;        for(int k=lo;k&lt;=hi;++k) {            if (i &gt; mid) arr[k] = aux[j++];            else if (j &gt; hi) arr[k] = aux[i++];            else if (aux[i] &gt; aux[j]) arr[k] = aux[j++];            else arr[k] = aux[i++];        }    }</code></pre><h4 id="3-多线程并行归并排序"><a href="#3-多线程并行归并排序" class="headerlink" title="3.多线程并行归并排序"></a>3.多线程并行归并排序</h4><blockquote><p>利用Fork/Join框架多线程并行归并</p></blockquote><pre><code>//使用Fork/Join进行归并排序class Merge&lt;E&gt; extends RecursiveAction{    private E[] elements;    private E[] aux;//辅助数组    private Comparator&lt;E&gt; comparator; //比较器    private int lo;    private int hi;    public Merge(E[] elements, Comparator&lt;E&gt; comparator) {        this.elements = elements;        this.aux = (E[])new Object[elements.length];        this.comparator = comparator;        //准备数据        this.lo = 0;        this.hi = elements.length-1;    }    public Merge(E[] elements){        this.elements = elements;        this.aux = (E[])new Object[elements.length];        this.comparator = (E x,E y) -&gt; {            if(x instanceof Comparable) return ((Comparable) x).compareTo(y);            else throw new RuntimeException("需要传入Comparator或者实现Comparable");        };        //准备数据        this.lo = 0;        this.hi = elements.length-1;    }    //私有构造方法用于分支调用    private Merge(E[] elements, E[] aux, Comparator&lt;E&gt; comparator, int lo, int hi) {        this.elements = elements;        this.aux = aux;        this.comparator = comparator;        this.lo = lo;        this.hi = hi;    }    //单线程归并    public void sort(){        merge(elements,aux,lo,hi);    }    //多线程并行归并    public void parallelSort(){        ForkJoinPool forkJoin = (ForkJoinPool) Executors.newWorkStealingPool();        try {            forkJoin.submit(this).get();//提交任务并获取等待结束        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        forkJoin.shutdown();    }    @Override    protected void compute() {        if(hi - lo &lt;= 10000) merge(elements,aux,lo,hi);        else{            //分成两部分,分别进行归并操作            int mid = lo + (hi-lo)/2;            Merge&lt;E&gt; mergeTask1 = new Merge&lt;&gt;(elements,aux,comparator,lo,mid);            Merge&lt;E&gt; mergeTask2 = new Merge&lt;&gt;(elements,aux,comparator,mid+1,hi);            //mergeTask1.fork(); //分支(异步): 子任务交给其他线程处理            //mergeTask2.fork();            //mergeTask1.join(); //获取(同步): 阻塞当前线程并等待获取结果            //mergeTask2.join();            invokeAll(mergeTask1,mergeTask2); //批量提交子任务,会阻塞到结果返回: 与fork不同,mergeTask1会分配给当前线程            inPlaceMerge(elements,lo,mid,hi);        }    }    //归并排序(对arr数组[lo,hi]部分进行归并排序)    private void merge(E[] arr,E[] aux,int lo,int hi){        for(int i=lo;i&lt;=hi;++i)            aux[i] = arr[i];        for(int i=1,len=hi-lo+1;i&lt;len;i&lt;&lt;=1)            for(int j = lo;j&lt;=hi-i;j += i&lt;&lt;1)                inPlaceMerge(arr,j,j+i-1,Math.min(j+(i&lt;&lt;1)-1,hi));    }    private void inPlaceMerge(E[] elements,int lo,int mid,int hi){        for(int i=lo;i&lt;=hi;++i)            aux[i] = elements[i];        int i = lo,j = mid+1;        for(int k=lo;k&lt;=hi;++k) {            if (i &gt; mid) elements[k] = aux[j++];            else if (j &gt; hi) elements[k] = aux[i++];            else if (((Comparable)aux[i]).compareTo(aux[j]) &gt; 0) elements[k] = aux[j++];            else elements[k] = aux[i++];        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2018/10/14/Shell/"/>
      <url>/2018/10/14/Shell/</url>
      
        <content type="html"><![CDATA[<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>希尔排序又称”缩小增量排序”,是插入排序的优化,插入排序在少量数据或部分有序的情况下,非常高效,因此希尔排序通过适当构造满足前述的条件,让整个排序过程处理的比插入排序更优</p></blockquote><pre><code>    /**     * 希尔排序     * 步骤: 将数组分隔为h个间隔序列,例如:数组1~6分隔为[1,3][2,4][3,6],每个间隔序列相当于一个子数组,     *       使用插入排序对子数组排序,然后减小h的值重新分割排序,当h为1时,数组和子数组相同,排序完成     * 概述: 希尔排序权衡了子数组的规模和有序性,排序之初,各个子数组都很短;排序之后,子数组长但是部分有序     *       这两种情况都很适合插入排序     */    public void shell(int[] arr){        int len = arr.length;        int h = 1;        //设置间隔序列        while(len/3&gt;h)            h = 3*h+1;        //使用插入排序对每个间隔序列进行排序        while(h &gt; 0){            for(int i=h;i&lt;len;++i){                for(int j=i;j&gt;=h &amp;&amp; arr[j] &lt; arr[j-h];j-=h){                    //交换                    arr[j] = arr[j]^arr[j-h];                    arr[j-h] = arr[j]^arr[j-h];                    arr[j] = arr[j]^arr[j-h];                }            }            h /= 3;        }    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2018/10/09/Insertion/"/>
      <url>/2018/10/09/Insertion/</url>
      
        <content type="html"><![CDATA[<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p><strong>概述</strong> </p></blockquote><p>插入排序所需的时间与数组的初始顺序有关,对于已经有序或部分有序的数组进行排序时有优势</p><blockquote><p><strong>实现</strong></p></blockquote><pre><code>    /**     * 插入排序     * 思路: 将一个元素插入到已经有序的序列中;     * 步骤: 1.起始时假设数组中索引 [0] 的为有序序列,此时将[1]插入,结果索引[0],[1]为有序序列     *   　　2.继续索引[0],[1]为有序序列,将[2]插入,结果[0],[1],[2]为有序序列     *　　　 3.依次类推,将[3]...插入,最后执行到数组末尾,则所有元素都插入到有序序列中去,排序完成     */    public void insertion(int[] arr){        for(int i=1,len=arr.length;i&lt;len;++i){            for(int j=i;j&gt;0 &amp;&amp; arr[j]&lt;arr[j-1];j--){                //交换                arr[j] = arr[j]^arr[j-1];                arr[j-1] = arr[j]^arr[j-1];                arr[j] = arr[j]^arr[j-1];            }        }    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2018/10/08/Selection/"/>
      <url>/2018/10/08/Selection/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p><strong>V1.0</strong></p></blockquote><pre><code>    /**     * 选择排序(比较大小直接交换)     */    public void select(int[] arr){        for(int i=0,len=arr.length;i&lt;len-1;++i){            for(int j=i+1;j&lt;len;++j){                if(arr[i] &lt; arr[j])                    continue;                //直接交换(交换次数多)                arr[i] = arr[i]^arr[j];                arr[j] = arr[i]^arr[j];                arr[i] = arr[i]^arr[j];            }        }    }</code></pre><blockquote><p><strong>V2.0</strong></p></blockquote><pre><code>    /**     * 选择排序(找出最小值再交换)     * 思路: 首先找出数组中最小元素,与数组第一个元素交换,     *       然后找出剩余数组中最小元素与数组第二个元素交换,     *       如此往复,直到进行到数组最后一个元素     */    public void selection(int[] arr){        for(int i=0,len=arr.length;i&lt;len-1;++i){            int min = i;            for(int j=i+1;j&lt;len;++j){                if(arr[min] &gt; arr[j])                    min = j;    //只记录索引,不交换            }            if(min == i)                continue;            //找出最小值后再交换            arr[i] = arr[i]^arr[min];            arr[min] = arr[i]^arr[min];            arr[i] = arr[i]^arr[min];        }    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>union-find算法</title>
      <link href="/2018/10/01/UnionFind/"/>
      <url>/2018/10/01/UnionFind/</url>
      
        <content type="html"><![CDATA[<h3 id="Union-Find算法"><a href="#Union-Find算法" class="headerlink" title="Union-Find算法"></a>Union-Find算法</h3><blockquote><p> <strong>基本介绍</strong></p></blockquote><blockquote><p>可以想象一张地图上有很多点，有些点之间是有道路相互联通的，而有些点则没有。如果我们现在要从点A走向点B，那么一个关键的问题就是判断我们能否从A走到B呢？换句话说，A和B是否是连通的.</p></blockquote><blockquote><p> <strong>定义union-find算法的接口UF</strong></p></blockquote><pre><code>public interface UF {    void union(int p,int q);    //在p与q之间添加一条连接    int find(int p);            //返回p所在的分量的标识符(0~N-1)    boolean connected(int p,int q); //如果p与q存在同一个分量中则返回true;    int count();    //连通分量的数量}</code></pre><h4 id="1-第一版-quick-find"><a href="#1-第一版-quick-find" class="headerlink" title="1.第一版 : quick-find"></a>1.第一版 : quick-find</h4><pre><code>/** * 思路: 使用数组表示所有触点,连通的触点设置相同值即可 * 特点: 使用该算法解决动态连通性问题并且最后只得到一个连通分量, *        则至少需要调用n-1次union(),每次都要遍历数组,即至少(n+3)(n-1) ~ N*N次数组访问, *        算法时间复杂度为平方级别的 */public class QuickFind implements UF{    private int[] id;   //分量id,以触点作为索引    private int count;  //分量数量    //初始化N(0 ~ n-1)个触点    public QuickFind(int N) {        count = N;        id = new int[N];        for(int i=0;i&lt;N;++i)            id[i] = i;    }    //在p与q之间添加一条连接    @Override    public void union(int p,int q){        int idp = find(p);        int idq = find(q);        if(idp == idq)            return;        for(int i=0;i&lt;id.length;++i){            if(id[i] == idq)                id[i] = idp;        }        count--;    }    //p所在分量的标识符    @Override    public int find(int p){        return id[p];    }    //判断是否连接    @Override    public boolean connected(int p, int q){        return find(p) == find(q);    }    //连通分量数量    @Override    public int count(){        return count;    }    //打印结果    public void print(){        for(int i:id){            System.out.print(i+" ");        }    }}</code></pre><h4 id="2-改进1-quick-union"><a href="#2-改进1-quick-union" class="headerlink" title="2.改进1: quick-union"></a>2.改进1: quick-union</h4><pre><code>/** *  思路: 每个触点值记录下一个触点数组索引 *  特点: 执行union()方法时不需要遍历整个数组, 只需要遍历同一分量的触点(与树高成正比) *        假设输入整数对为0-1 0-2 0-3 ... 0-(n-1),此时为最坏情况,时间复杂度为平方级别 */public class QuickUnion implements UF{    private int[] id;   //父连接数组,以触点作为索引    private int count;  //分量数量    public QuickUnion(int n){        count = n;        id = new int[n];        for(int i=0;i&lt;n;++i)            id[i] = i;    }    @Override    public void union(int p, int q) {        int rootP = find(p);        int rootQ = find(q);        if(rootP == rootQ)            return;        id[rootP] = rootQ;        count--;    }    @Override    public int find(int p) {        while(p != id[p])            p = id[p];        return p;    }    @Override    public boolean connected(int p, int q) {        return find(p) == find(q);    }    @Override    public int count() {        return count;    }    //打印结果    public void print(){        for(int i:id)            System.out.print(i + " ");    }}</code></pre><h4 id="3-改进2-加权quick-union"><a href="#3-改进2-加权quick-union" class="headerlink" title="3.改进2: 加权quick-union"></a>3.改进2: 加权quick-union</h4><pre><code>/** * 概述: 通过quick-union中union()方法可以发现,每次执行union()时,需要找到树根节点, *       因此考虑降低同一分量生成的树高,但同时节点多的树(大树)更容易被union()方法使用到, *       所以,在2个树合并时,优先选择降低大树的高度,即直接将小树(节点少)根节点指向大树(节点多)根节点. * 思路: 每个触点的值记录下一个触点数组索引,生成树形结构合并时,将小树根节点指向大树根节点 * */public class WeightedQuickUnion implements UF {    int[] id;  //父连接数组,以触点作为索引    int count; //分量数量    int[] sz;  //记录触点所在树的节点个数    public WeightedQuickUnion(int n) {        count = n;        id = new int[n];        sz = new int[n];        for(int i=0;i&lt;n;++i) {            id[i] = i;            sz[i] = 1;        }    }    @Override    public void union(int p, int q) {        int rootP = find(p);        int rootQ = find(q);        if(rootP == rootQ)            return;        //连通规则: 将小树(节点少)根节点指向大树(节点多)根节点        if(sz[rootP] &gt; sz[rootQ]) {            id[rootQ] = rootP;            sz[rootP] += sz[rootQ];        }        else{            id[rootP] = rootQ;            sz[rootQ] += sz[rootP];        }        count--;    }    @Override    public int find(int p) {        while(p != id[p])            p = id[p];        return p;    }    @Override    public boolean connected(int p, int q) {        return find(p) == find(q);    }    @Override    public int count() {        return count;    }    //打印结果    public void print(){        for(int i:id){            System.out.print(i+" ");        }    }}</code></pre><h4 id="4-改进3-路径压缩加权quick-union"><a href="#4-改进3-路径压缩加权quick-union" class="headerlink" title="4.改进3: 路径压缩加权quick-union"></a>4.改进3: 路径压缩加权quick-union</h4><pre><code>package cn.com.lock;/** * 思路: 在加权quick-union算法基础上,在find()方法中直接将节点连接到根节点(压缩搜索路径) */public class PathCompressionWQU implements UF{    int[] id;  //父连接数组,以触点作为索引    int count; //分量数量    int[] sz;  //记录触点所在树的节点个数    public PathCompressionWQU(int n) {        count = n;        id = new int[n];        sz = new int[n];        for(int i=0;i&lt;n;++i) {            id[i] = i;            sz[i] = 1;        }    }    @Override    public void union(int p, int q) {        int rootP = find(p);        int rootQ = find(q);        if(rootP == rootQ)            return;        //连通规则: 将小树(节点少)根节点指向大树(节点多)根节点        if(sz[rootP] &gt; sz[rootQ]) {            id[rootQ] = rootP;            sz[rootP] += sz[rootQ];        }        else{            id[rootP] = rootQ;            sz[rootQ] += sz[rootP];        }        count--;    }    @Override    public int find(int p) {        int start = p;  //记录开始节点的值        while(p != id[p]) //1. 循环结束后根节点为p            p = id[p];        //将节点连接到根节点,压缩搜索路径        //2. 再次循环,将节点都指向根节点p (除了开始节点,无法获取到索引)        while(start != p){  //处理没有指向根节点的节点,将其指向根节点 (不含开始节点)            int next = id[start];            id[start] = p;            start = next;        }        //返回根节点        return p;    }    @Override    public boolean connected(int p, int q) {        return find(p) == find(q);    }    @Override    public int count() {        return count;    }    //打印结果    public void print(){        for(int i:id){            System.out.print(i+" ");        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> union-find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2018/09/29/hanoi/"/>
      <url>/2018/09/29/hanoi/</url>
      
        <content type="html"><![CDATA[<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><blockquote><p>问题描述</p></blockquote><p>汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？</p><blockquote><p> <strong>自定义一个栈</strong></p></blockquote><pre><code>public class Stack&lt;E&gt; implements Iterable&lt;E&gt;{    private LinkedList&lt;E&gt; stack = new LinkedList&lt;&gt;();    private String name;    public Stack() {}    public Stack(String name) {        this.name = name;    }    public String getName() {        return name;    }    public void setName(String name){        this.name = name;    }    public void push(E e){        stack.push(e);    }    public E pop(){        return stack.pop();    }    public E peek(){        return stack.peek();    }    public void each(Consumer&lt;? super E&gt; consumer){        stack.stream().forEach(consumer);    }    public boolean isEmpty(){        return stack.isEmpty();    }    public int size(){        return stack.size();    }    @Override    public Iterator&lt;E&gt; iterator() {        return stack.iterator();    }}</code></pre><h4 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1.递归实现"></a>1.递归实现</h4><pre><code>    /** 递归方式     */    public void hanoi(int n,Stack&lt;Integer&gt; a,Stack&lt;Integer&gt; b,Stack&lt;Integer&gt; c){        if(n == 1){            c.push(a.pop());            System.out.println(a.getName()+" -&gt; "+c.getName());        }        else{            hanoi(n-1,a,c,b);   //将n-1个圆盘 a -&gt; b,此时c作为辅助柱子            c.push(a.pop());       //将a上第n个圆盘移动到c  a -&gt; c            System.out.println(a.getName()+" -&gt; "+c.getName());            hanoi(n-1,b,a,c);   //将b上n-1个圆盘 b -&gt; c,此时a作为辅助柱子        }    }</code></pre><h4 id="2-非递归实现"><a href="#2-非递归实现" class="headerlink" title="2.非递归实现"></a>2.非递归实现</h4><pre><code>    /** 非递归方式     *     * 概述: 根据美国学者总结的规律写即可     * 1. 将最小圆盘移动到下一个柱子(next)上(顺序ABC循环)     * 2. 将除了next以外的2个柱子顶部圆盘比较,将小的移动到大的上面(如果为空则直接移动到空柱上)     * 3. 循环步骤1,步骤2即可将一个柱子上圆盘移动到另一个柱子上     *    如果初始时A为放圆盘柱子,B,C为空,当圆盘数量N为奇数时结果会移动到B上,N为偶数会移动到C上,     *    因此起始时若N为奇数调换柱子B,C即可,最终会将圆盘移动到C上     */    public Stack&lt;Integer&gt; hanoiTower(int N,Stack&lt;Integer&gt; a,Stack&lt;Integer&gt; b,Stack&lt;Integer&gt; c){        if((N&amp;1) == 1){         //当n为奇数时调换b,c 柱子            b.setName("c");            c.setName("b");        }        Stack&lt;Integer&gt; realB = b.getName().equals("b")?b:c;    //获取到真正的b柱子        while(!(a.isEmpty() &amp;&amp; realB.isEmpty())) {      //当a,b柱子为空时移动完成            int topA = a.isEmpty()?Integer.MAX_VALUE:a.peek();            int topB = b.isEmpty()?Integer.MAX_VALUE:b.peek();            int topC = c.isEmpty()?Integer.MAX_VALUE:c.peek();            if(topA &lt; topB &amp;&amp; topA &lt; topC){                b.push(a.pop());    //1. 将最小圆盘移动到下一个柱子(next)上(顺序ABC循环)                System.out.println(a.getName()+" -&gt; "+b.getName());                compareAndMove(a,c);//2. 将除了next以外的2个柱子顶部圆盘比较,将小的移动到大的上面(如果为空则直接移动到空柱上)            }            else if(topB &lt; topA &amp;&amp; topB &lt; topC){                c.push(b.pop());                System.out.println(b.getName()+" -&gt; "+c.getName());                compareAndMove(b,a);            }            else if(topC &lt; topA &amp;&amp; topC &lt; topB){                a.push(c.pop());                System.out.println(c.getName()+" -&gt; "+a.getName());                compareAndMove(b,c);            }        }        return c;    }</code></pre><pre><code>   public void compareAndMove(Stack&lt;Integer&gt; a,Stack&lt;Integer&gt; b){        if(a.isEmpty() &amp;&amp; b.isEmpty())            return;     //移动完成        int topA = a.isEmpty()?Integer.MAX_VALUE:a.peek();        int topB = b.isEmpty()?Integer.MAX_VALUE:b.peek();        if(topA &lt; topB) {            b.push(a.pop());            System.out.println(a.getName()+" -&gt; "+b.getName());        }        else {            a.push(b.pop());            System.out.println(b.getName()+" -&gt; "+a.getName());        }    }</code></pre><blockquote><p><strong>测试</strong></p></blockquote><pre><code>    @Test    public void testHanoi(){        Stack&lt;Integer&gt; stackA = new Stack&lt;&gt;("a");        Stack&lt;Integer&gt; stackB = new Stack&lt;&gt;("b");        Stack&lt;Integer&gt; stackC = new Stack&lt;&gt;("c");        int N = 4;        for(int i=N;i&gt;0;--i){            stackA.push(i);        }        hanoiTower(N,stackA,stackB,stackC);     //非递归方式        //hanoi(N,stackA,stackB,stackC);        //递归方式        //查看结果        if(stackC.isEmpty())            stackB.forEach(x -&gt; System.out.print(x+" "));        else            stackC.forEach(x -&gt; System.out.print(x+" "));    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汉诺塔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单算术表达式求值</title>
      <link href="/2018/09/20/expression/"/>
      <url>/2018/09/20/expression/</url>
      
        <content type="html"><![CDATA[<h3 id="简单算术表达式求值-仅含-与"><a href="#简单算术表达式求值-仅含-与" class="headerlink" title="简单算术表达式求值(仅含() 与+ - * /)"></a>简单算术表达式求值(仅含() 与+ - * /)</h3><blockquote><p><strong>定义一个栈Stack类</strong></p></blockquote><pre><code>public class Stack&lt;E&gt; implements Iterable&lt;E&gt;{    private LinkedList&lt;E&gt; stack;    public Stack() {        this.stack = new LinkedList&lt;&gt;();    }    public void push(E e){        stack.push(e);    }    public E pop(){        return stack.pop();    }    public E peek(){        return stack.peek();    }    public void each(Consumer&lt;? super E&gt; consumer){        stack.stream().forEach(consumer);    }    public boolean isEmpty(){        return stack.isEmpty();    }    public int size(){        return stack.size();    }    @Override    public Iterator&lt;E&gt; iterator() {        return stack.iterator();    }}</code></pre><h4 id="1-中序表达式求值"><a href="#1-中序表达式求值" class="headerlink" title="1.中序表达式求值"></a>1.中序表达式求值</h4><pre><code>/** * 1.创建2个栈: 操作数栈dataStack 操作符栈optStack * 2.从左至右一次扫描表达式 * 3.遇到操作数时,压入dataStack * 4.遇到"+-/*"时与optStack栈顶操作符比较优先级, *   1).如果大于栈顶操作符优先级则入栈; *   2).如果小于等于栈顶操作符优先级,则取出optStack栈顶操作符 *      与dataStack栈顶2个对应操作数,将计算结果存入dataStack; *   3).重复步骤1),2),直到比optStack栈顶元素优先级高时入栈; * 6.遇到括号时 *   1).如果为"("则压入optStack; *   2).如果为")"则取出optStack栈顶操作符与dataStack栈顶2个对应操作数, *      将计算结果存入dataStack,重复此步骤,直到遇到"("停止,此时"("出栈丢弃 * 7.扫描结束后依次取出optStack栈顶操作符与dataStack栈顶2个对应操作数, *   将计算结果存入dataStack,重复此步骤,直到optStack栈为空, *   此时dataStack(仅剩一个操作数)栈顶操作数即为计算结果 */@Testpublic void expression(){    String[] exp = {            "( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )",            "2 + 3 * 4 + 5",            "100 * ( 2 + 12 )",            "100 * ( 2 + 12 ) / 14",            "(100/(3+7)+10)*(10-2)",            "5+(3+5)/4*12",            "5-2+3"    };    StringBuffer str = new StringBuffer(exp[6].replace(" ",""));    System.out.println(str);    char[] ch = str.toString().toCharArray();    Stack&lt;Character&gt; optStack = new Stack&lt;&gt;();    Stack&lt;Integer&gt; dataStack = new Stack&lt;&gt;();    for(int i=0,len=ch.length;i&lt;len;++i){        if(ch[i] == '(')            optStack.push(ch[i]);        if("*/".contains(Character.toString(ch[i]))) {            while(!optStack.isEmpty() &amp;&amp; "*/".contains(Character.toString(optStack.peek()))){                getResult(dataStack,optStack,optStack.peek());            }            optStack.push(ch[i]);        }        if("0123456789".contains(Character.toString(ch[i]))){            String dig = ""+ch[i++];            while(i&lt;len &amp;&amp; "0123456789".contains(Character.toString(ch[i]))){                dig += ch[i++];            }            i--;            dataStack.push(Integer.parseInt(dig));        }        if("+-".contains(Character.toString(ch[i]))){            while(!optStack.isEmpty() &amp;&amp; !"(".contains(optStack.peek().toString())) {                getResult(dataStack,optStack,optStack.peek());            }            optStack.push(ch[i]);        }        if(')' == ch[i]){            Character cur = null;            while((cur = optStack.peek())!='('){                getResult(dataStack,optStack,cur);            }            if(optStack.peek() == '(')                optStack.pop();        }    }    while(!optStack.isEmpty() &amp;&amp; !dataStack.isEmpty())        getResult(dataStack,optStack,optStack.peek());        System.out.print(dataStack.pop()+ " ");}public void getResult(Stack&lt;Integer&gt; dataStack,Stack&lt;Character&gt; optStack,Character cur){    optStack.pop();    switch(cur){        case '+':            dataStack.push(dataStack.pop()+dataStack.pop());            break;        case '-':            dataStack.push(-dataStack.pop()+dataStack.pop());            break;        case '*':            dataStack.push(dataStack.pop()*dataStack.pop());            break;        case '/':            Integer top = dataStack.pop();            dataStack.push(dataStack.pop()/top);            break;        default:            break;    }}</code></pre><h4 id="2-中序表达式转后序表达式再求值"><a href="#2-中序表达式转后序表达式再求值" class="headerlink" title="2.中序表达式转后序表达式再求值"></a>2.中序表达式转后序表达式再求值</h4><blockquote><p><strong>中序表达式转后序表达式</strong></p></blockquote><pre><code>    /**     * 1.创建2个栈: 中间结果栈resultStack 与 操作符栈optStack     * 2.从左至右扫描中序表达式     * 3.遇到操作数时压入resultStack栈     * 4.遇到运算符时,与optStack栈顶运算符进行比较     *   1).如果栈顶元素为"("则压入resultStack栈     *   2).如果大于栈顶运算符优先级则压入optStack栈     *   3).如果小于等于栈顶运算符优先级,则取出optStack栈顶元素压入resultStack栈,     *   4).重复步骤1),2),3)直到该运算符压入栈为止     *  5.遇到括号时     *   1).如果为"(",压入optStack     *   2).如果为")"则取出optStack栈顶元素压入resultStack栈,重复此步骤直到遇到"("结束,此时丢弃"("     *  6.扫描结束后将optStack栈中运算符压入resultStack栈     *  7.依次弹出resultStack栈元素,结果的逆序即为对应的后序表达式     */    @Test    public void backExpression(){        String[] exp = {                "( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )",                "2 + 3 * 4 + 5",                "100 * ( 2 + 12 )",                "100 * ( 2 + 12 ) / 14",                "(100/(3+7)+10)*(10-2)",                "5+(3+5)/4*12",                "5-2+3"        };        char[] ch = exp[0].replace(" ","").toCharArray();        Stack&lt;Character&gt; optStack = new Stack&lt;&gt;();        Stack&lt;String&gt; resultStack = new Stack&lt;&gt;();        for(int i=0,len=ch.length;i&lt;len;++i){            String curChar = Character.toString(ch[i]);            if('(' == ch[i])                optStack.push(ch[i]);            else if("*/".contains(curChar)){                Character cur = null;                while(!(optStack.isEmpty() || "(+-".contains((cur = optStack.peek()).toString()))){                    Character curOpt = optStack.pop();                    resultStack.push(curOpt+"");                }                optStack.push(ch[i]);            }            else if("+-".contains(curChar)){                Character cur = null;                while(!(optStack.isEmpty() || "(".contains((cur = optStack.peek()).toString()))){                    Character curOpt = optStack.pop();                    resultStack.push(curOpt+"");                }                optStack.push(ch[i]);            }            else if(')' == ch[i]){                Character cur = null;                while(!optStack.isEmpty() &amp;&amp; '(' != (cur = optStack.pop())){                    resultStack.push(cur+"");                }            }            else if("0123456789".contains(curChar)){                while(++i&lt;ch.length &amp;&amp; "0123456789".contains(Character.toString(ch[i]))){                    curChar += ch[i];                }                resultStack.push(curChar);                --i;            }            else{                throw new RuntimeException("含有无法处理操作符");            }        }        while(!optStack.isEmpty()){            resultStack.push(optStack.pop()+"");        }        //生成后续表达式        Stack&lt;String&gt; back = new Stack&lt;&gt;();        while(!resultStack.isEmpty()){            back.push(resultStack.pop());        }        //测试        back.forEach(x -&gt; System.out.print(x+" "));        Double result = calcBackExpression(back);        String resultStr = result+"";        if(resultStr.length()-2 == resultStr.indexOf(".") &amp;&amp; resultStr.charAt(resultStr.length()-1) =='0'){            resultStr = resultStr.split("\\.")[0];        }        System.out.println(resultStr);    }</code></pre><blockquote><p><strong>后序表达式求值</strong></p></blockquote><pre><code>    /**     * 1.从左至右扫描后序表达式     * 2.遇到操作数压入栈中     * 3.遇到运算符,从栈中弹出2个对应操作数计算结果并压入该栈     * 4.扫描到结尾栈中的值即为计算结果     */    public Double calcBackExpression(Stack&lt;String&gt; stack){        Stack&lt;Double&gt; dataStack = new Stack&lt;&gt;();        while(!stack.isEmpty()){            String cur = stack.pop();            if("+-*/".contains(cur)){                switch(cur){                    case "+":                        dataStack.push(dataStack.pop()+dataStack.pop());                        break;                    case "-":                        dataStack.push(-dataStack.pop()+dataStack.pop());                        break;                    case "*":                        dataStack.push(dataStack.pop()*dataStack.pop());                        break;                    case "/":                        dataStack.push(1/dataStack.pop()*dataStack.pop());                        break;                    default:                        break;                }            }            else{                dataStack.push(Double.parseDouble(cur));            }        }        return dataStack.pop();    }</code></pre><h4 id="3-中序表达式转前序表达式再求值"><a href="#3-中序表达式转前序表达式再求值" class="headerlink" title="3.中序表达式转前序表达式再求值"></a>3.中序表达式转前序表达式再求值</h4><blockquote><p><strong>中序表达式转前序表达式</strong></p></blockquote><pre><code>    /**     * 1.创建2个栈: 中间结果栈resultStack 与 操作符栈optStack     * 2.从右至左扫描中序表达式     * 3.遇到操作数压入resultStack栈     * 4.遇到操作符时与optStack栈顶元素优先级进行比较     *  1).如果栈顶元素为")",则压入optStack栈     *  2).如果优先级大于等于栈顶元素,则压入optStack栈;     *  3).如果优先级小于栈顶元素,则弹出optStack栈顶元素压入resultStack栈;     *  4).重复步骤1),2),3)直到该操作符压入栈为止     * 5.遇到括号时     *  1).如果为")",则压入optStack栈;     *  2).如果为"(",则依次弹出optStack栈顶元素压入resultStack栈,直到遇到")"为止,此时丢弃"(";     * 6.扫描结束后,依次弹出optStack栈中操作符压入resultStack栈     * 7.依次弹出resultStack栈元素,其结果即为前序表达式     */    @Test    public void preOrderExpression(){        String[] exp = {                "( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )",                "2 + 3 * 4 + 5",                "100 * ( 2 + 12 )",                "100 * ( 2 + 12 ) / 14",                "(100/(3+7)+10)*(10-2)",                "5+(3+5)/4*12",                "5-2+3"        };        char[] ch = exp[0].replace(" ","").toCharArray();        Stack&lt;Character&gt; optStack = new Stack&lt;&gt;();        Stack&lt;String&gt; resultStack = new Stack&lt;&gt;();        for(int i=ch.length-1;i&gt;=0;--i){            Character cur = ch[i];            if(')' == cur || "/*".contains(cur+""))                optStack.push(cur);            else if("+-".contains(Character.toString(cur))){                while(!optStack.isEmpty() &amp;&amp; "/*".contains(optStack.peek()+"")){                    resultStack.push(optStack.pop()+"");                }                optStack.push(cur);            }            else if("0123456789".contains(Character.toString(cur))){                String temp = cur+"";                while(--i &gt;= 0 &amp;&amp; "0123456789".contains(ch[i]+"")){                    temp += ch[i];                }                resultStack.push(new StringBuilder(temp).reverse().toString());                ++i;            }            else if('(' == cur){                while(!optStack.isEmpty() &amp;&amp; ')' != optStack.peek()){                    resultStack.push(optStack.pop()+"");                }                optStack.pop();            }            else{                throw new RuntimeException("未知运算符");            }        }        while(!optStack.isEmpty())            resultStack.push(optStack.pop()+"");        Stack&lt;String&gt; preOrder = new Stack&lt;&gt;();        //resultStack.forEach(x -&gt; System.out.print(x+" "));        while(!resultStack.isEmpty())            preOrder.push(resultStack.pop());        //preOrder.forEach(x -&gt; System.out.print(x+" "));        System.out.print(calcPreOrder(preOrder));    }</code></pre><blockquote><p><strong>前序表达式求值</strong></p></blockquote><pre><code>    /**     * 1.从右至左扫描前序表达式     * 2.遇到操作数压入栈     * 3.遇到运算符时从栈中弹出2个对应操作数并将计算结果入栈     *   注意: 依次弹出a1 a2 ,若运算符为"-"则计算为 a1-a2, 如果为"/" 为a1/a2     * 4.扫描结束后栈中的值即为前序表达式值     */    public Double calcPreOrder(Stack&lt;String&gt; stack){        Stack&lt;Double&gt; dataStack = new Stack&lt;&gt;();        while(!stack.isEmpty()){            String cur = stack.pop();            if("+-*/".contains(cur)){                switch(cur){                    case "+":                        dataStack.push(dataStack.pop()+dataStack.pop());                        break;                    case "-":                        dataStack.push(dataStack.pop()-dataStack.pop());                        break;                    case "*":                        dataStack.push(dataStack.pop()*dataStack.pop());                        break;                    case "/":                        dataStack.push(dataStack.pop()/dataStack.pop());                        break;                    default:                        break;                }            }            else{                dataStack.push(Double.parseDouble(cur));            }        }        return dataStack.pop();    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算术表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十进制正整数转二进制输出</title>
      <link href="/2018/09/02/binary/"/>
      <url>/2018/09/02/binary/</url>
      
        <content type="html"><![CDATA[<h3 id="1-十进制正整数转二进制输出"><a href="#1-十进制正整数转二进制输出" class="headerlink" title="1.十进制正整数转二进制输出"></a>1.十进制正整数转二进制输出</h3><pre><code>    //思路: 逐位取出二进制数    public void binary(){        int dec = 3;        String result = "";        for(;dec!=0;dec&gt;&gt;&gt;=1)            result += dec&amp;1;        System.out.println(new StringBuilder(result).reverse());    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程通信-简单的连接池实例</title>
      <link href="/2018/07/09/DataSourcePool/"/>
      <url>/2018/07/09/DataSourcePool/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简单连接池实例"><a href="#1-简单连接池实例" class="headerlink" title="1.简单连接池实例"></a>1.简单连接池实例</h3><a id="more"></a><pre><code>public class DataSourcePool {    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();    private int COUNT_INIT;          //初始化连接数    private int COUNT_MAX;          //最大连接数    private volatile int COUNT_CURRENT = 0;       //当前连接数量    private String DRIVER_CLASS;    private String URL;    private String USER_NAME;    private String PASSWORD;    private Lock lock = new ReentrantLock();    private Condition c = lock.newCondition();    public DataSourcePool(Properties properties) {        COUNT_INIT = Integer.parseInt(properties.getProperty("initialSize"));        COUNT_MAX = Integer.parseInt(properties.getProperty("maxActive"));        DRIVER_CLASS = properties.getProperty("driverClass");        URL = properties.getProperty("url");        USER_NAME = properties.getProperty("userName");        PASSWORD = properties.getProperty("password");        try {            Class.forName(DRIVER_CLASS);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        for(int i=0;i&lt;COUNT_INIT;i++){            try {                pool.add(DriverManager.getConnection(URL,USER_NAME,PASSWORD));                COUNT_CURRENT++;            } catch (SQLException e) {                e.printStackTrace();            }        }    }    //获取连接    public Connection getConnection(){        Connection result = null;        lock.lock();        try {            while (pool.isEmpty() &amp;&amp; COUNT_CURRENT &gt;= COUNT_MAX) {                c.await();          //如果连接池为空且连接数已经达到最大则等待            }            if (pool.isEmpty()&amp;&amp;COUNT_CURRENT &lt; COUNT_MAX) {                result = DriverManager.getConnection(URL, USER_NAME, PASSWORD);                COUNT_CURRENT++;            }            else{                result = pool.removeLast();            }        }catch(Exception e){            e.printStackTrace();        }        finally{            lock.unlock();        }        return result;    }    //释放连接    public void release(Connection connection){        lock.lock();        try {            if(pool.size()&lt;COUNT_INIT){                pool.push(connection);                c.signal();            }            else{                connection.close();                COUNT_CURRENT--;            }        }catch(Exception e){            e.printStackTrace();        }        finally{            lock.unlock();        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Lock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程通信-生产者与消费者简单实例(二)</title>
      <link href="/2018/07/06/ProcerAndConsumer2/"/>
      <url>/2018/07/06/ProcerAndConsumer2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-产品类"><a href="#1-产品类" class="headerlink" title="1.产品类"></a>1.产品类</h3><pre><code>//产品public class Product {    public Product(){        System.out.print("生产了一个产品");    }}</code></pre><h3 id="2-生产者类"><a href="#2-生产者类" class="headerlink" title="2.生产者类"></a>2.生产者类</h3><pre><code>//生产者public class Producer implements Runnable{    private int COUNT_MAX;               //仓库大小    private LinkedList&lt;Product&gt; list;   //仓库    private Lock lock;    private Condition c;    private Condition p;    public Producer(Consumer consumer,int COUNT_MAX){        this.COUNT_MAX = COUNT_MAX;        this.list = consumer.getList();        this.lock = consumer.getLock();        this.c = consumer.getC();        this.p = consumer.getP();    }    @Override    public void run() {        //不断的生产产品放入仓库        for(;;){            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }            lock.lock();            try{                while(list.size() &gt;= COUNT_MAX){     //仓库数量大于COUNT_MAX时等待                    try {                        p.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                list.push(new Product());                System.out.println(",还剩下: "+list.size()+"个");                c.signal();   //唤醒消费者消费            }finally{                lock.unlock();            }        }    }}</code></pre><h3 id="3-消费者类"><a href="#3-消费者类" class="headerlink" title="3.消费者类"></a>3.消费者类</h3><pre><code>//消费者public class Consumer implements Runnable {    private LinkedList&lt;Product&gt; list = new LinkedList&lt;Product&gt;();    private Lock lock = new ReentrantLock();    private Condition c = lock.newCondition();    private Condition p = lock.newCondition();    public LinkedList&lt;Product&gt; getList() {        return list;    }    public Lock getLock() {        return lock;    }    public Condition getC() {        return c;    }    public Condition getP() {        return p;    }    @Override    public void run() {        for(;;){            try {                TimeUnit.MILLISECONDS.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }            //不断从仓库消费产品            lock.lock();            try{                while(list.size() &lt;= 0){//仓库没产品时等待                    try {                        c.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                list.pop();                System.out.println("消费了一个产品,剩: "+list.size()+"个");                p.signal();   //消费产品后唤醒生产者            }finally{                lock.unlock();            }        }    }}</code></pre><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><pre><code>@Testpublic void Test(){    Consumer consumer = new Consumer();    Producer producer = new Producer(consumer,10);    new Thread(consumer).start();    new Thread(consumer).start();    new Thread(producer).start();    new Thread(producer).start();    new Thread(producer).start();    new Thread(producer).start();    try {        Thread.sleep(100);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Lock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者与消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程通信-生产者与消费者简单实例(一)</title>
      <link href="/2018/07/04/ProcerAndConsumer1/"/>
      <url>/2018/07/04/ProcerAndConsumer1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-产品类"><a href="#1-产品类" class="headerlink" title="1.产品类"></a>1.产品类</h3><pre><code>//产品public class Product {    public Product(){        System.out.print("生产了一个产品");    }}</code></pre><h3 id="2-生产者类"><a href="#2-生产者类" class="headerlink" title="2.生产者类"></a>2.生产者类</h3><pre><code>//生产者public class Producer implements Runnable{    int COUNT_MAX;                      //仓库大小    private LinkedList&lt;Product&gt; list;   //仓库    public Producer(LinkedList&lt;Product&gt; list,int COUNT_MAX){        this.list = list;        this.COUNT_MAX = COUNT_MAX;    }    @Override    public void run() {        //不断的生产产品放入仓库        for(;;){            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }            synchronized (list){                while(list.size() &gt;= COUNT_MAX){     //仓库满时等待                    try {                        list.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                list.push(new Product());                System.out.println(",还剩下: "+list.size()+"个");                list.notifyAll();   //唤醒消费者消费            }        }    }}</code></pre><h3 id="3-消费者类"><a href="#3-消费者类" class="headerlink" title="3.消费者类"></a>3.消费者类</h3><pre><code>//消费者public class Consumer implements Runnable {    private LinkedList&lt;Product&gt; list;    public Consumer(LinkedList&lt;Product&gt; list){        this.list = list;    }    @Override    public void run() {        for(;;){            try {                TimeUnit.MILLISECONDS.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }            //不断从仓库消费产品            synchronized (list){                while(list.size() &lt;= 0){//仓库没有产品时等待                    try {                        list.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                list.pop();                System.out.println("消费了一个产品,剩: "+list.size()+"个");                list.notifyAll();   //消费产品后唤醒生产者            }        }    }}</code></pre><p>4.测试</p><pre><code>    @Test    public void Test(){        LinkedList&lt;Product&gt; list = new LinkedList&lt;Product&gt;();        Consumer consumer = new Consumer(list);        Producer producer = new Producer(list,10);        new Thread(consumer).start();        new Thread(consumer).start();        new Thread(producer).start();        new Thread(producer).start();        new Thread(producer).start();        new Thread(producer).start();        try {            Thread.sleep(100);        } catch (InterruptedException e) {            e.printStackTrace();        }    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Lock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者与消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java同步锁概述</title>
      <link href="/2018/07/02/JavaLock/"/>
      <url>/2018/07/02/JavaLock/</url>
      
        <content type="html"><![CDATA[<h3 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1.synchronized"></a>1.synchronized</h3><blockquote><p>synchronized是一种简单的可重入锁,JDK6开始对synchronized做了大量优化,性能和ReentrantLock差距不大</p></blockquote><h3 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h3><blockquote><p>ReentrantLock是可重入锁,它可以完全替代synchronized,每次使用都要显示的加锁与解锁,而且提供了新的特性: 公平锁,有条件,可定时,可轮询,可中断,可以有效避免死锁的活跃性问题.</p></blockquote><blockquote><p><strong>公平锁:</strong> 线程按照发出请求的顺序来获取锁,创建ReentrantLock对象时传入true即可生成公平锁</p><p><strong>非公平锁:</strong> 不必按照发出请求的顺序获取锁,可以插队,创建ReentrantLock时默认为非公平锁</p></blockquote><blockquote><p><strong>条件:</strong>对于每个重入锁,都可以通过newCondition()方法绑定若干个条件对象,不同的线程可以等待不同的条件,从而实现更加细粒度的线程间通信</p></blockquote><blockquote><p><strong>可轮询与可定时:</strong>在获取锁时,先使用tryLock()尝试获取所有的锁,如果不能同时获得,就退回,并重新尝试,休眠时间由一个特定的组件完成</p></blockquote><blockquote><p><strong>可中断:</strong>lockInterruptibly方法能够在获取锁的同时保持对中断的响应</p></blockquote><h3 id="3-ReadWriteLock-读写锁"><a href="#3-ReadWriteLock-读写锁" class="headerlink" title="3.ReadWriteLock(读写锁)"></a>3.ReadWriteLock(读写锁)</h3><blockquote><p>ReentrantReadWriteLock实现了ReadWriteLock接口,构造器提供了公平锁与非公平锁两种创建方式,对于读多写少的场景,如果全部使用<strong>排它锁</strong>显然是没有必要的,因为不同的读操可以并发执行提高效率,如果使用<strong>排它锁</strong>则读操作会阻塞其他读操作降低效率,此时使用读写锁是更好的选择</p></blockquote><blockquote><p><strong>读锁(共享锁):</strong>允许多个读线程并发执行</p><p><strong>写锁(排他锁):</strong>不允许写线程与其他线程(读或者写线程)并发执行</p></blockquote><blockquote><p><strong>读锁的升级:</strong>读锁升级为写锁,ReentrantReadWriteLock<strong>不支持锁升级</strong></p><p><strong>写锁的降级:</strong>持有写锁的同时去获取读锁,然后释放写锁</p></blockquote><blockquote><ul><li><strong>写锁降级的简单介绍</strong></li></ul><blockquote><p>首先要了解写锁的特点,线程间是互斥的,但是如果是当前线程则可重入,因此仅仅对当前线程而言,可以在获取到写锁以后再获取读锁,然后再释放写锁</p></blockquote></blockquote><blockquote><ul><li><strong>通过简化实例简单了解锁降级</strong></li></ul></blockquote><pre><code>//主要代码public class Degrade {    volatile int value = 0;    public void getAndSetValue(){        Thread.sleep(100);    //便于测试        value++;                            //写操作        Thread.sleep(100);    //便于测试        System.out.println(value);          //读操作    }    public void getValue(){        Thread.sleep(100);    //便于测试        System.out.println("get:"+value);      //读操作    }       }</code></pre><pre><code>//测试代码      @Test    public void test(){        Degrade deGrade = new Degrade();        for(int i=0;i&lt;2;i++){       //创建2个读写线程            new Thread(new Runnable() {                @Override                public void run() {                    for(;;){                        deGrade.getAndSetValue();                    }                }            }).start();        }        for (int i=0;i&lt;5;i++){      //创建5个读线程            new Thread(new Runnable() {                @Override                public void run() {                    for (;;){                        deGrade.getValue();                    }                }            }).start();        }</code></pre><blockquote><p><strong>现在我们要完成每一次value值更新,都会至少被一个读操作读取到,显然不加锁的情况下,是不行的</strong></p></blockquote><ol><li><p>测试方式1,改写如下</p><pre><code>//主要代码public class Degrade {    volatile int value = 0;    final ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();    Lock read = rwlock.readLock();    Lock write = rwlock.writeLock();    public void getAndSetValue(){        Thread.sleep(100);    //便于测试        write.lock();        value++;                            //写操作        write.unlock();                    //写锁释放        Thread.sleep(100);    //便于测试        read.lock();        System.out.println(value);          //读操作        read.unlock();    }    public void getValue(){        Thread.sleep(100);    //便于测试        read.lock();        System.out.println("get:"+value);      //读操作        read.unlock();    }       }输出结果片段:2get:2get:4//显然此时不能满足条件,因为当写锁释放时,此时可能由其他读写线程先执行,这样value刚更改过还没有被读取输出过就又没修改了,因此输出结果不续性</code></pre></li></ol><blockquote><ol start="2"><li>测试方式2,改写如下</li></ol></blockquote><pre><code>```//主要代码public class Degrade {    volatile int value = 0;    final ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();    Lock read = rwlock.readLock();    Lock write = rwlock.writeLock();    public void getAndSetValue(){        Thread.sleep(100);    //便于测试        write.lock();        value++;                            //写操作        Thread.sleep(100);    //便于测试        System.out.println(value);          //读操作        write.unlock();    }    public void getValue(){        Thread.sleep(100);    //便于测试        read.lock();        System.out.println("get:"+value);      //读操作        read.unlock();    }       }输出结果为: 12get:2get:2get:2get:2get:23get:3get:3get:34get:4get:4//可以看到满足要求,输出结果连续,但是这种方式,将一个读操作也放入写锁中,每次写操作完成后必定执行此读操作,从而实现每次更新value值后,都至少有一个读操作读取到value值输出//现在如果要写操作执行完成后,其他读操作都有机会先执行,该怎么实现?```</code></pre><blockquote><ol start="3"><li>测试方式3(<strong>写锁降级</strong>),修改如下</li></ol></blockquote><pre><code>~~~//主要代码public class Degrade {    volatile int value = 0;    final ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();    Lock read = rwlock.readLock();    Lock write = rwlock.writeLock();    public void getAndSetValue(){        Thread.sleep(100);    //便于测试        write.lock();    //获取写锁        value++;                            //写操作        read.lock();    //已经有写锁的情况下可直接获取到读锁(无需竞争)        write.unlock();    //释放写锁,此时锁降级为读锁(其他读线程可以并行)        Thread.sleep(100);    //便于测试        System.out.println(value);          //读操作        read.unlock();    //释放读锁            }    public void getValue(){        Thread.sleep(100);    //便于测试        read.lock();        System.out.println("get:"+value);      //读操作        read.unlock();    }       }输出结果:1get:2get:2get:2get:2get:2get:22get:2get:2get:2get:23get:3get:3get:4get:4get:44get:4get:4//可以看到写操作执行完成之后,其他的读操作都有机会先执行,因为写操作完成后写锁降级为读锁,此时所有读线程都有机会抢到cpu执行权,例如先输出get:4,后输出4~~~</code></pre><blockquote><p><strong>显然通过上面的对比可以发现,写锁降级为读锁后,其他读锁都可以并发执行了,从侧面提升了读的效率,同时也使读线程可以更加敏感的感知到数据的更新</strong></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Lock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AQS实现一个简单的可重入锁</title>
      <link href="/2018/05/24/MutexLock/"/>
      <url>/2018/05/24/MutexLock/</url>
      
        <content type="html"><![CDATA[<h3 id="1-AbstractQueuedSynchronizer-AQS-简单介绍"><a href="#1-AbstractQueuedSynchronizer-AQS-简单介绍" class="headerlink" title="1.AbstractQueuedSynchronizer(AQS)简单介绍"></a>1.AbstractQueuedSynchronizer(AQS)简单介绍</h3><p>AQS定义了一套多线程访问共享资源的同步器框架,其核心功能都是围绕着其32位整型属性state进行，一般可以说它表示锁的数量，对同步状态的控制可以实现不同的同步工具，例如闭锁、信号量、栅栏等等。为了保证可见性此变量被声明为volatile，保证每次的原子更新都将及时反映到每条线程上。而对于同步状态的管理可以大体分为两块，一是独占模式的管理，另外是共享模式的管理  </p><h3 id="2-可重入锁简单实现"><a href="#2-可重入锁简单实现" class="headerlink" title="2.可重入锁简单实现"></a>2.可重入锁简单实现</h3><blockquote><p>利用AQS实现Lock接口的方法</p></blockquote><pre><code>import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;//使用AQS实现可重入锁public class Mutex implements Lock{    private Sync sync = new Sync();    //借助AQS实现同步    private class Sync extends AbstractQueuedSynchronizer{        @Override        protected boolean tryAcquire(int arg) {            /***             * 返回true表示可以获取锁             */            Thread current = Thread.currentThread();            /**             * state相当于信号量,作为锁的状态标识             */            int state = getState();            if(state == 0){                if(compareAndSetState(0,arg)){                    setExclusiveOwnerThread(current);                    return true;                }            }else if(current == getExclusiveOwnerThread()){  //如果是相同线程则可重入                state += arg;                setState(state);                return true;            }            /**             * 返回false表示不能获取锁             */            return false;        }        @Override        protected boolean tryRelease(int arg) {            /**             * 返回true表示可以释放锁             */            if(Thread.currentThread()!=getExclusiveOwnerThread())                throw new RuntimeException();            int state = getState()-arg;            boolean flag = false;            if(state == 0){                setExclusiveOwnerThread(null);                flag = true;            }            /**             * 返回false表示不能释放锁             */            setState(state);  //更新重入锁状态            return flag;        }        /**         * 判断是否获取到了锁         */        @Override        protected boolean isHeldExclusively() {            return getExclusiveOwnerThread() == Thread.currentThread();        }    }    //实现Lock接口的方法    @Override    public void lock() {        sync.acquire(1);//内部会先调用tryAcquire方法判断是否可以获取锁    }    @Override    public void lockInterruptibly() throws InterruptedException {        sync.acquireInterruptibly(1);    }    @Override    public boolean tryLock() {        return sync.tryAcquire(1);    }    @Override    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {        return sync.tryAcquireNanos(1,unit.toNanos(time));    }    @Override    public void unlock() {        sync.release(1);//内部会先调用tryRelease方法判断是否可以释放锁    }    @Override    public Condition newCondition() {        return sync.new ConditionObject();    }}</code></pre><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><pre><code>public class Multi {    private int value = 0;    Mutex mutex = new Mutex();  //创建自定义锁对象    //ReentrantLock mutex = new ReentrantLock();    public void incA(){        mutex.lock();       //获取锁        value +=1;        try {            Thread.sleep(100);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("A: "+value);        incB(); //可重入测试        mutex.unlock();     //释放锁    }    public void incB(){        mutex.lock();       //获取锁        value += 1;        System.out.println("B: "+value);        mutex.unlock();     //释放锁    }    @Test    public void test(){        Multi multi = new Multi();        //线程1        new Thread(new Runnable() {            @Override            public void run() {                for(;;){                    multi.incA();                }            }        }).start();        //线程2        new Thread(new Runnable() {            @Override            public void run() {                for(;;){                    multi.incA();                }            }        }).start();        try {            Thread.sleep(10000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Lock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简单的可重入锁</title>
      <link href="/2018/05/23/SimpleLock1/"/>
      <url>/2018/05/23/SimpleLock1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简单实现"><a href="#1-简单实现" class="headerlink" title="1.简单实现"></a>1.简单实现</h3><blockquote><p>实现Lock接口并实现其lock方法与unlock方法</p></blockquote><pre><code>//利用Lock接口实现一个可重入锁public class ReLock implements Lock{    private boolean isLock = false;  //锁是否被获取    private int count = 0; //记录一个线程获取同一个锁的次数    private Thread lockBy = null; //记录当前获取到锁的线程    //获取锁    @Override    public synchronized void lock() {        Thread currentThread = Thread.currentThread();        while(isLock &amp;&amp; currentThread!=lockBy){            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        isLock = true;        lockBy = currentThread;        count++;    }    //释放锁    @Override    public synchronized void unlock() {        count--;        if(count == 0) {            isLock = false;            notify();        }    }    //实现其他方法}</code></pre><h3 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h3><pre><code>public class ReLockTest {    //创建自定义的可重入锁对象    public ReLock lock = new ReLock();    public int value = 0;    public void getNext(){  //自定义锁测试方法        //获取锁        lock.lock();        value++;        try {            Thread.sleep(100);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(value);        //释放锁        lock.unlock();    }    public void ReLockA(){      //可重入测试方法        //获取锁        lock.lock();        value++;        ReLockB();      //可重入则正常运行        System.out.println("A: "+value);        //释放锁        lock.unlock();    }    public void ReLockB(){        //获取锁        lock.lock();        value++;        System.out.println("B: "+value);        //释放锁        lock.unlock();    }    @Test    public void test(){        ReLockTest test = new ReLockTest();        new Thread(new Runnable() {     //自定义锁测试线程1            @Override            public void run() {                while(true){                    test.getNext();                    //test.ReLockA();   //可重入测试                }            }        }).start();        new Thread(new Runnable() {     //自定义锁测试线程2            @Override            public void run() {                while(true){                    test.getNext();                }            }        }).start();        try {            Thread.sleep(10000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Lock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git简单使用</title>
      <link href="/2018/05/22/git/"/>
      <url>/2018/05/22/git/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Git安装"><a href="#1-Git安装" class="headerlink" title="1.Git安装"></a>1.Git安装</h3><blockquote><ul><li><strong>在Linux上安装Git</strong></li></ul></blockquote><p>先查看系统有没有安装git,如下表示没有安装</p><pre><code>$ gitThe program 'git' is currently not installed. You can install it by typing:sudo apt-get install git</code></pre><p>安装</p><p>新版本的Debian或Ubuntu Linux 使用<code>sudo apt-get install git</code></p><p>老版本的Debian或Ubuntu Linux 使用<code>sudo apt-get install git-core</code></p><p>其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。 </p><blockquote><ul><li><strong>Moc OS 上安装Git</strong></li></ul></blockquote><p><strong>方案1:</strong> 安装homebrew，然后通过homebrew安装Git，具体参考<a href="http://brew.sh/" target="_blank" rel="noopener">homebrew文档</a></p><p><strong>方案2(推荐):</strong> 安装Xcode即可,Xcode已经集成Git</p><blockquote><ul><li><strong>Windows上安装Git</strong></li></ul></blockquote><p>直接从Git官网<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>,然后按默认安装即可</p><blockquote><ul><li><strong>安装完成后进行设置</strong></li></ul></blockquote><p>进入git bash输入:</p><pre><code>$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"</code></pre><p><strong>注意:</strong> 注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址,不加<code>--global</code>参数即可。 </p><hr><h3 id="2-创建版本库"><a href="#2-创建版本库" class="headerlink" title="2.创建版本库"></a>2.创建版本库</h3><blockquote><ul><li><strong>概述</strong></li></ul></blockquote><p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 </p><p><strong>注意:</strong> 版本控制系统只能跟踪文本文件的改动,而图片丶视频丶word等二进制文件只能知道文件变动了,但是具体变动了什么内容,版本控制系统并不知道</p><blockquote><ul><li><strong>创建空目录</strong></li></ul></blockquote><pre><code>$ mkdir repositoryName</code></pre><blockquote><ul><li><strong>初始化</strong></li></ul></blockquote><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库,创建完成后多了一个<code>.git</code>隐藏目录</p><pre><code>$ git init</code></pre><blockquote><ul><li><strong>把文件添加到版本库</strong></li></ul></blockquote><ol><li>将文件放入版本库<code>respositoryName</code>目录下,如<code>readme.txt</code></li><li>使用命令<code>git add</code>把文件添加到Git仓库,没有任何显示表示添加成功</li></ol><pre><code>$ git add readme.txt</code></pre><ol start="3"><li>用命令<code>git commit</code>告诉Git，把文件提交到仓库:</li></ol><pre><code>$ git commit -m "wrote a readme file"</code></pre><p><code>-m</code>后面输入表示本次提交的说明</p><p>可以使用<code>git add</code>添加多次,最后再使用<code>git commit</code>提交</p><hr><h3 id="3-版本控制"><a href="#3-版本控制" class="headerlink" title="3.版本控制"></a>3.版本控制</h3><blockquote><ul><li><strong>常用查看命令</strong></li></ul></blockquote><p><code>git status</code> 查看仓库当前状态</p><p><code>git diff</code> 查看difference</p><p><code>git log</code> 查看版本提交日志</p><p><code>git reflog</code> 查看你的每一次命令</p><blockquote><ul><li><strong>版本回退</strong></li></ul></blockquote><p><code>git reset --hard HEAD^</code> 回退到上一个版本,<code>HEAD</code>表示当前版本,<code>HEAD^</code>表示上一个版本,<code>HEAD^^</code>表示上上一个版本,<code>HEAD~100</code>表示往上100个版本</p><p><code>git reset --hard &lt;commit id&gt;</code> 回退到指定的提交版本,<code>commit id</code>可以通过<code>git log</code>或<code>git reflog</code>查看</p><p><strong>注意:</strong> 版本号<code>commit id</code> 只需写前几位能定位到唯一版本即可</p><blockquote><ul><li><strong>撤销修改</strong></li></ul></blockquote><p><strong>场景1:</strong>当你改乱了工作区某个文件的内容,想直接丢弃工作区的修改时,用命令<code>git checkout -- fileName</code></p><p><strong>场景2:</strong>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;fileName&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p><strong>场景3:</strong>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本回退</strong>，不过前提是没有推送到远程库。</p><blockquote><ul><li><strong>删除文件</strong></li></ul></blockquote><p><strong>场景1:</strong> 确实要删除版本库中的文件,使用<code>git rm &lt;fileName&gt;</code>,并且<code>git commit</code></p><p><strong>场景2:</strong> 如果删除错了,可以把误删的文件恢复到最新版本,使用<code>git checkout --&lt;fileName&gt;</code></p><hr><h3 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4.远程仓库"></a>4.远程仓库</h3><blockquote><ul><li><strong>查看远程仓库</strong></li></ul></blockquote><p><code>git remote</code>            查看远程仓库信息(git中默认远程仓库名字为<code>origin</code>)</p><p><code>git remote -v</code>        查看远程仓库详细信息</p><p>如下: <strong>fetch</strong>表示可以抓取的远程仓库,<strong>push</strong>表示可以推送的远程仓库</p><pre><code>$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)</code></pre><blockquote><ul><li><strong>添加远程仓库</strong>(Github为例)</li></ul></blockquote><ol><li>关联Github仓库</li></ol><pre><code>$ git remote add origin git@github.com:yourGithubName/repositoryName.git</code></pre><p><strong>注意:</strong> <code>yourGithubName</code>是你的github账户名,<code>repositoryName</code>是你的github仓库名</p><p>​    添加完成后Git中默认的远程仓库的名字就是<code>origin</code> </p><ol start="2"><li>把本地仓库的内容推送到远程仓库</li></ol><pre><code>$ git push -u origin master</code></pre><p>把当前分支<code>master</code>推送到远程,由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以<strong>简化命令</strong>为<code>git push origin master</code></p><blockquote><ul><li><strong>从远程仓库上克隆</strong></li></ul></blockquote><pre><code>$ git clone git@github.com:yourGithubName/repositoryName.git</code></pre><p> <code>yourGithubName</code>是你的github账户名,<code>repositoryName</code>是你的github仓库名</p><p><strong>注意:</strong> Github给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code></p><hr><h3 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5.分支管理"></a>5.分支管理</h3><blockquote><ul><li><strong>创建分支</strong></li></ul></blockquote><p><code>git checkout -b hexo</code>        创建hexo分支并切换到hexo分支</p><pre><code>git branch hexo               创建hexo分支git checkout hexo          切换到hexo分支</code></pre><blockquote><ul><li><strong>查看分支</strong></li></ul></blockquote><p><code>git branch</code>                    查看所有分支,当前分支前面会有一个<code>*</code></p><blockquote><ul><li><strong>合并分支</strong></li></ul></blockquote><pre><code>git merge hexo                把hexo分支合并到当前分支git merge --no-ff -m "merge with no-ff" hexo    合并分支时禁用Fast forward模式</code></pre><p><strong>注意:</strong> Git默认使用<code>fast forward</code>模式,此模式下删除分之后,会丢掉分支信息</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。 </p><blockquote><ul><li><strong>删除分支</strong></li></ul></blockquote><pre><code>git branch -d hexo            删除hexo分支git branch -D hexo            强制删除hexo分支(可不合并直接删除)</code></pre><blockquote><ul><li><strong>推送分支</strong></li></ul></blockquote><p><code>git push origin master</code>          将本地master分支推送到远程仓库origin上的master分支</p><blockquote><ul><li><strong>抓取分支</strong></li></ul></blockquote><p><code>git pull</code>                    抓取远程仓库的新提交</p><blockquote><ul><li><strong>存储工作现场</strong></li></ul></blockquote><p><code>git stash</code>                    把当前工作现场存储起来</p><p><code>git stash list</code>                查看存储的工作现场如<code>stash@{0}</code></p><pre><code>git stash apply                将当前的工作现场恢复到存储的工作现场git stash apply stash@{0}     恢复到指定的工作现场</code></pre><p><code>git stash drop</code>                删除存储的工作现场</p><p><code>git stash pop</code>                恢复到存储的工作现场并删除</p><blockquote><ul><li><strong>Bug分支使用</strong></li></ul></blockquote><pre><code>git stash                    把当前工作现场存储起来,可等以后恢复现场后继续工作git checkout -b bug01        创建一个分支bug01当作bug修复分支,然后在该分支修复buggit checkout master            切换到master分支git merge --no-ff -m "merged bug fix 01" bug01        删除bug01分支</code></pre><hr><h3 id="6-标签管理"><a href="#6-标签管理" class="headerlink" title="6.标签管理"></a>6.标签管理</h3><blockquote><ul><li><strong>创建标签</strong></li></ul></blockquote><p><code>git tag v1.0</code>            创建一个新标签(在当前分支的最近的commit位置)名字为v1.0</p><p><code>git tag &lt;name&gt; &lt;commit id&gt;</code>    在对应的commit位置创建一个标签</p><blockquote><ul><li><strong>查看标签</strong></li></ul></blockquote><p><code>git tag</code>                查看所有标签</p><blockquote><ul><li><strong>删除标签</strong></li></ul></blockquote><p><code>git tag -d v1.0</code>                        删除本地标签v1.0</p><p><code>git push origin :refs/tags/v1.0</code>        删除远程仓库标签v1.0</p><blockquote><ul><li><strong>推送标签到远程仓库</strong></li></ul></blockquote><pre><code>git push origin v1.0            推送标签v1.0到远程仓库git push origin --tags            推送所有标签到远程仓库</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中原子类操作</title>
      <link href="/2018/05/21/Atomic/"/>
      <url>/2018/05/21/Atomic/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote><ul><li><strong>包:</strong> java.util.concurrent.atomic</li><li><strong>特点:</strong> 它提供的方法都是原子性操作,在多线程情况下不会出现线程安全问题</li></ul></blockquote><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><blockquote><ol><li><p>原子更新基本类型        </p><p>如:</p><ul><li>AtomicBoolean             对boolean类型变量实现原子操作</li><li>AtomicInteger               对int/Integer类型变量实现原子操作</li></ul></li><li><p>原子更新数组</p><p>如:</p><ul><li>AtomicIntegerArray      对数组实现原子操作</li><li>AtomicIntegerLongArray</li></ul></li><li><p>原子更新抽象类</p><p>如:</p><ul><li>AtomicReference        对引用类型变量实现原子性操作</li></ul></li><li><p>原子类更新字段</p><p>如:</p><ul><li>AtomicIntegerFieldUpdater    对对象中的<strong>int类型</strong>变量实现原子性操作</li></ul></li></ol></blockquote><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3.实现原理"></a>3.实现原理</h3><pre><code>    public final int incrementAndGet() {        for (;;) {            int current = get();    //第一步            int next = current + 1;    //第二步            if (compareAndSet(current, next))    //第三步                return next;        }    }</code></pre><ul><li><p>逻辑分析</p><ul><li>第一步获取当前的value值current</li><li>第二步对current进行加一操作获得next</li><li>第三步为关键步骤,通过对当前值current与next比较,如果符合预期(即只增加了1),则说明没有被其他线程修改过,此时compareAndSet返回true,否则继续循环尝试更新.</li></ul></li></ul><h3 id="4-简单实例"><a href="#4-简单实例" class="headerlink" title="4.简单实例"></a>4.简单实例</h3><h4 id="4-1简单类型"><a href="#4-1简单类型" class="headerlink" title="4.1简单类型"></a>4.1简单类型</h4><pre><code>//获取自增值的类class Increase{    //public Integer i = 0; //不使用原子类,赋初始值为0    public AtomicInteger i = new AtomicInteger(0);  //使用原子类,赋初始值为0    public Integer getIncrease(){        //return i++;   //非原子性操作,多线程情况下会出现线程安全问题        return i.getAndIncrement(); //原子性操作,不会出现线程安全问题    }}//测试类public class AtomicTest {    public static void main(String[] args){        Increase inc = new Increase();        //线程1        new Thread(new Runnable() {            @Override            public void run() {                while(true){                    System.out.println("result1: "+inc.getIncrease());                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        }).start();        //线程2        new Thread(new Runnable() {            @Override            public void run() {                while(true){                    System.out.println("result2: "+inc.getIncrease());                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        }).start();    }}</code></pre><h4 id="4-2-原子类更新字段"><a href="#4-2-原子类更新字段" class="headerlink" title="4.2.原子类更新字段"></a>4.2.原子类更新字段</h4><ul><li>对象所属类</li></ul><pre><code>public class User {    public volatile int age;    //必须使用volatile关键字    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre><ul><li>测试类</li></ul><pre><code>public class AtomicTest {    public static void main(String[] args){        AtomicIntegerFieldUpdater&lt;User&gt; field = AtomicIntegerFieldUpdater.newUpdater(User.class,"age");        User user = new User();        user.setAge(0);        field.getAndIncrement(user);    //更新age值(自增1),此操作为原子操作        System.out.println(user.age);   //输出age值为1    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中锁的种类--重入锁丶自旋锁</title>
      <link href="/2018/05/20/SimpleLock/"/>
      <url>/2018/05/20/SimpleLock/</url>
      
        <content type="html"><![CDATA[<h3 id="1-重入锁"><a href="#1-重入锁" class="headerlink" title="1.重入锁"></a>1.重入锁</h3><blockquote><p>重入锁又名递归锁,当同一个线程在外层方法已经获取锁的时候,再进入内层方法时会自动获取该锁</p><ul><li><p><strong>优点:</strong> 可以一定程度避免死锁</p></li><li><p>java中的<code>ReentrantLock</code>与<code>Synchronized</code>都是重入锁</p></li></ul></blockquote><h4 id="简单认知"><a href="#简单认知" class="headerlink" title="简单认知"></a>简单认知</h4><pre><code>public class Reentrant{    public synchronized void outOne(){//锁对象为this        System.out.println("One");        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }        //进入该方法内时已经获取到了锁(this),此时再调用outTwo()方法时会自动获取到锁(this)        outTwo();    }    public synchronized void outTwo(){//锁对象为this        System.out.println("Two");        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    //测试    @Test    public void test(){        //执行测试,因为synchronized为重入锁,因此不会出现死锁的情况        new Thread(new Runnable() {            @Override            public void run() {                new Reentrant().outOne();            }        }).start();        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="2-自旋锁-spinlock"><a href="#2-自旋锁-spinlock" class="headerlink" title="2.自旋锁(spinlock)"></a>2.自旋锁(spinlock)</h3><blockquote><p>自旋锁是非阻塞锁,指尝试获取锁的线程不会立即阻塞,而是采用循环的方式去尝试获取锁</p><ul><li><strong>优点:</strong> 不会有线程状态切换,因此响应快</li><li><strong>缺点:</strong> 循环会消耗cpu,死锁问题</li><li><strong>注意:</strong>递归程序使用自旋锁时,不能在持有自旋锁时调用自己,也不能在递归调用时试图获得相同的自旋锁</li></ul></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote><ul><li>使用自旋锁(spinlock)时,临界区要尽量短,不要有显式或者隐式的系统调用(如读写文件操作)</li><li>临界区: 一个访问共用资源的程序片段,当有线程进入临界区时,其他线程或进程必须等待</li><li>存在大量线程,竞争激烈时,不适合使用自旋锁(占用cpu时间)</li></ul></blockquote><h4 id="自旋锁的实现"><a href="#自旋锁的实现" class="headerlink" title="自旋锁的实现"></a>自旋锁的实现</h4><pre><code>public class SpinLock {  private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;();  public void lock(){    Thread current = Thread.currentThread();    while(!sign .compareAndSet(null, current)){    }//当第二个线程调用lock方法时,导致循环一直被执行(自旋),直到第一个线程调用unlock才结束  }  public void unlock (){    Thread current = Thread.currentThread();    sign .compareAndSet(current, null);  }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Lock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-模版设计模式</title>
      <link href="/2018/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="模版设计模式的定义"><a href="#模版设计模式的定义" class="headerlink" title="模版设计模式的定义"></a>模版设计模式的定义</h3><blockquote><p>定义一个操作中的算法的框架,而将一些步骤放到子类中,是的子类可以不改变该算法框架即可重定义该算法的某些特定步骤</p></blockquote><h3 id="简单实例-计算程序运行时间的模版"><a href="#简单实例-计算程序运行时间的模版" class="headerlink" title="简单实例: 计算程序运行时间的模版"></a>简单实例: 计算程序运行时间的模版</h3><ul><li>注意: 一般模版方法都会加上final关键字,不允许被重写</li></ul><pre><code>abstract class TimeTempalte{    //模版方法    public final void getMillis(){    //计算运行时间的框架        long startTime = System.currentTimeMillis();    //记录开始时间        code();        //程序代码        long endTime = System.currentTimeMillis();        //记录结束时间        System.out.println("运行时间: "+ (endTime - startTime));    }    public abstract void code();    //通过抽象方法交给子类具体定义需要计算的程序代码}</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><strong>优点</strong><ol><li>具体细节步骤实现定义在子类中,不会改变整体的结构</li><li>代码复用的基本技术,在数据库设计中尤为重要</li><li>存在一种反向的控制结构,通过一个父类调用其子类的操作,通过子类对父类进行扩展增加新的行为,符合”开闭原则”</li></ol></li><li><strong>不足</strong><ol><li>每个不同的实现都需要定义一个子类,会导致类的个数增加,系统更加庞大</li></ol></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个子类公有的方法,并且逻辑基本相同</li><li>重要丶复杂的算法,可以把核心算法设计为模版方法,周边的相关细节功能则由各个子类实现</li><li>重构时经常使用,把相同代码抽取到父类中</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2018/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h3><blockquote><p><strong>单例模式:</strong> 确保一个类只有一个实例,并提供一个全局访问点来访问这个唯一实例</p></blockquote><blockquote><p><strong>三个要点:</strong></p><ul><li>该类只有一个实例</li><li>可以自动实例化</li><li>必须向整个系统提供这个实例</li></ul></blockquote><h3 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h3><h4 id="1-饿汉式-Eager-Singleton"><a href="#1-饿汉式-Eager-Singleton" class="headerlink" title="1.饿汉式(Eager Singleton)"></a>1.饿汉式(Eager Singleton)</h4><blockquote><p>类被加载时,就创建对象的引用并实例化,当外部需要对象时获取该对象</p></blockquote><pre><code>public class Singleton{    private Singleton(){}    //私有化构造函数(外部无法创建对象)    private static Singleton instance = new Singleton();    //创建对象的引用并实例化    public static Singleton getInstance(){    //提供一个公共的静态方法供外部获取创建的对象        return instance;    }}</code></pre><h4 id="2-懒汉模式-Lazy-Singleton"><a href="#2-懒汉模式-Lazy-Singleton" class="headerlink" title="2.懒汉模式(Lazy Singleton)"></a>2.懒汉模式(Lazy Singleton)</h4><blockquote><p>先创建对象的引用但不实例化,在对象被第一次引用时实例化对象</p><p>需要考虑线程安全问题</p></blockquote><pre><code>public class Singleton{    private Singleton(){}    //私有化构造函数    private static volatile Singleton instance;        //创建对象的引用但不实例化    public static Singleton getInstance(){    //外部获取对象的方法        if(instance == null){    //外层多一次判断,当对象存在时,不需要经过同步锁,提高速度            synchronized(Singleton.class){        //加锁解决线程安全问题                if(instance == null){                    instance = new Singleton();    //对象第一次被引用,实例化对象                }            }        }    }}</code></pre><h4 id="3-Holder模式-推荐"><a href="#3-Holder模式-推荐" class="headerlink" title="3.Holder模式(推荐)"></a>3.Holder模式(推荐)</h4><pre><code>public final class Singleton {    private Singleton() {}    //被调用时才会装载,从而实现延迟加载    private static class SingletonHolder{        //静态初始化器,由JVM保证线程安全        private static final Singleton single = new Singleton();    }    public static Singleton getInstance(){ return SingletonHolder.single; }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlzoo练习答案 -- self join</title>
      <link href="/2018/05/17/selfJoin/"/>
      <url>/2018/05/17/selfJoin/</url>
      
        <content type="html"><![CDATA[<ol><li><p>How many stops are in the database. </p><p><code>select count(*) from stops</code></p></li><li><p>Find the id value for the stop ‘Craiglockhart’ </p><p><code>select id from stops where name = 'Craiglockhart'</code></p></li><li><p>Give the id and the name for the stops on the ‘4’ ‘LRT’ service. </p><pre><code>select a.id,a.name from stops as a inner join route as b on a.id = b.stopwhere b.company = 'LRT' and b.num = 4</code></pre></li></ol><ol start="4"><li><p>The query shown gives the number of routes that visit either London Road (149) or Craiglockhart (53). Run the query and notice the two services that link these stops have a count of 2. Add a HAVING clause to restrict the output to these two routes. </p><pre><code>SELECT company, num, COUNT(*)FROM route WHERE stop=149 OR stop=53GROUP BY company, num having count(*) &gt; 1</code></pre></li></ol><ol start="5"><li><p>Execute the self join shown and observe that b.stop gives all the places you can get to from Craiglockhart, without changing routes. Change the query so that it shows the services from Craiglockhart to London Road. </p><pre><code>SELECT a.company, a.num, a.stop, b.stop FROM route a  JOIN route b ON (a.company=b.company AND a.num=b.num) join stops c on b.stop = c.idWHERE a.stop=53 and c.name = 'London Road'</code></pre></li></ol><ol start="6"><li><p>The query shown is similar to the previous one, however by joining two copies of the stops table we can refer to stops by name rather than by number. Change the query so that the services between ‘Craiglockhart’ and ‘London Road’ are shown. If you are tired of these places try ‘Fairmilehead’ against ‘Tollcross’ </p><pre><code>SELECT a.company, a.num, stopa.name, stopb.nameFROM route a JOIN route b ON  (a.company=b.company AND a.num=b.num)  JOIN stops stopa ON (a.stop=stopa.id)  JOIN stops stopb ON (b.stop=stopb.id)WHERE stopa.name='Craiglockhart' and stopb.name = 'London Road'-- stopa.name='Fairmilehead' and stopb.name = 'Tollcross'</code></pre></li></ol><ol start="7"><li><p>Give a list of all the services which connect stops 115 and 137 (‘Haymarket’ and ‘Leith’) </p><pre><code>select distinct a.company,a.num from route a join route b on (a.company = b.company and a.num = b.num)where a.stop = 115 and b.stop = 137</code></pre></li></ol><ol start="8"><li><p>Give a list of the services which connect the stops ‘Craiglockhart’ and ‘Tollcross’ </p><pre><code>select distinct a.company,a.num from route a inner join route b on (a.company,a.num) = (b.company,b.num) inner join stops c on a.stop = c.id inner join stops d on b.stop = d.idwhere c.name = 'Craiglockhart' and d.name = 'Tollcross' </code></pre></li></ol><ol start="9"><li><p>Give a distinct list of the stops which may be reached from ‘Craiglockhart’ by taking one bus, including ‘Craiglockhart’ itself, offered by the LRT company. Include the company and bus no. of the relevant services. </p><pre><code>select d.name,a.company,a.num from route as a join route as b on (a.company,a.num) = (b.company,b.num) join stops as c on a.stop = c.id join stops as d on b.stop = d.idwhere c.name = 'Craiglockhart'</code></pre></li></ol><ol start="10"><li><p>Find the routes involving two buses that can go from Craiglockhart to Sighthill.<br>  Show the bus no. and company for the first bus, the name of the stop for the transfer,<br>  and the bus no. and company for the second bus.</p><p>Hint</p><p>Self-join twice to find buses that visit Craiglockhart and Sighthill, then join those on matching stops.</p><blockquote><p>主要思路:</p><ul><li>先找出以”Craiglockhart”为开始站的结果集(返回开始路线号,公司名,结束站(start.stop))</li><li>再找出以”Sighthill”为结束站的结果集(返回开始路线号,公司名,开始站(end.start))</li><li>连接2个结果集(连接条件: 结束站(start.stop)与开始站(end.start)相同此时成为中间转一次车的一条线路)</li></ul></blockquote><pre><code>select distinct start.num,start.company,name,end.num,end.company from (   select a.num,a.company,b.stop from route as a   join route as b on (a.company,a.num) = (b.company,b.num) and a.stop != b.stop   where a.stop = (       select id from stops where name = 'Craiglockhart'   )) as startjoin (   select c.num,c.company,c.stop from route as c   join route as d on (c.company,c.num) = (d.company,d.num) and c.stop != d.stop   where d.stop = (       select id from stops where name = 'Sighthill'   )) as end on start.stop = end.stopjoin stops on start.stop = stops.id</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring对多线程的支持</title>
      <link href="/2018/05/16/ThreadSpring/"/>
      <url>/2018/05/16/ThreadSpring/</url>
      
        <content type="html"><![CDATA[<h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h3><blockquote><ul><li>spring3以上版本.<a id="more"></a></li><li>配置(采用java配置方式)</li></ul></blockquote><pre><code>@Configuration            //java方式配置@ComponentScan("cn.com")  //指定注解扫描的包@EnableAsync              //开启对异步的支持public class Config {    //给定一个获取线程池对象的方法    @Bean   //等同于在xml中配置bean    public Executor getExecutor(){        //创建线程池        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();        //设置线程池        taskExecutor.setCorePoolSize(5);        taskExecutor.setMaxPoolSize(10);        taskExecutor.setQueueCapacity(25);  //设置线程池所使用的缓冲队列        taskExecutor.initialize();        //返回线程池        return taskExecutor;    }}</code></pre><h3 id="2-创建多个线程任务"><a href="#2-创建多个线程任务" class="headerlink" title="2.创建多个线程任务"></a>2.创建多个线程任务</h3><pre><code>@Component  //ioc注入public class SpringThread {    @Async  //指定该方法为异步方法    public void threadOne(){        while(true){            System.out.println("one: ThreadOne is run...");            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    @Async  //指定为异步方法    public void threadTwo(){        while(true){            System.out.println("two: ThreadTwo is run...");            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><pre><code>AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);  //根据java配置类创建spring应用上下文对象SpringThread st = ac.getBean(SpringThread.class);  st.threadOne();st.threadTwo();</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中创建线程的几种方式</title>
      <link href="/2018/05/15/Threads/"/>
      <url>/2018/05/15/Threads/</url>
      
        <content type="html"><![CDATA[<h3 id="1-方式一-继承Thread类"><a href="#1-方式一-继承Thread类" class="headerlink" title="1.方式一: 继承Thread类"></a>1.方式一: 继承Thread类</h3><blockquote><p><strong>实现:</strong> 自定义类继承Thread类,重写其run方法,将需要执行的代码放到run方法中去<a id="more"></a></p></blockquote><pre><code>class ThreadTest extends Thread{    @Override    public void run() {        //线程代码        System.out.println("线程执行了...");    }}</code></pre><blockquote><p><strong>使用:</strong> 创建对象并调用其start方法</p></blockquote><pre><code>new ThreadTest().start()</code></pre><h3 id="2-方式二-实现Runnable接口"><a href="#2-方式二-实现Runnable接口" class="headerlink" title="2.方式二: 实现Runnable接口"></a>2.方式二: 实现Runnable接口</h3><blockquote><p><strong>实现:</strong> 自定义类实现Runnable接口,实现其run方法,将需要执行代码放到run方法中去</p></blockquote><pre><code>class ThreadTest implements Runnable{    @Override    public void run() {        //线程代码        System.out.println("线程执行了...");    }} </code></pre><blockquote><p><strong>使用:</strong> 将自定义类对象作为参数传入Thread类对象中去,然后调用Thread类对象的start方法</p></blockquote><pre><code>new Thread(new ThreadTest()).start()</code></pre><h3 id="3-方式三-匿名内部类"><a href="#3-方式三-匿名内部类" class="headerlink" title="3.方式三: 匿名内部类"></a>3.方式三: 匿名内部类</h3><blockquote><p><strong>实现:</strong> 本质同1,2</p></blockquote><pre><code>//1.继承Thread方式new Thread(){    @Override    public void run() {        while(true){          System.out.println("Thread Success!");          }    }}.start();</code></pre><pre><code>//2.实现Runnable接口方式new Thread(new Runnable() {    @Override    public void run() {        while(true){            System.out.println("Runnable Success!");        }    }}).start();</code></pre><h3 id="4-方式四-带返回值的线程"><a href="#4-方式四-带返回值的线程" class="headerlink" title="4.方式四: 带返回值的线程"></a>4.方式四: 带返回值的线程</h3><blockquote><p><strong>实现:</strong> 自定义类实现Callable接口,实现其call方法,可带返回值</p></blockquote><pre><code>class CallableTask implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println("正在计算...");        return 1;    }}</code></pre><blockquote><p><strong>使用:</strong> 将自定义类对象作为参数传递</p></blockquote><pre><code>CallableTask ct = new CallableTask();FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(ct);new Thread(ft).start();  //执行线程Integer result = null;try {     result = ft.get();   //获取线程执行的返回值}catch (Exception e){}System.out.println("计算结果为: "+ result);</code></pre><h3 id="5-方式五-Timer-定时器"><a href="#5-方式五-Timer-定时器" class="headerlink" title="5.方式五: Timer(定时器)"></a>5.方式五: Timer(定时器)</h3><blockquote><p><strong>使用:</strong> 创建Timer对象,然后执行其schedule(时刻表)方法</p></blockquote><pre><code>public void TimerTest(){    Timer timer = new Timer(); //创建一个定时器对象    timer.schedule(new TimerTask() {        @Override        public void run() {     //线程任务            System.out.println("TImerTask is run ...");        }    },0,1000);    //0秒后执行,毎1000毫秒执行一次线程任务}</code></pre><h3 id="6-方式六-线程池"><a href="#6-方式六-线程池" class="headerlink" title="6.方式六: 线程池"></a>6.方式六: 线程池</h3><blockquote><p><strong>使用:</strong> 根据不同需求创建不同的线程池对象, 例如:</p><ul><li><code>Executors.newFixedThreadPool(10)</code>创建固定线程数的线程池</li><li><code>Executors.newCachedThreadPool()</code>创建一个运行时自动扩充线程数的线程池</li></ul></blockquote><pre><code>public void ThreadPoolTest(){    Executor threadPool = Executors.newCachedThreadPool();  //创建一个线程池(自动分配线程个数,不够用时自动创建)    //Executor threadPools = Executors.newFixedThreadPool(10);  //创建一个线程数固定大小(10)的线程池    for(int i=0;i&lt;100;i++){        threadPool.execute(new Runnable() {         //将线程任务分配给线程池中的线程执行            @Override            public void run() {                System.out.println(Thread.currentThread().getName()+"执行了...");            }        });    }}</code></pre><h3 id="7-方式七-spring对多线程的支持"><a href="#7-方式七-spring对多线程的支持" class="headerlink" title="7.方式七: spring对多线程的支持"></a>7.方式七: spring对多线程的支持</h3><blockquote><p><a href="/2018/05/16/ThreadSpring/index.html"><strong>连接地址</strong></a></p></blockquote><h3 id="8-方式八-lambda表达式-jdk8"><a href="#8-方式八-lambda表达式-jdk8" class="headerlink" title="8.方式八: lambda表达式(jdk8)"></a>8.方式八: lambda表达式(jdk8)</h3><blockquote><p>简单介绍</p></blockquote><pre><code>//并行计算public int lambdaAdd(ArrayList&lt;Integer&gt; nums){    //并行计算集合nums进行求和    return nums.parallelStream().mapToInt(i -&gt; i).sum();    //parallelStream为并发流}//并行输出public void lambdPrint(ArrayList&lt;Integer&gt; nums){   //并行输出集合nums的值   nums.parallelStream().forEach(System.out::println);}</code></pre><blockquote><p>测试</p></blockquote><pre><code>@Testpublic void test(){    ArrayList&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();    values.add(10);    values.add(20);    values.add(40);    values.add(30);    lambdPrint(values);    System.out.println("result: "+ lambdaAdd(values));}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
